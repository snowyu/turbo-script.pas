2006-10-2
+ 设计语法树类
   TTurboWord = Class(TCustomTurboModule); //用户自定义单词
     Childs: TTurboWordList; //被 Parser 使用!
     Parent: TTurboWord; //同上. nil means root.
     Variables: TTurbovariableList
     Symbols: TTurboTypeList;
     //根据编译开关将这些列表的类编译进入Memory. 比如如果该模块的Accessor为DBAccessor,那么就只能使用后期绑定的形式编译.
     //还有如果该模块的编译开关要求函数分别
     procedure Compile; 

   TTurboModule = Class(TTurboWord)
     UsedModules: TList;
     Words: TTurboWordList;
   //TTurboVMWord = Class(TCustomTurboSymbol); //机器码只有操作符。也许不必考虑机器码。

2006-9-29
* [uTurboAccessor]
  * rename  uTurboScriptAccessor to uTurboAccessor
  * RegisterAccessor 放入Module管理器了
  + GTurboModuleManager
* rename uTurboScriptConsts to uTurboConsts

通知(释放通知,卸载通知)是否能作为AOP 功能加入?我现在的AOP是基于类添加功能的,换句话说,同一类的不同实例将共享同样的AOP对象.
通知定义: 当对象实例的某事件发生的时候,通知预定了该事件的对象实例.

看样子我必须将基于实例的AOP功能类早日拿出来,不然够呛(不得不在Feature上区分具体是那一个实例):
  TMeCustomInstanceFeature = 基于实例的AOP功能类,这样可以为每一对象实例添加新的属性.
  或者将基于Class的叫做功能类: TMeCustomFeatureClass
  还有一个方法就是修改VMT, 增加Object记录的大小,这样我就可以存放附加数据了.不过这样的话,必须要小心,在注入前不能有任何已经创建的注入对象!
  TMeNotificationFeature = Class(TMeCustomInstanceFeature)
  end;


2006-9-28
!+ 移植到MeScript
!+ 构造编译器中的模块类: uTurboCompiler.pas
   TTurboModule = Class(TCustomTurboModule)
     Childs: TTurboModuleList; //被 Parser 使用!
     Parent: TTurboModule; //同上. nil means root.
     UsedModules: TList;
     Words: TTurboWordList;
     Variables: TTurbovariableList
     Symbols: TTurboTypeList;
     //根据编译开关将这些列表的类编译进入Memory. 比如如果该模块的Accessor为DBAccessor,那么就只能使用后期绑定的形式编译.
     //还有如果该模块的编译开关要求函数分别
     procedure Compile; 
     //放到TCustomTurboExecutor中:
     //property LastWordEntry: PTurboWordEntry;
     //property LastVariableEntry: PTurboVariableEntry;
   TCustomTurboWord = Class(TCustomTurboSymbol);
   TCustomTurboVMWord = Class(TCustomTurboWord); //机器码只有操作符。也许不必考虑机器码。
   TTurboWord_JMP = Class(TCustomTurboWord); //下划线开始的为VM 机器码.
  至于类型我准备用uMeTypes的.

2006-9-27
!+ 建立TurboScript异常处理中心机制

分析 Delphi 异常处理中心机制
分析的结果就是我必须在完成对象等类型处理后,才能进行,它是放在SysUtils单元中..

+ 构思出了 TurboModuleAccessor 架构 in uTurboScriptAccessor.pas

~ 想法简化直接调用Delphi函数,这样就可以直接用Delphi的异常处理机制.直接用是做梦,不过可以参考编译产生的汇编.
开始构思语法树(独立于语言之外的)

2006-9-25
+ TurboModule Stream Header
!+ 构思 TurboModuleAccessor 架构
* [VM] 修订 EnterFar ModuleIndex cfa-addr 改为 MemBase-addr(另一模块的内存基址) cfa-addr
- [VM] 放弃 ModuleIndex 机制，因为我希望我的脚本(Program)能够在内存中并行工作，并且尽量节约内存：我采用的是一个Module只在内存中存在一份拷贝。
  而显然不通的Program ModuleIndex是不同的。所以放弃 ModuleIndex, 转而使用 LastModuleEntry-addr
+ [VM] CALLFAR PTurboModuleEntry cfa-addr: if PTurboModuleEntry = nil means it's self, do not lookup.  
+ TCustomTurboObject: FreeNotification

2006-9-23
~ 装入后的流，以流的大小作为 UsedMemory.
在Executor执行脚本前，必须做的事情有？
 如果希望，接着上次没有完成的地方做，就必须保留 SP, RSP 堆栈指针（放入保留内存？）.
 但是我的堆栈，是整个程序公用的（为了快速交换数据）。所以堆栈指针有可能被别的模块修改。这样保存堆栈指针就达不到目的。
 //数据栈指针、返回栈指针如果不为0，那么必须不能设置。
   没有问题，从内部执行（一个模块调用另一个模块的函数），无影响。但是从Delphi中调用模块函数后，在执行另一个模块中函数，就～～
   想发只允许从 TProgram 中调用执行，每次执行完毕，必须将堆栈指针传递给TProgram.
   在TProgram 中终止脚本执行，必须遍历每一个Executor,设置其状态。不妨将TProgram看作 root Executor，其他则是导入的模块,
怎样在Delphi中调用脚本函数，可以连续调用，能够持续。只需要保证数据栈指针即可。而返回栈除非是调试，否则不必要。

在Executor 上有 Import Modules(uses)： 使用到模块中的函数。还有ChildModules(不过这个似乎只在编译的时候有意义)。
//扁平化处理，只有Program上才存在ChildModules(TList 汇集所有装入的),所有装入的Module实例放在该处。层次化Module名只供查找用。
这里的ChildModules实际上就是 Import Modules 啊！！反正不管，实例只能有一个地方存在！

2006-9-22
~ 发现 如果将 States 控制在一个字节，那么速度将近会提升1倍
  MOV BL, mem 速度要快于 MOV DX, mem，将近快1倍。

~ Used Modules(Import Section):
  LastModuleEntry: Pointer; //last Used module entry.
  LastWordEntry: Pointer;   //所有这些Pointer都是相对FMemory的地址(当装入后是否考虑由装入者对该地址重定位？)
  //Import Module Entry
  TTurboModuleEntry = packed record
    PriorModule: Pointer; //相对地址指针
    ModuleIndex: integer;
    Module: TCustomTurboExecutor; //nil means not assigned(or loaded).
    Name: ShortString; //packed string, full module name with path.
  end;
  暂时不考虑地址重定位，总是作为相对Fmemory的地址存在。
  但是我发现自己很难抵挡住这样的诱惑，重定位后可以提升速度。那么我必须考虑，重定位函数放在那里？
  代码装载到内存后，需要重定位，代码保存到文件或其它地方，也需要将绝对地址转为相对地址。
  RelocateTurboMem(RelatedAddrToAbsoluteAddr)
  procedure TurboConvertAddrRelatedToAbsolute(const Mem: Pointer);
  asm
  end;
  procedure TurboConvertAddrAbsoluteToRelated(const Mem: Pointer);

2006-9-21
* 使用 寄存器作为状态寄存器，但是导致不能命令指令随时停止，所以，在将状态寄存器放入保留内存中，这样，就能命令停止了。EBX 成了临时寄存器。

~ 有没有取得当前执行地址的x86指令？
  答：不能，只能通过Call 间接取得。
+ [VM] 调用 register calling（delphi）写的函数：
  CallReg: register
  CallPascal: pascal
  CallStd: stdcall
  CallFast : fastcall
  如何准备参数？那就必须要知道过程需要几个参数，才能从数据栈中取出需要的个数。也就是我需要得知ProcType, 必须的信息是：ParamCount(以Integer为单位的，不是真正意义上的参数个数)
  CallReg Addr, CallReg 有一个操作数。 Addr 为该函数注册后的索引地址。

~ 外来函数在 TProgram 上注册好，还是在 Executor 上注册好呢？还是在 Executor 上注册好，至于后期绑定的，那就无所谓了，可以自由发挥。
  注册的函数结构： TTurboRegisteredFunctionRec = packed Record //合并后放在 LastWordEntry 中。
  ParamCount: Integer; //以Integer为单位的，不是真正意义上的参数个数
  CallingStyle: TCallingConvension;
  TypeInfo: Pointer; //nil means no RTTI info.: 实际上是一个相对于FMemory的地址。

+ [VM] 当调用其他模块的函数时候，是否需要保存现场？
  至少EDI(FMemory)和ESI(PC:Program Counter)需要保存。堆栈是共用，不需要保存。除非是delphi写的。
  但是我返回的时候？如何才能返回？
  回答：增加Far word, 和 near word, 对于私有过程（只在本模块内有效），采用 near word(默认, Enter, Exit); 对于能被其他模块访问的过程
  则采用far word(EnterFar, ExitFar).
  对于外部过程，调用的VM代码： EnterFar module-index cfa-address， 也就是说，对于near 调用，只需要直接写下地址，但是对于Far调用就必须要OpCode + OpRands
  在保留内存区增加 Index, 用来保存ModuleIndex,这样对于自己内部调用EnterFar，就不必要去查找模块地址了.
  这就是ForthDLL的链接方式调用！

iVMEnterFar:
在返回栈中保存EDI(旧的 FMemory 基址), 根据 ModuleIndex 查找模块内存基址，如果找到就设置EDI成新的 FMemory 基址,然后装入该函数的地址，其它就和VMEnter一样了，转去VMEnter。

  PUSH EDI
  LODSD
  CMP  EAX, [EDI].TPreservedCodeMemory.ModuleIndex
  JZ  @@DoLocalEnterFar
@@GetModuleAddr:
  PUSH EDX
  PUSH ESI
  PUSH EBX
  PUSH EBP
  
  MOV  EDX, EAX
  MOV  EAX, [EDI].TPreservedCodeMemory.Executor
  //function TCustomTruboExecutor.GetModuleMemoryAddr(aModuleIndex: Integer): Pointer;
  CALL TCustomTruboExecutor.GetModuleMemoryAddr
  POP EBP
  POP EBX
  POP ESI
  POP EDX

  CMP  EAX, 0
  JZ   @@NotFoundError
  MOV  EDI, EAX
  JMP @@Exit

@@NotFoundError:
  POP  EDI
  MOV  [EDI].TPreservedCodeMemory.LastErrorCode, errModuleIndex
  JMP  iVMHalt

@@DoLocalEnterFar:

@@Exit:
  LODSD
  ADD EAX, EDI
  JMP iVMEnter

iVMExitFar:
  POP ESI
  POP EDI
  JMP iVMNext

2006-9-20
+ 基本实现 TTurboX86Interpreter 解释器核心
  !+ 没有单步执行 ({$Define TurboScript_Stepping_Supports})
  !+ 返回栈＆数据栈没有溢出判断。 {$Define TurboScript_DataStack_Overflow_Inspect} {$Define TurboScript_ReturnStack_Overflow_Inspect}
  !+ 内存没有溢出判断 {$Define TurboScript_Memory_Overflow_Inspect}
~ 关于控制流程指令：到底转移地址是放在数据栈中还是操作数中？
  想通了，JMP指令操作数放在内存中，GOTO指令操作数在数据栈中，而且GOTO的参数只是绝对地址。
  GetBindingVar(str-addr -- addr) return the variable address(real absolute address). nil means not found.
  GetBindingWord(str-addr -- callingConvention addr) callingConvention 是表明该word的调用类型
  CallBinding (callingConvention addr -- ) 由于该函数可以在其它模块中，所以该地址为真实地址。

2006-9-14
~如果参数栈＆返回栈使用全局内存，好处就是多个执行器可以共享数据，坏处就是多个执行器不能并行执行。
 也许在执行器上面还应有一个类，这个类就可以管理参数栈＆返回栈内存以及参数，这样在这个类上就可以并行执行。
 这个类叫什么好呢？ TTurboProgram:
   TTurboProgram: Execute

记住这里的X86堆栈： 压入则是地址减少，弹出则是地址增加
When an item is pushed onto the stack, the processor decrements the ESP
register, then writes the item at the new top of stack. When an item is popped off the stack, the
processor reads the item from the top of stack, then increments the ESP register

2005-7-19
* 决定不在字符串后面加对齐指令!!是怎么样就是怎么样!!

手工跟踪测试：
PC: CPU的运行指针
IP: FORTH的运行指针

调用核心词汇：iVMNext, 执行当前IP.
(IP) -> W  fetch memory pointed by IP into "W" register
              ...W now holds address of the Code Field(CFA)

IP+2 -> IP advance IP, just like a program counter
              (assuming 2-byte addresses in the thread)
(W) ->  X  fetch memory pointed by W into "X" register
              ...X now holds address of the machine code 
JMP (X)     jump to the address in the X register

2005-7-18
该测试下是否我写的解释器正确！！
* [Bug] 修正编译错误！！

Win32Forth 的数据栈采用的是我所设想的技巧:
数据栈使用的是Hardware栈，不过使用EBX作为实际栈顶。

EBX    <-- TOS Data
数据栈 <-- 第二个数据

(a b -- )
EBX = a
b is in  数据栈.

TIB: Text Input Buffer

修改FORTH解释器的内存映象的结构:
FORTH解释器初始化的时候，先分配的内存：
[cTIBLengthOffset]TIBLength: DWORD (#TIB=1)
[cToINOffset]>IN:DWORD(the current TIB index)
[cTIBOffset]TIB(1024 Byte):原有内存！

从磁盘装入:
[cLastWordEntryOffset]LastWordEntry: DWORD(PForthWord); 指向该程序或单元拥有的单词入口

cTIBLengthOffset = 0;
cToINOffset = cTIBLengthOffset + SizeOf(Integer);
cTIBOffset = cToINOffset + SizeOf(Integer);
cMAXTIBCount = 1024; //Bytes
cLastWordEntryOffset = cTIBOffset + cMAXTIBCount;

我又有点昏了，既然我这里的地址是相对偏移量，那么所有的地址都应该是才对！
因此@等FORTH词汇，也是取的相对偏移量！
如果需要存取绝对地址（外部地址）的数据，应该建立专门的非标准词汇来处理！
所以，我所写的一些词汇要改！！

另外：将TIB作为固定的缓冲区放入FORTH内存中，不错（SP-FORTH 分配的是1024个字节）。
spf_parser.f

必须在系统中实现的核心词汇:
spf_defkern.f
CODE _CREATE-CODE
CODE _CONSTANT-CODE
CODE _USER-CODE (this is SP-FORTH impl, not ANSI-FORTH)
CODE _SLITERAL
CODE _CLITERAL-CODE
CODE _USER-VALUE

其次为: spf_forthproc.f
@, !, DUP, LAST-CFA, ALLOT, DP, HERE, LAST, ",", 

6.1.2450 WORD 
CORE 

        ( char "<chars>ccc<char>" -- c-addr )

Skip leading delimiters. Parse characters ccc delimited by char. 
An ambiguous condition exists if the length of the parsed string 
is greater than the implementation-defined length of a counted string. 

c-addr is the address of a transient region containing the parsed word 
as a counted string. If the parse area was empty or contained no 
characters other than the delimiter, the resulting string has a zero 
length. A space, not included in the length, follows the string. A 
program may replace characters within the string. 

Note: The requirement to follow the string with a space is obsolescent 
and is included as a concession to existing programs that use CONVERT. 
A program shall not depend on the existence of the space. 

See: 3.3.3.6 Other transient regions, 3.4.1 Parsing, 6.2.2008 PARSE , A.6.1.2450 WORD 

It' for the input buffer process(TIB).

: WORD ( char "<chars>ccc<char>" -- c-addr ) \ 94
  DUP SKIP PARSE 255 MIN
  DUP SYSTEM-PAD C! SYSTEM-PAD 1+ SWAP QCMOVE
  0 SYSTEM-PAD COUNT + C!
  SYSTEM-PAD
;

2005-7-17
开始搞核心词汇。

2005-7-15
现在我有两种字符串在FORTH中,并且它们都是会对齐地址边界（基于Pointer的大小计算）：
ShortString: (ByteCount)PChar
String: (IntCount)PChar

function StrToPChar(const aV: string): PChar;
begin
  SHowMessage(IntToStr(Length(aV)));
  Result := Pchar(aV);
end;

procedure TForm1.Button1Click(Sender: TObject);
var
  d: PChar;
  a: pChar;
begin
  d := 'Hello world';

  a := StrToPChar(d);
  {in fact delphi will call the LStrFromPChar to convert the PChar(d) to String!}
end;


重新设定单词结构：
删除掉关于库名的设定。只有单词链表。
至于库不在此处处理。
也就是说LibEntry 变成了Forth Word Entry.

文件头:
MagicWord: 'SUPER4TH'
//类型 TYPE(TSuperForthFileType): 是程序，还是库
NAME：StrLen(Byte): string
版本号：DWORD
日期：DWORD(The Data field indicates the number of calendar days since the start of the calendar (the number of days since 1/1/0001 plus one).)
参数栈大小： DWORD，0表示默认。
返回栈大小： DWORD，0表示默认。未用，使用系统的返回栈。

装入内存的映象:
LibEntry: DWORD(PForthWord); 指向该程序或单元拥有的单词入口

因为要传递数据栈中的数据,所以,SP该是指针，可以指向别人！
不过对动态数组无所谓！暂时就先用动态数组。

2005-7-12
~ 关于连接和调用其它的脚本中的单词的问题。

调用的单元中必须对其进行说明：
ImportWord WordName LibName

放弃在一个程序（单元）中使用多个库多单词的结构。
在我的FORTH中对程序和单元不加区分，以后就统称为
单元，如果在单元中存在Main的单词，那么调用没指定
Word的Execute,就会执行Main这个单词。

只有保存到文件中才存在:MagicWord, UnitName
在流中不存在(为了方便我将VMCode直接写入数据库)

对于非本单元的词的分类：
Forth 词汇
Delphi
DLL

2005-7-11
+ FORTH解释器核心词汇:
  VMFillMem

2005-7-8
+ FORTH解释器核心词汇:
  Enter
  Exit
  Next

2005-7-7
按照 delphi帮助所说，当重新分配的内存块很大，它将会移动该块的地址到能放下的地方！
当移动后，除非是相对偏移量，否则字典中的CFA地址将全部出错！除非对绝对地址进行地址重定位。
另外如果在运行状态，那么对于已经压入堆栈的绝对地址，也会出错。

所以，必须将程序和数据分开才好，或者就只有采用固定大小的内存块。
暂时采用固定内存块，因为它的单词都是PFA。当然需要在运行中动态添加单词的应用毕竟是少数。

当然，如果所有的地址全部都是相对偏移量地址，那么就不会存在地址重定位。但是这样一来，速度
必然会受一定的影响。

在我的解释其实现中，堆栈的方向是向上递增的（压栈），它的栈顶指针总是指向未用的元素。
并且使用的地址全部都是相对偏移量地址.

解释器需要两个运行指针:
1. IP 机器指令的运行指针
2. PC FORTH的PFA解释运行指针

type
  TmMethod = procedure of object;
procedure TForm1.Button1Click(Sender: TObject);
var
  aProc: procedure;
  aT, aMethod: TmMethod;
begin
  //aProc := ;
  aMethod := test;
  aProc := TMethod(aMethod).Code;
  //aMethod;
  TMethod(aT).Code := @aProc;
  TMethod(aT).Data := Self;
  aT;
end;

2005-7-6
如何Cast 数组中的元素：
aLongWord := PLongWord(@Array[3])^
PForthLibEntry := PForthLib(@Array[3])


我相通了，FORTH在内存中的组织，可以根据不同地点具体实现方式不同而不同。
但是文件映像对于任何实现都必须是一样的！
在文件中的组织：
MagicWord: 'SUPER4TH'

类型 TYPE(TSuperForthFileType): 是程序，还是库
NAME：StrLen(Byte): string
版本号：DWORD
日期：DWORD(The Data field indicates the number of calendar days since the start of the calendar (the number of days since 1/1/0001 plus one).)
如果是程序：
  参数栈大小： DWORD，0表示默认。
  返回栈大小： DWORD，0表示默认。未用，使用系统的返回栈。
如果是库：
  参数栈大小： DWORD，0表示默认。未用
  返回栈大小： DWORD，0表示默认。未用，使用系统的返回栈。

LibEntry: DWORD; 指向该程序或单元拥有的单词库入口
  PriorLibEntry: DWORD(Pointer) 文件中的相对偏移量
  LibNameLen: Byte
  LibName: array [0..LibNameLen] of char, the last char is #0
  LastWord: DWORD(Pointer) //the last word. 因为它是一个只能向prior前移动的单向链表。

单词链:
    PriorWord: DWORD(Pointer); //前一个单词 0 means 为最前面。文件中的相对偏移量
    Precedence: Byte; //优先级, 0=low, 1=high equals 1 for an IMMEDIATE word
    //1=True; 0=False; Smudge bit. used to prevent FIND from finding this word
    //this can be extent to private, protected, public, etc
    Visibility: Byte; 
    CallStyle: Byte;
    CodeFieldStyle: Byte;
    ParamFieldLength: DWORD
    NameLen: Byte
    Name: array [0..NameLen] of char, the last char is #0
    //CFA: DWORD //其实就是直接指向的某个单词的PFA，不过那个单词的PFA就是直接执行的机器码而已。
               //CFA = ParameterFields[0]
    ParameterFields: array [0..PFLen-1] of integer(DWORD);

以上为文件中的组织。
_______________________________
  在内存中组织:
  TForthLib = packed record
    Name: string; //1 DWord(Pointer)
    PLastWord: PForthWord; //the last word. 因为它是一个只能向prior前移动的单向链表。
  end;
  //TForthWords = array of TForthWord;
  PForthWord = ^ TForthWord;
  TForthWord = packed record //ITC (Indirect Threaded Code)
    PriorWord: PForthWord; //前一个单词 -1 means 为最前面。
    Name: String;
    Precedence: Byte; //优先级, 0=low, 1=high equals 1 for an IMMEDIATE word
    //1=True; 0=False; Smudge bit. used to prevent FIND from finding this word
    //this can be extent to private, protected, public, etc
    Visibility: Byte; 
    CallStyle: Byte;
    CodeFieldStyle: Byte;
    //ParameterFields: array of PForthWord; //the first PFA is CFA.
  end;

对于编译型FORTH，CFA需要特别关注。因为在原始的ITC运行模式中，CFA直接指向的是执行的机器码地址。
而对于我的编译型FORTH，当加载已经编译的FORTH虚拟机后，如果CFA的执行码在Host中，那么就必须对该地址进行重定位。
那么如何区分CFA（在Host or VM）？
在FORTH Word 头结构中增加 CodeFieldStyle 属性：
cfsHost: the CF is in Host, so the CFA is the index No for the Host. Must fix.
cfsFORTH: the CF is in FORHT, so the CFA is the offset address of the FORTH, no need to fix.

2005-7-5
字典区结构：
1、字典索引区：包含的字典库
  在文件中的组织:
  LibNameLen: Byte;
  LibName: array [0..LibNameLen-1] of char
  LastWordOffset: Integer; //该库的最后一个单词的偏移量.

  在内存中组织:
  TForthLibs = array of TForthLib;
  TForthLib = packed record
    Name: String[31]; //32 bytes
    Words: TForthWords;
  end;
  TForthWords = array of TForthWord;
  PForthWord = ^ TForthWord;
  TForthWord = packed record //ITC (Indirect Threaded Code)
    PriorWord: PForthWord; //前一个单词 -1 means 为最前面。
    Name: String[31]; //32 bytes
    State: Word; //include Precedence bit(equals 1 for an IMMEDIATE word), Smudge bit(the 2nd bit used to prevent FIND from finding this word.)
    CallStyle: Word;
    ParameterFields: array of PForthWord; //the first PFA is CFA.
  end;
  放弃这样的内存组织，清晰倒是清晰，但是速度太慢！
  还是采用分配一个固定大小的内存区域作为字典区(统一放在Memory区)。

注：
  1. 对于非汇编过程,该过程无论是否有参数或局部变量,都会有push EBP; MOV EBP, ESP的动作!
     也就是说如果我想使用一般的过程,就不能将系统堆栈作为参数栈使用！

2005-7-4
为了避免重新计算地址，全部采用相对偏移量！

词汇的数据结构：
Core 词汇: 虚拟机器码 （或者用汇编）实现的。必须的！
System 词库： 以Core词汇为基础编写的，当然也可以用汇编实现，不过为了可移植性，最好两种实现方式都有。

怎么组织Unit？
增加一个Unit指针，类似于词汇指针CP, Context, Last, Current:

称之为字典区(或词汇区),这是单独的一个空间区域，有别于代码区，由ALLOT分配空间。


2005-7-2
在ITC机制下，所有的单词内容都是地址(指向其他单词的CFA的地址)。所以必须有一个简单的解释器（其实称不上解释，因为它把适当的跳转指令早已嵌入到代码流中了“Enter, Exit, Next”）执行。
通过CFA指向真实的机器执行码。
只不过对于用户定义的单词（For all colon(冒号) definitions）中，它的入口单词总是"Enter",出口单词总是"Exit"。

注意：
  * Enter 又的FORTH上称作 DOCOL or DOCOLON。作用是保存当前IP，然后跳转到PFA中的下一个单词执行。
  * Exit 在fig-Forth 中被称作 ;S。作用是恢复保存的IP，然后跳转回去。
  * Next 无论用户单词或系统单词都有的,用在单词的最后.
  * PFA:  Parameter Field address, 用户单词的定义体（单词内容）。

(IP) -> W  fetch memory pointed by IP into "W" register
              ...W now holds address of the Code Field(CFA)

IP+2 -> IP advance IP, just like a program counter
              (assuming 2-byte addresses in the thread)
(W) ->  X  fetch memory pointed by W into "X" register
              ...X now holds address of the machine code 
JMP (X)     jump to the address in the X register

Enter 的伪流程
(the address of the Forth word just entered is kept in W. SEE NEXT)

PUSH IP to Reutrun Stack
ADD W, 3     //Parameter Field address -> W
MOV IP, W
NEXT

Exit 的伪流程
POP IP From RS
NEXT

NEXT 的伪流程
(IP) -> W  fetch memory pointed by IP into "W" register
              ...W now holds address of the Code Field(CFA)
IP + 2 -> IP //(assuming 2-byte addresses in the thread)
(W) -> X  // the machine code address of CFA in W
JMP (X)

关于8086的优化：
   AX = W         DI = scratch
   BX = TOS       SI = IP
   CX = scratch   BP = RSP
   DX = scratch   SP = PSP

Enter:
  XCHG SP,BP  //将系统堆栈指向FORTH返回栈, 注意，如果我系统堆栈作为返回栈该指令就不必!
  PUSH SI     //将IP指针压入FORTH返回栈
  XCHG SP, BP //还原, 注意，如果我系统堆栈作为返回栈该指令就不必!
  ADD AX, 3   //Parameter Field address -> W 我觉得应该是加2才对!!! ADD AX, SizeOf(Pointer)
  NEXT

Exit:
  XCHG SP,BP  //将系统堆栈指向FORTH返回栈, 注意，如果我系统堆栈作为返回栈该指令就不必!
  POP SI     //将IP指针压入FORTH返回栈
  XCHG SP, BP //还原, 注意，如果我系统堆栈作为返回栈该指令就不必!
  NEXT

Next:
  ITC:
    LODSW         // (SI) -> AX  means (IP) -> W, IP++
    MOV CX, [AX]  // (W) -> X
    JMP CX        // JMP (X)

  DTC:
    LODSW   // (SI) -> AX  means (IP) -> W, IP++
    JMP AX  // JMP (W)

== 最重要 AND wonderful DOES> 语句 ==
FORTH 单词定义的Body是由两部分构成的：CF(Code Field) and PF(Parameter Field).
 * The Code Field is the "action" taken by this Forth word, and the Parameter Field is the data on which it acts.
 * The Code Field is a subroutine call, and the Parameter Field is parameters that are included "in-line" after the call. (The assembly language programmer's view.)
 * The Code Field is the single "method" for this "class" of words, and the Parameter Field contains the "instance variables" for this particular word. (The object-oriented programmer's view.) 

Code Field过程总有一个参数――PF参数域的起始地址. CF过程用来解释PFA的内容，是单词，常量，变量，词汇表，等等。
FORTH预定了以下几种Code Field过程。

||    Code Field  || Parameter Field || 
||    routine     || contents        ||                
||    ENTER       || a high-level "thread" (series of addresses)  ||
||    DOCON       || a constant value ||
||    DOVAR       || a storage location for data  ||
||    DOVOC       || vocabulary info (varies by implementation) ||

通过DOES>语句，可以实现自己的Code Field过程。这样我可以很容易的通过扩充Code Field过程实现对Delphi过程以及stdcall,fastcall等等过程的调用。


2005-7-1
uForthCore_80386.pas
包含纯汇编过程.如果公用堆栈,那么就不能调整堆栈的大小了.不过无所谓.就当是自举好了.而且这样可以直接使用Delphi的过程。
因为汇编方法将会始终有一个默认参数（这样始终会有入口代码Push EBP），所以放弃，只用函数库的方式来实现核心词汇。


80386 中 EBP中的用法是作为堆栈的框架指针，快速访问堆栈框架中的中某个参数。

Delphi的前面三个参数放在：EAX, EDX, ECX中！接下来的参数按照从左到右的顺序依次压入堆栈.

function Test(const a: integer; const b: string; const c: TRec; const ok: integer; e: integer = 0): integer;
asm {push EBP; MOV EBP, ESP} //delphi 建立的代码
end {POP EBP; RET};//delphi 建立的代码

进入子程序访问堆栈的参数

[EBP+$04]：为CALL 指令压入的当前IP，供返回的时候用。
[EBP]：为在进入的子过程的时候Delphi压入的旧的EBP值！当退出该子过程的时候会自动恢复。注意仅当过程存在参数的时候才会压入旧的EBP

堆栈中的第一个参数(就是参数表中最后一个参数e): [EBP+$08]
堆栈中的第二个参数(就是参数表中倒数第二个参数ok): [EBP+$0C] 
：

注: 
  1. 如果是汇编方法,那么最后一个参数始终是该对象实例的地址(对于类方法而言则是该类的VMT表的地址)。
  2. 对于非汇编过程,该过程无论是否有参数或局部变量,都会有push EBP; MOV EBP, ESP的动作!也就是说如果我使用一般的过程,
     就不能将系统堆栈作为参数栈使用！

词汇的数据结构：
Core 词汇: 虚拟机器码 （或者用汇编）实现的。必须的！
System 词库： 以Core词汇为基础编写的，当然也可以用汇编实现，不过为了可移植性，最好两种实现方式都有。


2005-6-30
我对FORTH的设想：
几种执行机制都可采用，甚至可以包括Delphi Regiser, stdcall, fastcall等等这被称作调用方式。
在连接后（正式发布无调试信息状态）消除名字信息（Published的除外），只包括使用到的过程。
单词按照库名的方式分类组织。对单词的代码场的内容进行扩充。在调试状态下与原始的FORTH构架基本类似（统一用ITC机制执行）！
不过单词的代码场的内容多了调用方式、指向一下个同名的CFA域、以及参数的说明。
先实现类似解释性,然后在转向实现机器码.

  完整的Forth缓存器有下列六个。
  PSP:Parameter Stack(or data stack) Pointer
  TOS:Top Of Stack
  RSP:Return Stack Pointer
  IP :Interpreter Pointer
  UP :User Pointer
  W  :Working register
  另有其它缓存器，moving forth原文内称为X缓存器，亦有人用A(Addressing)缓存器。
  以下描述各缓存器功能。
  PSP,TOS：为数据堆栈相关缓存器，PSP为管理数据堆栈之指针器。
    而TOS为数据堆栈顶端缓存器，主因为数据堆栈动作量大，但只有一个进出口。
    若将顶端数据留在CPU之中，有加速数据处理的作用。
  RSP：为程序呼叫之返回堆栈指针器。
  IP ：执行Forth word用之地址缓存器，用以指向下次执行字为何，其运作和字典相关。
  UP ：使用者管理用缓存器，为多任务管理用缓存器，指向task作用区。记录其Task相关信息。
  W  ：辅助工作用缓存器，辅助字典动作或运算用。

FORTH编译：就是插入代码流的过程。
FORTH的执行：
  初始化
  根据不同的执行机制执行。我选ITC方式。

注意：在我的虚拟机器中TOS实质上就是 ParameterStackSize.

代码的在内存中的组织：

|Address of CFA|Address of CFA|....|NEXT

2005-6-16
！实现最简单的编译型的脚本执行器：
   只有全局变量，执行体（四则运算，赋值，显示）。
   还需要定义支持的数据类型，其余可以参考 2004-12-14。

2005-3-4
！列举需要实现的Forth核心词汇！

2005-1-12
Flowchart:
  Executor.LoadFromStream
    aFormator := GetPEFormat()
    if Assigned(aFormator) then
    else raise ESuperExecutor.Create(RSInvalidPEFormat);
2004-12-23
1、定义PE文件头格式
  定义类的方法属性
  俺的PE文件映像定义
  也许考虑定义模块: 代码，数据集合。
2、定义执行器类方法属性
3、定义编译器类方法属性

19:33 2004-12-14
任务计划：
1、VM运行器: 装入VM码，将VM码变成机器码直接运行。这样翻译一下就解决了代码重定向问题。
定义数据区域（区域划分）：
  代码区 CodeArea : 存放运行代码。
  数据区 DataArea : 存放全局变量。

  返回栈 ReturnStack: 就是用系统栈
  数据栈 DataStack: Intel CPU 上无数据栈,只有模拟？将寄存器串起来作为数据栈？
    EAX  : 1 POP Stack
    EDX  : 2
    ECX  : 3
    //EBX  : 4 注： EBX 是Delphi保留。
    决定,栈顶由最常用的三寄存器: EAX, EDX, ECX构成，然后其他数据放入系统栈！如果其他数据放入数据栈，有可能会破坏返回栈数据，如何保护？！
    算了，还是单独开辟一个数据区作为数据堆栈。备份EBX，然后将EBX作为数据堆栈指针。EBX=0 栈底
    可以同返回栈共用，不过ESP的入栈是减少一直到0，而数据栈EBX指针是增加一直到EBP（其实如果碰到ESP就不能再增加了！同样ESP如果碰到EBX那么也就不能再减少）。

定义实现的基本指令集:
    inAdd, //Add(n1+n2=n) n1 n2 -- n
    inSub, //subtract(n1-n2=n) n1 n2 -- n
    inInc, //add 1(n1+1=n) n1 1 -- n
    inDec, //subtract 1
    inMUL, //multiply (n1*n2=n) n1 n2 -- n
    inDIV, //divide(n1/n2=n) n1 n2 -- n

    {## Logical instuctions }
    inEQU, //equ(Result := n1=n2) n1 n2 -- T/F
    inNEQ, // not equ
    inLES, //less than
    inLEQ, //less than and equ
    inGET, //greater than
    inGEQ, //greater than and equ
    inNOT, //Negate(NOT)
    inAND,
    inOR,
    inXOR,

    {## Memory Operation Instruction }
    inSetValue,
    inGetValue,
    
    {## Proc Operation Instruction }
    inJMP,
    inJZ,
    inJNZ,
    inCall,
    inReturn,
    inNoop,

    {## Stack Operation Instuction }
    inPush,
    inPop,
    inDrop,
    inDUP,
    inSWAP,
    inOVER,
    inROT
