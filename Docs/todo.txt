iushTODO: 
  1. 必须找到一种重新分配内存（扩充空间）的时候，基地址不变的方法【可能需要在FastMM中找】。
     可以直接使用API调用【或者类似的函数】，然后保留下最大的内存地址范围，即可。
     换句话说，必须要有MaxSize参数设定！
  2. think about how to impl the procedure with parameters, see also CLR.
!+ MaxStackSize directive 设定数据栈的大小。 要修改结构，才能放入,只有在Program和DLL(Package)中才会存在。
    Syntax    {$MaxStackSize  Size[KB|MB] }
    注意：必须放在Program|Unit之后

2007-2-2
~  我想将执行引擎从代码内存镜像中分离出来

2007-2-1
!定下工作顺序： 暂时不忙实现数组列表的形式(Variables...),不过位置预留。
  1. 拆开 StaticClass
  2. 将外部引用从其中分离出来单独，链表
   !+ LastWordRefEntry 外部的方法
   !+ LastVariableRefEntry 外部的变量
   !+ LastTypeInfoRefEntry 外部的类型

2007-1-31
* TTurboPreservedDataMemory 
  * 里面的一些字段调整了下顺序

2007-1-28
* rename TCustomTurboModule.Parent to TCustomTurboModule.Owner
* rename TCustomTurboModule.StoreInParent to TCustomTurboModule.StoreInOwner

2007-1-26
TurboBlock -> TurboStaticClass -> TurboModule
                              |-> TurboClass
TurboBlock: Statement Block. 里面只有代码！抽象该类的目的是供数据库中的过程用，让过程也能单独存放在数据库中。
也就是说 Aceesor 加载引擎必须能支持 TurboBlock, TurboStaticClass , TurboModule 的加载！

2007-1-24
!* 将Module中保存机制(LoadFromStream, SaveToStream)放到Accessor中【不用，还是放在各自的类中，作为流格式】。
!+ 只有Module上才该有 RefList，这样一来在上面的引用外部的汇编咋弄？好像没法弄了
类如果单独保存的话？可以通过Owner连接。

2007-1-19
将类作为基本，难点：
  类本身不分配内存，只有模块才能
  模块是类
  类应该是作为MetaInfo类
如何在MM中，使用Object，建立一个基本类（该类其实就是Object），不出现在文件中,然后所有的从该类派生，但是关键字用的是Class
唉，或者第一版就全部用Class, TObject 基类没有增加任何字段，只是VMT表变大了。不过第1个DWORD总是指向VMT表了。
还是不好办，还是将 TCustomTurboModule 里面的东西抽点出来放在 TTurboModuleInfo(object) 中。

2007-1-9
~ 又有一个idea ti attach the script to the exe:
  Ref/GDataOnFile.pas
  原理是将文件附加在尾部，然后在最后的字节上添加一个标识结构，比如：
  TTurboFileTailer = packed record
    MagicId: array [0..3] of char; //标识： MeFT
    HeaderOffset: Longword; //偏移量，从文件当前位置开始的，指出附加的文件在Host文件的位置： PhyPosition= PositionOf(TurboFileTailer) - HeaderOffset;
  end;

2007-1-5
* the re-struct MetaInfo.Name from PShortString to PChar.

2006-12-25
~ 决定主要使用List表结构存放，和CLR类似，放弃链表结构；在内存动态扩充类可以将表结构的第一个元素作为动态扩充的链接起点【暂时不忙实现】，
  因为我主要是想实现，将字段、方法、类动态绑定到数据库。
~ 决定将所有的数据全部都是看作类，和CLR一样，引入 static 类的概念：
  Module is static class
  Package(Assembly) is static class derived from Module.
~ P1.dpr
  CFA:= iAdd(CFA,300);inc(C);aArray[C] := CFA;
  Debug-Optimal+ IDE: 940
  Debug+Optimal- IDE: 1210
  CFA:= iAdd(CFA,300);
  Debug-Optimal+ IDE: 830
  Debug+Optimal- IDE: 1084
    iAdd(CFA,300); //JITter will compile this method bofore the first call
    QueryPerformanceCounter(tBegin);
    CFA:= iAdd(CFA,300);
  Debug-Optimal+ IDE: 210

~ P2.dpr 
  Debug-Optimal+ IDE: 180
  Debug+Optimal- IDE: 190

2006-12-24
~ CLR模块加载到内存后，它是如何管理代码地址空间的 【2周】
当第一次引用某个类型的时候，根据其Meta信息通过调用类构筑器(.cctor)，才分配内存空间。
~ 俺的程序集：与普通Module一样，只不过编译器将几个文件内容编译成了一个Module文件，但是与普通module文件的扩展名不一样： Lib.
  还是要将程序集分出来，程序集将比MOdule多了清单，以及程序集自身的描述。腰部还是混在一起算了，关键还是要整理出MetaData的结构。
  它的在字符串存放采用的是PChar形式，我也准备采用，因为可能255放不下类型名称。
~ 构造通用的数据结构，让所有的Meta信息都一致。在CLR中使用的是IMAGE_DATA_DIRECTORY的结构装载所有的数据的，

* Compiler Switch: 
  + LoadOnDemand directive
    是否预先加载（引用的）模块，还是按需要加载（仅当脚本调用到模块的过程的时候才去加载）
    Syntax    {$L+|-} or {$LoadOnDemand ON|OFF}
    Default:  {$LoadOnDemand OFF}
    注意：打开按需加载的好处是如果脚本没有执行到某个模块的过程时不会该模块不会在内存中（甚至该模块文件可以不存在），能节省内存，但是影响了效率。


2006-12-21
!+ 讲编译的VM代码直接嵌入Exe，这样可以直接执行，有两种形式：
  1、讲执行引擎（EE）放入DLL中，通过调用DLL的函数： CorExeMain(const aExeFileName: string; const pCmdLine: PChar);
  2、执行引擎直接在Exe中！
  本次实现，将VM块直接放入资源节中(.script). 需要编写一个Exe stub实现上述功能.先实现方式2
  tsrun.exe
    首先试图装入资源（看样子不行，没有找到资料，UpdateResource函数只有在win2000以上的版本用，只有装入新节）中装入
    不行则查找参数行，看有没有文件名。
    找到直接添加资源的资料了，在 XNResourceEditor\ResourceUtils\Source\下的： unitPEFile.pas，unitResourceDetails.pas
    EurekaLog 5 将这两个文件合并成了一个，取消了一些功能，我改成了 uTurboPE.pas
    const cScriptResType = 'SCRIPT'; //资源名以及资源类型名必须大写
    WriteResourceInStream(vExeStream, 'MAIN', vData.Memory, vData.Size, cScriptResType);
    ReadResourceToStream('t.exe', scriptStream, 'MAIN', cScriptResType);
    

2006-12-18
!+ uTurboPEImage.pas
 This unit contains various classes and support routines to read/write the contents of portable executable (PE) files. 
我的目的：生成标准的PE文件，读入标准的PE文件。首先实现将模块放入资源段，这最简单，然后编写一个DLL： tsCoreEE.dll，然后在桩中打入调用该DLL入口执行。
  TTurboPE = object
  protected
  public
  end;

2006-12-17
俺的模块准备分为主模块和模块
主模块就是带有清单的模块。
然后就是实现Table

2006-12-16
~ Namespace 语句和AppDomain以及模块的关系
如果Namespace只是一种结构的话，那么意味着每一进程都将独立装入同样的系统内裤。浪费？
现目前我的模块的实现不也是如此，如果准备实现系统单元。

俺的模块准备分为主模块和模块
主模块就是带有清单的模块。

tsrun test.tpc: 占用内存Working Set 2.052M
.net hello 占用内存Working Set 4.752M

2006-12-15
~ downlaod some perfect CLI e-books:
  Addison.Wesley.The.Common.Language.Infrastructure.Annotated.Standard.eBook-DDU.chm 其实就是 Ecma 但是组织得更好
  Inside Microsoft .NET IL Assembler.CHM
  Applied.Microsoft.NET.Framework Programming.pdf
  Customizing the Microsoft dot NET Framework Common Language Runtime.chm
~ 关于类型的思索，想到字符串，想到引用，为啥必须要引用应该可以让用户自己选择是否需要：
  Array = ComplexType
    
    BaseElementType: TypeInfo;
  end;
  SimpleArray  = 没有引用计数的动态数组定义
  SimpleString    = SimpleArray of Char; //没有引用计数的字符串定义

2006-12-14
~ 自己事务计划
    最近在看CLI架构，发现CLI的许多设想，和俺的架构类似，都是面向堆栈虚拟机，模块化，支持按需加载模块，模块可以不在本机，当然它的模块分类比俺的细致，它区分了程序集模块（assembly）和模块，而我则就是一种模块。设计思想的不同之处在于：
    CLI设想的虚拟机执行机构只能是JITter(即时编译器)，根本没有考虑解释器执行。
    CLI是强类型化的，所有的变量和类型都必须有Meta信息支持。
    CLI的VEE支持垃圾回收机制
    将类放在VM中作为基本类型
    所有的过程全是方法【如何处理类，类是特殊模块？】
    计划：
    
    重点分析它的模块架构，以资借鉴 【1周】
    模块加载到内存后，它是如何管理代码地址空间的 【2周】
    重新构造TurboScript的模块架构 【2周】
    解决代码地址空间管理【2周】
    脚本加载后将所有的相对地址全部重定位成绝对地址，构造 AddressResolver AddressBinding【1周】
    分析类类型，如何实现
    赋值指令和在类型之间值转换
    错误异常处理机构【必须独立，方便更换，初期实现类似Delphi的异常错误处理机制】
    类型对象变量的后期绑定机制
    
    唉，事情真是一大堆啊。

~ 单位事务计划


~ 模块，程序集和AppDomain（Application Domain）
程序集就是DLL或Exe（多了一个RVA主程序入口地址）
模块(Module)类似于以前的单元，用于分割不同的类和类型，以及资源(resource, 资源记录就是字符串，图象以及其它数据，他们只在需要的时候才会被调入内存)。类型的Meta信息也是模块的一部分。

既然模块种包含类型的Meta信息，类型检查系统就可以联合静态和动态技术。当IL运行的时候，执行环境能得知
所有变量参数的类型Meta信息，自然就能执行运行时刻的类型检查――这被称之为 reflection(它的含义为解释自描述类型，类型的影子)。

多个模块文件可以被链接成一个程序集(assembly)。在程序集上多了一个清单（manifest），用来描述该程序集以及模块的列表，一个主入口，导出的类型定义列表（私有模块中公开的类型）。这份清单被放在一个模块上，
在该模块上的公开的类型不会出现在导出类型定义列表上！

程序集是CLI发布管理(deployment managed)的单位。程序集是可重用的软件组件。程序集甚至能动态绑定调用代码。
  * 程序集是独立的软件组件子集，无须重新编译。
  * 程序集是定制软件
  * 程序集能被独立发布
  * 程序集导出的API能和其它组件完美的交互。

程序集在文件系统中是用PE(portable executable)格式存放。

一个程序集将被加载到一个Application Domain(AppDomain)中执行？ 外部引用的其它程序集将在同样同一AppDomain下运行。
换句话说，AppDomain 将程序集聚集在一起，实现最终功能。
每一个AppDomain定义了一个由CLI执行引擎管理的地址空间。所有的地址引用将确保实在同一个AppDomain中。
CLI地址空间是有层次的：AppDomain 能被加载入一个CLI地址空间。
CLI地址空间可以被概略的认为是OS中的进程地址空间（至少在Rotor CLI中是这样）。每一个地址空间都有明确的地址边界。

每一个CLI地址空间可以包含多个AppDomain： 其中一个AppDomain就是系统程序集，另一个AppDomain包含与其他与AppDomain共享的程序集。
只有CLI管理器(the supervision of the CLI)才能跨越AppDomain的地址空间访问进行交互。AppDomain之间的交互通讯是通过远程(Remoting)类型检查机制
完成。同样的机制被用于跨越地址空间，如接口和OS IPC.

模块，程序集，AppDomain和地址空间（address space）的关系是，模块是编译器建立的最小的单元文件，由一个或n个模块组成程序集，程序集是进行分发的
最小单元文件，程序集能组合在一个AppDomain下执行。多个AppDomain能在单个地址空间下执行。

【问】如果对其它程序集过程的调用，意味着需要开辟新的VirtualExecutionEngine?,堆栈这些全部都要新的？？

注：
Common Language Infrastructure (CLI) 通用语言基础组织

2006-12-11
* TCustomTurboModule
  + FMaxMemorySixe
  + FMaxDataMemorySize
  -1 means the max size is equ used memory size when save the module stream 
  我只是当成标志用，在保存的时候判断下是否-1如果是就节约内存。


2006-12-7
~ 需要编写赋值语句
!+ 模块编写，嵌入模块指令， import XXX 该指令将XXX模块合并到其中！
  + ImportModules: string; 包括了所有合并进来的模块名称，用逗号分隔.  ,XXX1,XXX2,XXX3,
    然后修改查找模块的方法。
  + 划分出设计时间用的单元【所有语法符号都会被编译】，和运行时间用的单元【只有公开的使用的才会被编译】。
~ 我的用户错误处理入口挂接是在全局参数上，该怎么访问？

2006-12-6
+ 继续编写Assert错误处理。
  断言编写完毕，不过俺是显示断言信息，当断言为假的时候。应该改为断言为假的时候显示信息，并终止执行。
  已经改正！当断言为假触发，运行时间错误errAssertionFailed，然后终止执行。
  当异常机制完成后，就该是触发 EAssertionFailed exception 了。
* TurboForthCompiler 过程调用支持这样的格式 Assert(False, 'helo'); 编译自动转换，首先压入参数，最后调用。参数第一个是栈顶，第二个是次栈顶，依此类推。
  测试通过
~ 明天开始弄异常机制。
 
2006-12-5
+ TFCC 在FPC下编译通过，不过需要更改，我发现FPC的集合类型似乎是用的Int32而不是Byte!!
~ [FPC] 2.0.4 中汇编最好使用 [EAX+TRec.F] 的形式而不是用 [EAX].TRec.F! 两者的结果不一致！ FPC 的 Self 指针是用ESI！

2006-12-4
~ 查了，证实CLR的过程调用的参数传递走的是数据栈。
  怀疑，C#自动判断了参数栈最大尺寸，建立 .MaxStack 的大小。

2006-12-3
+ TurboForthCompiler 过程调用支持这样的格式 Assert(False, 'helo'); 第一个是栈顶，第二个是字符串，依此类推。然后编译器自动转换为：
  push 'Hello'
  push False
  Call Assert
~ 如何使用绝对地址而又不担心基址改变的方法：那就是在运行时刻固定住MaxCodeSize，内容的变化范围不能超过MaxCodeSize！

2006-12-2
~ 异常机制，分析Delphi的异常机制
~ 是否该考虑嵌入单元了，这样俺的系统单元才能出来。
  主程序模块：一个可运行脚本有且只有一个主程序模块，主程序模块将自动嵌入 System 单元。
  初期灭有这样复杂.
* TTurboGlobalOptions: 以后这些参数放入系统单元的。
  + ErrorAddr: Pointer;
  + ErrorProc: Pointer;
  + AssertErrorProc: Pointer;
  + IOResult: tsInt; //The built-in I/O routines use InOutRes(ult) to store the value that the next call to the IOResult standard function will return. 
+ Compiler Switch: 没法子，COCO PRAGMAS不能存在注释中，我暂时将参数作为可选项放在头部。
  + Assert directives
    Syntax	{$C+} or {$C-}
            {$ASSERTIONS ON} or {$ASSERTIONS OFF}
    Default	{$C+}
            {$ASSERTIONS ON}
    Scope	  Local
    和Delphi类似，如果关闭，则不会编译Assert过程。
    要想使用断言，必须使用参数，可以这样编译，增加过程参数，然后翻译，比如: 将语句Assert(False, 'helo'); 自动翻译成：
      Push False; Push 'Helo'; CALL Assert
  + MESSAGE directive
    Syntax    {$MESSAGE  HINT|WARN|SYNTAX|SYMANTIC 'text string' }
    Examples: {$MESSAGE 'Boo!'}                   emits a hint 
  + MaxCodeSize directive
    Syntax    {$MaxCodeSize  Size[KB|MB] }
    注意：必须放在Program|Unit之后
  + MaxDataSize directive
    Syntax    {$MaxDataSize  Size[KB|MB] }

哈，我找到了可以通过InternalGrammarComment 事件拦截注释：
  InternalGrammarComment := ProcessGrammarComment;
procedure T-->Grammar<--.ProcessGrammarComment(Sender : TObject; CommentList : TCommentList);
var
  vOptionName : string;
  vEnabled : boolean;
  ParamList : TStringList;
begin
  //Process Compiler Options here
  SetCompilerOption...
end;
搞定,这下指令可以到处写了！支持如下几种格式：
  {$CompierDirective[+|-] param1, param2, ...., paramN}
  {$CompierDirective [ON|OFF] param1, param2, ...., paramN}


2006-12-1
今天完成将atg里面的简单的移植到语法树【遇到麻烦，反正都要改，算了还是先折磨异常机制，暂时不忙慌写语法树，等更成熟些再说，俺看了书再来】
编译流程 
  ForthCompiler 建立语法树
    ProgramSymbol.Compile; 编译
      首先编译主过程：事实上在ForthCompiler建立语法树的时候已经编译了。
      然后是过程：对于 Published 的过程不管有没有引用都将编入内存。
      然后编译变量和常量：
      最后编译类型信息：
      最后在解决地址空位 ResolveRefs。
~ 碰到问题了，如果将Word的过程体指令直接编入内存，那么里面的地址引用就是一个问题！必须将指令也转为符号管理。
  还有一个办法就是将定义的所有Word直接压入主内存区，这样地址自然就都存在了，然后如果定义了优化参数，
  另外建立一个内存区，在处理！
  管它的，现在就不管这么多，全部直接压入！以后再来折磨这个语法树。

2006-11-30
~TODO: 
  将atg里面的简单的移植到语法树
  整理提取适当的方法名称
  实现Delphi类似的异常机制
  实现字符串处理
  实现字段（变量）后期绑定、过程（方法）后期绑定
    GetBindingField PString, GetBindingMethod PString
    然后在指令处理中还要根据模块类型，决定是否添加模块名称前缀在字段名前
  构思宏类，所谓宏类就是存放于数据库中的类【抽象出来的知识】

~ 编译标识符
  可以分为标识符本体编译，和标识符的引用编译。
  常量除开字符串常量外，没有本体！
  变量的本体就是变量数据所在地址空间，引用编译则是将该数据地址编入代码区内存。
  过程的本体就是过程的代码，引用编译就是将过程的入口地址编译到指定的内存。
  编译本体的方法：
    CompileTo() 将标识符本体编译（添加到）到指定的模块。
    ReferenceTo(aMem: Pointer): 将标识符引用编译（添加到）到指定的地址，注意你必须保证有足够的空间容纳该地址。

2006-11-27
* [BUG] FastMM4 俺更新到11-09号4.74版本，最后一个内存泄漏就没有！
* TurboForthExpr.atg 初步修改使用语法树。
+ TTurboPreservedDataMemory.ModuleOptions: TTurboScriptOptions;
+ TTurboScriptOptions.soTypeSafety
  当模块有这个参数的时候，编译器将强制把所有标识符的的类型信息(RTTI)编入内存。
~ 需要增加一个语法，用来注明该标识符需要编入RTTI信息。注：如果模块有soTypeSafety，
  那么不管有没有该语法，都将强制编入RTTI信息。就叫 Typed 吧.
  : [Public] [Typed] Word1;
  Var [Public] [Typed] Variable1;
~ 如果我不需要SimpleType，那么该如何？需要TypeInfo. 这样我还需要将基本类型全部联入才行。
  打造 System 单元？考虑象Delphi那样，有包编译方式【尺寸最小】和普通编译方式。
  Use System, XX; //是DLL调用方式 不会嵌入
  Imports System, XX; //是嵌入方式。对于System 单元默认是嵌入方式，除非明确指定。
  ProgramSymbol -> ModuleSymbol

~ 关于类型的Size，有固定大小的类型，如Int32等，有非固定大小的类型：序列。
对于非固定大小的类型，需要变量实例才能确定其真实的大小。
  SizeOfVar(Var), SizeOfType.怎么提取公用性？在TypeInfo中添加方法：
  function Size(aVariable: Pointer): tsUInt;
  如果要想在用户自定义的类型中也能如此，那么就必须使用虚方法，这是真的么？我觉得不是，我可以专门定一个用户自定义类型的类，然后
  在该类中添加一个静态Size方法。

2006-11-26
* CALLFAR 指令直接指向 TurboModuleInfo, 而不是ModuleEntry.
* 将数据区和代码独立，测试通过，现在Code区只有代码！
~ 模块、类、类实例 的区别
  模块可以直接使用，类不能。类实例的每一个数据都是新建的【可以从类的数据中复制】，共享代码区。
  是否考虑类实例的数据从堆中新建，而不是从DataMemory中复制，不过这样一来又增加了复杂度【俺编程苦啊，还是简单点吧，将DataMemory既作为MetaData也包括类字段数据】？
  还有和过程的区别？过程的 Parent 是模块或类。过程没有只有代码区，没有数据区（或者说是公用父亲的数据区存放Meta数据）
    也就是说，过程不能独立于模块或类存在。
  模块类别可以是：过程模块【整个模块就是一个过程】mtFunction； 容器 mtModule； 类模块【整个模块就是一个类】mtClass； 模块类实例【整个模块就是一个实例】mtObject
  mtFunction: 和 mtProgram 类似，但是MUST HAVE Parent. 是通过LastWordEntry链表挂上的。
              嗯，在LastModuleEntry中也有，所以应该是在LastModuleEntry中加载，然后设置好父亲信息，如果父亲Free则必须跟着Free。
              它的过程入口CFA就挂在InitProc上，FinalProc没有用。
  mtModule:
* [Bug] TCustomTurboModule.NotifyModuleFree() 当Parent释放后，儿子没有跟着被释放。
  
* [Bug] Memory Leask: 
  TCustomTurboModule.FModuleUnloadNotifies 忘记释放
  [uTurboAccessor] FTurboModuleMgr 忘记释放
  [uTurboAccessor] TTurboModuleAccessorList 里面的Accessor 忘记释放。
~ 先构建最简单的语法树：
  对于Word该如何把握还真是头疼啊。涉及到的问题有：
  如果单独空间编译过程体，涉及到的其它过程地址的定位问题。还有引用的模块、变量地址
  干脆一个过程作为一个Module：
   然后如果该过程被用到再复制。
   那么引用变量的问题如何解决？
   对于语法树中的我只需要分配代码区,而数据区则公用模块的。该如何在CustomTurboModule中体现？
   由于在汇编中没有过程的局部变量，所以可以不管。
   TTurboWordSymbol= 
     Parent: ModuleSymbol; 就是y拥有它的Module
     Word: TCustomTurboModule;
   TTurboModuleSymbol=
     Module: TCustomTurboModule;

2006-11-25
* 数据区和代码独立，要想复用代码还必须要：
    不能在代码区保存数据区的地址，而应该在数据区中保存代码区的地址！
    当然，这样一来速度必然会降低【错误，速度不会降低，这个很少用到，我由专门的寄存器负责IP】。
    把所有的参数都放入数据区，那么代码区就没有头结构了，全部都是代码！不能在代码区中开辟空间作为快速变量区，因为代码区是复用的！
    只能在数据区中开辟空间作为快速变量区。
- TTurboPreservedCodeMemory 参数全部移动到 TTurboPreservedDataMemory。

~ 规范汇编的 TTurboVisibility :
  fvHidden: 只能由本模块调用，近调用，该过程不会被连接到LastWordEntry中！没有Name信息。
  fvPrivate: 只能由本模块调用，近调用，该过程会被连接到LastWordEntry中！一般没有Name信息。
  fvProtected: 只能由本模块以及从该模块的子模块调用，远调用，该过程会被连接到LastWordEntry中！一般没有Name信息。
  fvPublic: 任意模块均可调用，远调用，该过程会被连接到LastWordEntry中！一般没有Name信息。
  fvPublished: 任意模块均可调用，远调用，该过程会被连接到LastWordEntry中！有Name信息。
~ 汇编模块编译链接规则：
  Word(过程):
    fvProtected..fvPublished 的全部会被编译； 
    fvHidden..fvPrivate,没有引用的，不会被编译。
  常量，变量： 只有使用到的才会被编译入模块。

!+ 俺需要编写一个最简单的能产生代码片段的编译器。
  能编译常量变量和已知过程。
  TTurboWordSymbol.Compile(const Src: string);

  TTurboModelSymbol(TTurboWordSymbol.Parent)

语法树搞定后，就该弄数据库对象。

2006-11-24
~ 将数据区和代码独立的好处：
  1、建立外部对象，只需要复制数据区，公用代码区即可！
  
  对于分散在数据库中的对象的方法，只要从子类逐个查到父类，就是重载了。
  暂时不思考对象，首先整理，然后建立基本语法树在说。

2006-11-21
~ 关于 JIT 即使编译器是可行的，保留内存区头部和数据区即可。
!* 将所有的TXXXRntry 修改成如下的结构：
  TTurboWordEntry = record
    prior: PTurboWordEntry;
    Value: TTurboWordInfo;
  end;
!* 将 DataMemory 改名为MetaData,表示专门用来存放Meta数据？算了额还是不改吧，字符串这些都在里面的。
 但是名称怎么取呢？？
!* 将以下这些移到 DataMemory中。
   TTurboPreservedDataMemory = packed record
    InitializeProc: Pointer; //it is the offset address of the FMemory
    FinalizeProc: Pointer; //如果是模块的话
    //last Used(import) module entry.
    LastModuleEntry: PTurboModuleEntry;
    //有名字的函数链表，指向最后一个函数入口。
    LastWordEntry: PTurboWordEntry;
    //有名字的变量链表
    LastVariableEntry: PTurboVariableEntry;
    //RTTI TypeInfo 链表
    LastTypeInfoEntry: PTurboTypeInfoEntry;
    //reserved: array [SizeOf() ] of byte; 
   end;
~ 关于VMT表，虚方法表，到第用连接的形式，还是用的表的形式，表的形式，速度快，但是无法动态添加新的虚方法～～
  我有注意了，哈哈，我想到DynamicMethod，凡是需要动态添加的方法，就是用动态方法，和Delphi类似，嘿嘿这样就解决了
  速度和动态添加的问题。


2006-11-15
~ 使用链表的意义在于可以在运行时刻快速的添加新的过程到模块而不必惊动编译器进行编译，这样极大的提高了速度。
  现在剩下的问题就是编译时刻的Meta信息和运行时刻的Meta信息的侧重点不一样，如何处理？
  TTurboMetaInfo = object //for typecast the memory.
  TTurboSymbol = class //for compiler
    FMetaInfo: PTurboMetaInfo; //通过连接的形式
  end;

终于明白自己为什么在Type定义这里卡住了原因，混淆了Delphi编译中使用，和让自己脚本本身能使用类型两个目的！
!+ 定义于Type有关的指令，将TurboMetaInfo作为Delphi写的编译或供外部【Delphi】使用。
   然后逐步过渡到使用脚本来写编译器。嘿嘿。
   VarType (var-addr -- varTypeAddr)
   现在我为啥需要编写TypeMetainfo，是因为编译的需要，建立语法树的需要！！所以~~~暂不管指令实现！


~ 使用外部变量来表述该变量是运行时绑定的: var [external] myvar。

!+ uTurboMetaInfo.pas  [将XXXEntry 里面的数据分离到本单元]
  the turboScript basic metadata for type, constants etc.
里面的字符串全部使用偏移量指向PShortString!
是否启动virtual 方法，也就是使用动态对象，这样的话，必须保留第一个字段指向VMT, 而且必须在装入后对该地址重定位。如果不用就没有VMT表！
先不管，做下去，看需要而定！
  //定义最基本的类型，所有的用户扩展类型，全部都是由下面的基本类型派生的！！
  TTurboTypeKind = ();
  TTurboMetaInfoRec = record
    VMT: Pointer; //使用动态方法
    TypeKind:  TTurboTypeKind;
    Name: PShortString;
  end;

  //the abstract 
  TTurboMetaInfo = object
    TypeKind:  TTurboTypeKind;
    Name: PShortString; //point to the offset
  end;

2006-11-13
!+ uTurboSymbols
  TTurboMetaData: in fact the symbols are the metaData. 最后我觉得还是命名为 TurboSymbol 吧。
  TTurboType = Class: the abstract turboScript base type.
  TTurboConstant = 
  TTurboVaraible = Class(TTurboConstant)
  
!+ uTurboTypes
~ 重新规划保留区内存：
  内存分配：
    代码区分为两部分，前面部分为系统数据区，保存模块参数。注意系统数据区编译好后就不能改变！除非重新编译。
    更改数据区为：MetaData数据区，用来保存类型信息，模块变量【字段】，字符串常量。
  文件流中：
    MetaData字段 保存的是MetaData在流中的偏移量。GlobalOptions 为MetaData大小。Executor 为代码区在流中的偏移量。
  TPreservedCodeMemory = packed record
    MetaData: Pointer; //point to the data memory.
    GlobalOptions: PTurboGlobalOptions;
    Executor: TCustomTurboModule;
    //##abondoned:this Module unique Index in this program, allocated by compiler.
    //##ModuleIndex: Integer;
    ModuleType: TTurboModuleType;
    UsedMemory: tsInt; //实际使用的大小
    MemorySize: tsInt; //分配代码区的大小
  end;
  
  //模块 MetaData 数据区前端内存分配
  TTurboMetaData = record
    InitializeProcEntry: PTurboProcEntry; //it is the offset address of the FMemory
    FinalizeProcEntry: PTurboProcEntry; //当从内存中unload之前被调用如果存在的话。
    //last Used(import) module entry.
    LastModuleEntry: PTurboModuleEntry;
    //有名字的函数链表，指向最后一个函数入口。
    LastWordEntry: PTurboWordEntry;
    //有名字的变量链表
    LastVariableEntry: PTurboVariableEntry;
    //RTTI TypeInfo 链表
    LastTypeInfoEntry: PTurboTypeInfoEntry;
  
  end;

  PTurboProcEntry = ^TTurboProcEntry;
  TTurboProcEntry = record
    Prior: PTurboTypeInfoEntry; //nil means no more
    Proc: Pointer;
  end;
  TTurboTypeInfoEntry = record
    Prior: PTurboTypeInfoEntry;
    TypeInfo: PTurboType;
  end;

//废弃：
PackageInfoTable: see system.pas:
  PackageInfo = ^PackageInfoTable;
  PackageInfoTable = packed record
    UnitCount : Integer;      { number of entries in UnitInfo array; always >= 0 }
    UnitInfo : PUnitEntryTable;
  end;
  { Compiler generated table to be processed sequentially to init & finit all package units }
  { Init: 0..Max-1; Final: Last Initialized..0                                              }
  UnitEntryTable = array [0..9999999] of PackageUnitEntry;
  PUnitEntryTable = ^UnitEntryTable;
  PackageUnitEntry = packed record
    Init, FInit : Pointer;
  end;


2006-11-12
!+ 定义最基础的数据类型：
  按用途来说： Type, Contant, Variable, Statement
  按Type来说： Integer, Float, String, Array, Record  //, Sequence(序列)
  分析清楚这些最基本的MetaType，我才能在运行时刻定义新的数据类型.
  【这只是一种尝试，暂缓构思】
  TypeDef
    Sequence = Type //也许这个类型该放入基本类型
    Grammar:
      '[' Element {, Element} ']'.

    Protected
      Count: Integer;
      Element: Type;
      Contents: array[1..Count] of Element;default;
    end;
    If = Statement
    Grammar:
      'IF' BoolVar:Identity 'THEN' DoThenStatementBlock:StatementBlock  'ELSE' DoElseStatementBlock:StatementBlock
    end;
  类型定义:
    Integer(Ordinal): Int8(1byte), Int16(2Byte), Int32(4Byte), Int64(8Byte); 
             UInt8(unsigned 8-bit integer), UInt16, UInt32, UInt64, 
             Boolean, Char(1Byte), WideChar(2Byte)
    
  Float: float32(Single), float64(Double).
  String:
  
!+ 构思语法树(=就是 TypeInfo):
  语法结构不是等于类型，而是类型是语法结构中的一种！
~ 阅读了 CLR扩展PE结构分析 后，发觉我完全可以参考 metadata中的#~流【heap】来实现我的类型流！
  不过它把所有的名称字符串单独放入一个堆中，效率？当然在流中的时候肯定是该堆的偏移量。

2006-11-11
* TTurboVMInstruction prefix from in to op
~ 是否所有的控制指令都使用偏移地址？CLR就是全部用偏移量！
  暂时不管吧！
!+ TTurboAddressRelocator： 哈，我想到了，可以将重定位功能放到 TPreservedCodeMemory 上面，呵呵我真聪明。
   代码区地址重定位：
     【本地】Call 地址
     【本地】变量地址
   数据区地址重定位：
     为了能够在运行时刻动态添加新类型和方法过程，所以将类型、过程链表等结构放在数据区。另外我的主要设计目的是编译时刻的速度
     所以那个需要在运行时候添加过程肯定稍微慢些。
     【2006-11-12】今天又想了下，其实可以不用链表的形式，对于编译时刻定义的类型过程可以用数组的形式在代码区前面确定下来，这样代码区实际上由参数区，类型定义区，代码区构成。
                   然后，运行时刻添加的类型过程，放入堆中。
                   很显然，这样一来，Data区就没有必要存在了，因为模块变量也可以用这样的数组形式固定在代码区。而运行时刻的新变量则只在堆中。
        

2006-11-8
* 分离代码区数据区
  * 重新调整文件结构
    将数据区放在代码区后面，数据区的偏移量 ＝ SizeOf(StreamHeader) + UsedMemory + 1。
  + TCustomTurboModule.DataMemory
  + TPreservedCodeMemory.Data
  * TCustomTurboModule
    * FindXXXEntry
    * LoadFromStream, SaveToStream, Reset
    + DataMemorySize
    * LoadUsedModules
    + UsedDataSize
    + AllocDataSpace, GrowData, AddXXXToData
  * TX86Interpreter
    CallFar, EmitString, EmitLString, FetchXXX, StoreXXX
!* 重新整理VM指令集
!+ 运行时刻将指令中的变量相对地址变为绝对地址
   + GetTurboInstructionLength(aOp: TTurboInstruction): Byte;
   + TTurboAddressRelocator
     + TranslateYoRelated
     + TranslateYoAbsoluted

2006-11-7
~ 【x86ASM】TEST :  AND imm8 with AL; set SF, ZF, PF according to result
* [Bug] ForthCompiler: 对于定义为>= Protected 的单词，需要使用远调用！
* [Bug] ForthCompiler: LastModuleEntry 忘记连接了。
* [Bug] 对齐算法有错误，造成有时变量无法存入数据！
* [TurboModule]  终于决定将 CPU States 移到全局参数中！
~ TurboScript 子过程模块之间的VM DLL远调用效率
  : Add external 'test'; //该函数在另一文件中。
  结果运行时间：1082 <如果不使用Cache功能每次都要查找：2676>
  使用的是按需加载技术，也就是仅当该函数被调用的时候才加载，然后加上Cache技术，后面的调用就在内存中处理。
* [TurboModule] 加上soLoadOnDemand参数功能，控制是否使能按需加载，在装入的时候判断，如果没有使能按需加载，就在这个时候将DLL装入。
  要不在模块上也加入这个参数呢？？
~ TODO:
  * 分离代码区数据区
  * 增加地址重定位器，当处于非编译状态时，地址为绝对地址（包括代码数据中的所有指针）。而当切换到编译状态的时候地址为相对地址。
    * 修改 X86Interpreter, 适应新的绝对地址，这样速度又将提升。
  * TypeInfo: 抽象基本类型，类型定义
  * 变量后期绑定，Word后期绑定
  * 改写汇编编译器，采用语法树生成代码，而不是现在的直接生成。
    * 制定Word参数类型（这样能实现对过程参数的语法检查）
  * DLL 远调用， Host 远调用
  * 制定类的底层规范
  * 制定异常处理机制
  * 制定高级语言规范
  小任务：
    * 完善单元初始和终止过程链
    * 增加编译开关：(Max)MemSize; (Max)ParamStackSize, (Max)ReturnStackSize, (Max)DataSize
      有个问题如果在文件里也有定义，到底是以命令行为准，还是以文件，我想是以文件！

2006-11-6
!* [Bug] !Tick 出现问题，值没有能保存进去！
* [VM] Forth DLL 调用初步测试通过！
* [Bug] 使用Unit的时候 全局参数 忘记 需要设置！！
* [Bug] ForthCompiler 对于Published 的定义的单词应该是用ExitFar!
  为了设置该参数，还是只有让Executor创建对象！！
~ ModuleFileAccessor
  如果要考虑支持树型Module名称： Module1.SubModule1.SubModule2，那么必须要有
    BasePath: 用于指明项目的库的基本Root目录，同时需要增加编译开关: "-Base:"，用来在编译单元的时候指明该单元的Base目录。
    SysPath: 用于指明TurboScript系统的Root目录
  搜索顺序为先找BasePath,再找SysPath. 这样BasePath就可以重载SysPath中的内容。
  为了测试，先不管这些，只实现flat Modules.
~ 注意ModuleEntry中的单元全部都是真实的需要引用的单元，对于那些直接嵌入的单元在运行时刻中是并不存在的。
  而对于真实的单元（类似于DLL），Module.Parant属性是没有用处的（它的目的是为直接嵌入的提供到底嵌入到哪里）。
  既然如此那就无所谓了，还是让Accessor 负责创建Module。
~ [奇思妙想] 将FastPrint控件包改造成能够编辑录入的界面设计系统。

2006-11-5
* ModuleAccessor 需要得知是用哪一种Executor Class,要不我把这个责任扔回去？
  * RequireModule 增加一个参数:
   + aModuleClass: TTurboModuleClass
   这样似乎不行啊，还是只能让上面一级（TurboModule负责创建，否则Create的参数无法设置！！）
* [ForthCompiler]
  + display error infomations on the console.
  + the switch options: -ge : generate the deatil error list file (*.lst)

2006-11-4 
~ 关于后期绑定，内部实现的初步设想是返回一个aBindingHandle，然后操作该handle.  FindVarBinding('aVarName'， aBindingHandle， pValue); 
   SetVarBinding(aBindingHandle) //变量被修改。
   不过，建议还可以参考CLR的实现，如果能找到的话。
~ 异常：采用表的形式，而不是嵌套堆栈的形式来存放异常处理过程，这样做的好处是：执行的时候不用在堆栈中压入处理过程，加快执行速度，缺点是错误发生的时候，查表速度慢。
  + 全局参数中加上 ExceptionProcessor: 指向该模块的异常处理中心的地址【该地址为"System"单元的过程偏移地址,也许该地址为绝对地址由主程序单元在初始化的时候设置更为妥当？】。
  + TurboWrodEntry中加上 ExceptionProcessBlock 字段指明当错误发生的时候该跳转到哪里去进行该处的异常处理？但是嵌套异常如何办？？嵌套异常全部写入该块中，并注明拦截的终止地址即可。
    try.finally 和 try..except的异同：都是捕获异常。
    try.finally 执行完成finally 的语句照样触发异常,跳过finally后面的语句退出过程；
    try..except 执行完成except 的语句后，如果没有raise不会触发异常，后面的语句照样执行；
  【注意：如果该单词不在WordEntry上那么就无法进行异常处理】
~ 关于远调用，先只实现  Forth, stdcall, pascal 三种，stdcall, pascal由于参数全部在堆栈所以根本无需要知道参数的个数，只需要知道有无返回值以及返回值的大小。
~ 关于可视性，将其排序，按照 published, public, ... 的顺序排列这样 published 能被最先找到！
~ 发现如果将过程从模块中分离存放在数据库中，似乎过于零散，这样不便于我异常处理的实现。我觉得可以将模块设想成原子动作表（如：某对象的所有动作，某模块的所有动作，某动作的所有原子动作），集中存放。
  还是必须分开存放，原因如下：
  1、便于运行时刻对该过程动态添加过程（动作）的参数，和修改。
~ 是否需要象CLR一样，将数据区独立出来？在代码区只有临时数据区，通过 Ldc.1 ..ldc.5 等指令直接访问。
  的确有必要，理由：代码区全是代码之后，便于地址重定位。将地址全部变成绝对地址后，性能绝对是提高，而不是降低。当然在启动性能上受到了损失。
  不过我这里的模块都是小模块，所以也谈不上损失多少的问题。
~ 在定义外部word的时候如何区分该word的module类型？？
  : Public Word external ["moduleName" [Lib|DLL|Host]] [stdcall|pascal|forth] [name "procname"] [index 1];
!* ModuleEntry.
  + Revision:
  + BuildDate TitmeStamp
  由于我在编译的时候将使用单元的过程的偏移量直接编入了代码中，所以必须判断单元的版本和日期，这样该单元被改变后会自动重新编译，取得最新的偏移量。
!+ [ForthCompiler] 需要加上使用 RequireModule(),然后取得过程的偏移量。
  + 需要完成 TurboFileAccessor.
~ 关于外部调用的实现，我有两个方案
  1、建立 CallExternal PTurboWordEntry 指令 这样具体外部函数的类型在该指令中解析
  1、在编译时刻分别解析不同的外部函数类型，然后产生对应调用指令。

2006-11-3
* [BUG] [ForthCompiler] 因为我在Object使用了string，但是却没有初始化object内存，在对赋值该string赋值的出现严重错误！！改为Shortstring即可。
* [BUG] [ForthCompiler] Int64, Integer 这类的变量必须AlignMem.
* [VM] reanme TTurboWordEntry packed record to TTurboWordBlock object!
+ [VM] !TICK:: store tickcount to variable address directly. (int64Addr -- )
+ [VM] StoreInt(!), StoreInt64(!i8), StoreByte(!i1), StoreWord(!i2)
+ [VM] FetchInt(@), FetchInt64(@i8), FetchByte(@i1), FetchWord(@i2)
* [VM] 修改指令长度为 Byte 而不是 Int32，这样保留内存区只有256个字节，最大基本指令只有255个，现目前使用了大概100多个，需要根据 CLR
  做最后修订。

~ packed record
  只有对里面的 Pointer, Integer, Int64, string 才会对齐。shortstring类型不会产生对齐。
!* change the TTurboWordEntry record to TTurboWordBlock object
  这样我就能在上面加上地址重定位到其它模块等的过程。
  ?!* Name to PPackedShortString;
~ 在64位的机器上同样可以使用32位指针！！而且并不存在64位的指针，指针最多到48位！

2006-11-2
* [ForthCompiler]
  + @Tick : push the QueryPerformanceCounter: int64 to stack. [临时指令]
  + i8+: add int64
  + i8-: sub int64  (i1 i2 -- int64= i2`-i1)

2006-11-1
~ TASK
  + [ForthCompiler] 完成 Word 结构:
    + FWords: array of PTurboWordEntry;
    + FUsedModules: array of PTurboModuleEntry;
    + extend Define Word 
      WordDefine : [WordVisibility] WordName ("external" FORTHCALL|STDCALL|PASCAL|REGISTER|FASTCALL) |CodeParts ;
        注意，默认为 ForthCall,其它的调用则是外部DLL调用！对于>Protected的ForthCall的过程，全部使用远调用。
      : [WordVisibility] WordName 
        ExternalWord
        |WordPart
      ";".
      ExternalWord = "EXTENAL" 
        StdCall
        |PascalCall
        |RegisterCall
        |FastCall
        |DefaultCall //the default forth call.
      
      StdCall ＝"STDCALL" ExternalWordPart.
      ExternalWordPart = Identity 
        "Name" Identity
        |"Index" Integer
      .

    + 测试远调用
    + 完成VM指令：调用 CallEntry WordEntry
    + 完成DLL调用

~ 关于地址，在代码区的地址为相对偏移地址，而使用内存分配的地址为绝对地址（如局部变量的字符串）。

CLR 的即使编译器优化得很好，至少在这个加法运算上:
    CFA := 300;
    QueryPerformanceCounter(tBegin);
    CFA:= CFA+300;
    CFA:= CFA+300;
    ....
    CFA:= CFA+300;
  他使用JIT编译后的：
  MOV ESI, 300  BE2C010000
  ADD ESI, 300  81C62C010000
  ...
  ADD ESI, 300
  Delphi 编译的：
  MOV EBX, 300  BB2C010000
  ADD EBX, 300  81C32C010000

  和Delphi编译的一样，只是使用的寄存器不一样，但是为啥时间差别这么大？？.net = 15; delphi=60;
  我在内存种强制将EBX改成ESI发现是和EBX一样的时间。这只能说明CLR在即时编译的时候做的优化 ＝ 300*XXX;不然不可能这么快。

EUPHORIA 脚本引擎才是最快的，多用于游戏开发中。它采用的是和我类似的脚本执行机构!但是在它的运行器中似乎没有中断的办法，而TurboScript则每执行一个指令前都要检查是否需要停止，除非是编译的时候插入调试指令。【它的核心代码写得简直不是人看的】
因此它比我的快，我的TurboScript要比它慢0.25倍(虚拟指令执行)。【1/74 = 0.01351(EUPHORIA)  1/98 = 0.01020(TurboScript), 1351:1020】
再测试下它的调用子过程的效率：1/522 = 0.0019157; TurboScript: 1/157 =  0.006369. 19157/63690 嘿嘿，俺的调用子程序的效率简直比它高到哪里去了！～！我调用子过程的速度比它快70%倍.
EUPHORIA 脚本:
function iAdd(integer a, integer b)
  return a+b
end function
--计时开始
count = 300
iAdd(count, 300)
...
iAdd(count, 300)
--计时结束

TurboScript脚本
: Add +;
--计时开始
300
300 Add
...
300 Add
--计时结束

2006-10-31
* [Bug] 将远调用作为对另一程序的调用，不要互相影响。
  也就是说，另一程序的状态和错误是完全独立的！
  当然这样的唯一遗憾就是：调用后无法得知其真实运行态。
  他们之间只有参数栈和返回栈是共享的。还有全局参数区。
!+ 全局参数区，将状态，和参数栈大小等参数纳入，这样才能减少远调用的复制操作。而且也能解决停止状态。
  TTurboGlobalOptions = record  //do not use the packed.
    //States: TTurboProcessorStates; //如果放在这里，速度会下降
    LastErrorCode: TTurboProcessorErrorCode;
    ParamStackBase: Pointer;
    ParamStackSize: Integer; //bytes
    ParamStackBottom: Pointer;
    ReturnStackBase: Pointer;
    ReturnStackSize: Integer; //bytes
    ReturnStackBottom: Pointer;
  end;
  
~ 近调用过程的性能损耗：
  以加法为例： 
  定义过程 : Add +; 与直接调用 "+" 虚拟指令比较：
  "+" 指令的速度＝ 1 (1/100)
  Add 过程调用的速度 ＝  0.568 (1/176)
  速度下降了43.2％[100-56.8].
  俺稍微优化了下，Add 过程调用的速度 ＝ 0.613(1/163)， 速度现在是虚拟指令速度的61.3%,下降了38.7％ 和没有优化前比，速度提升了4.5%.

2006-10-26
!+ 单元初始化(Init)and Final 过程要改变成链表形式，从第一个执行，加是到最后一个。
  目的：对于那些没有自己的内存的模块，但是有自己的初始化过程的，也要执行啊。
  PTurboWordLink = ^TTurboWordLink;
  TTurboWordLink = packed record
    Next: PTurboWordLink;
    Word: PTurboWordEntry;
  end;

!* 现在放在wordEntry上的全部都是近调用，应该是远调用才对。近调用的只有私有word,或在WordEntry上的visibility in [<=fsPrivate]。

2006-10-25
在内存中RTTI信息的链接方式，决定采用和VM机器指令同样的方式，当数值小于保留区为简单类型常量(TTurboSimpleType)，否则为相对偏移地址。
使用 Delphi单元 TypInfo 的 TTypeData。只不过里面的所有 PPTypeInfo 类型的字段变成了上述说明的。

+ uTurboTypes.pas
  专门处理 读入内存，创建装载MeTypes.
  //Create PMeProcType and load 
  LoadMeProcTypeFrom(aProcTypeData: PTurboProcTypeData): PMeProcType;
  既然只有一个过程，那么还是暂时放在TurboExecutor一起。



2006-10-24
+ Function RemoveModuleTypes(aModuleName: string)
  //remove registered types of this module
* call RemoveModuleTypes function when module is unloaded.
2. 是否缓存ProcType，也就是放到注册类型列表中，先不缓存：
  vProcType :=  getProcType(const Buffer):PMeProcType;
  New(vProc, Create);
  vProc.InitFrom(vProcType);
  vProc.AssignFromStack(ParamStack);
  Inc(ParamStackPointer, vProc.StackSize);

!+ MeString: 
  Length(Word) String #0(Byte)
  this string length can be 0-$FFFF
  MeString = packed record
    Len: Word;
    Str: array [1..Len] of char;default;
    EndOfString: char; //#0 always. EndOfString
  end;

  ShortString = packed record
    Len: Byte;
    Str: array [1..Len] of char;default;
  end;

  AnsiString ＝ ^ TAnsiString.Str;
  TAnsiString = packed record
    RefCount: Integer;
    Len: LongWord;
    Str: array [1..Len] of char; default;
    EndOfString: char; //#0 always. EndOfString
  end;

2006-10-23
~  开始弄 TypeInfo,
* TCustomModule
  + RegisteredTypes: TMeTypes;
+ [uTurboConsts] TStaticMemoryStream
基本类型：基本类型是内置的不需要放入流中。如何区分基本类型和自定义类型在流中。
在流中可以通过 数字的大小来区分，如： >=0 是基本类型，>0 的则是指向自定义类型的偏移地址。
过程类型不是基本类型

基本类型: TTurboType

定义流格式: 嘿嘿，我可以按照Delphi RTTI 的内存格式进行啊（TypInfoEx.pas）
TuroType: integer; //>=0 是基本类型，>0 的则是指向自定义类型的偏移地址。

ProcType Stream:
  Kind: TMethodKind
  //Name: packed ShortSting
  ParamCount: Byte
  ParamList: array[1,,ParamCount] of record
      Flags: TParamFlags;
      ParamType: Integer;
      ParamName: Packed ShortString;
  end;
  [ResultType: integer] //如果是函数

1. 需要函数来装入BufferToMeType
2. 是否缓存ProcType
3. 只建立一个RegisteredTypes 管理所有的类型？然后通过
  类型名称为： ModuleName.TypeName 来区分
  既然只用一个那么就可以使用MeType的全局GRegisteredTypes变量！！

自定义类型的生存周期：就是模块的生存周期。
后期绑定的类型不存在生存周期问题。

~ 考虑如何将类型纳入我的知识数据库
模块和类型放入知识库中：
  模块和类型的关系： krCollection

粒度：
  模块里面的类型过程等全部内容被放入一个字段（相当于文件存放在了数据库中）。
  模块里面的内容被拆散，每一个类型，过程被分别存放在不同的字段中(这时候，这些东西全部是后期绑定的)。

2006-10-21
~ 发现一种新的语言 Seed: 它的特点是可以自定义新的语法结构(for 语句，while语句等)，它的自身就是这样弄出来来的。
  http://seed7.sourceforge.net
~ 在网上看了看关于 ECMA standard common intermediate language CIL（也就是Dot.net 的CLR Microsoft Intermediate Language (MSIL)） 的实现，
  其思路和俺的差不多，都是面向堆栈，支持后期绑定（它称之为反射refelection）,metadata（运行时刻类型信息，还不知道是否是所有的都有，还是自己定义，不过如果想做到safecode，那么就必须知道meta信息，这样才能防止传入非法数据，我想managed code 一定有metainfo,最多名称没有）。
  我感兴趣的是，它是怎么实现不同大小的push指令的（它叫load）。
  所有的东西都是类，其实俺的实现也可以这么理解，模块＝类，至于说必须要传递自己这个参数，那不就是FMemory基址指针(我放在EDI中的)，就差一个VMT表了。
  不过有点乱的是对象实例和类如何区分？我这定义的应该是对象的类！而不是对象实例。
!+ 定义外部函数的 TTurboWordEntry CFA域的内容：
  外部的定义： 模块外部的Forth函数（可从调用约定看出）；在宿主(MainApp)中的函数；在DLL中的函数。
   PModuleEntry:
   PFunctionIndex:
   FunctionName: PTPackedString
   //参数个数
   //参数描述列表: Size InRegister(如果为0表示要压入堆栈，该域供Register and FastCall使用)
   
   返回值类型＝无，在EAX中；在EAX:EDX中；在浮点小数栈中；
   必须获知每一个参数类型，才能决定压入堆栈的参数是那些，尤其是register调用。
!* [CustomModule] 当在编译状态的时候，不作地址变换。
!+ 虚拟 CPU 识别的基本类型:
   Address
   Integer(int1, int2, int4(32位), int8(64位), nativeInt)
   Float
   String
- [FullSpeedFeature] From TTurboX86Interpreter
!* TTurboCodeFieldStyle = (cfsFunction, cfsHostFunction, cfsDLLFunction);
  cfsFunction: 
    published-protectd Function 就统一采用外部调用Foth函数的形式： ModuleAddr FunctionAddr
    而privated 的则是私有函数，只能在模块内使用。
  cfsHostFunction, cfsDLLFunction: 
    PModuleEntry: Pointer;
    Index: Integer; -1 means non-index visits.
    Name: PChar; //the function name in the DLL/Host.
* TTurboModuleEntry: 对其扩充
  + ModuleType: mtLib, mtHost, mtDLL
  * Module: Pointer:
      DLL Module(mtDLL): it's the DLL handle.
      ForthLib module(mtLib): loaded the instance of TCustomTurboModule.
      Host Module(mtHost): 如果不把host里的函数按模块组织就不用，否则就该设计一个新类来处理。
      nil means not assigned(or loaded).
外部DLL/Host函数执行流程如下：
根据 TTurboWordEntry的 TTurboExteralWordPFA.PModuleEntry获得 ModuleHandle,如果 ModuleHandle ＝ nil 那么装载该DLL,
还是用伪代码写：
if TTurboExteralWordPFA.ProcAddr = nil then
begin
  with TTurboExteralWordPFA.PModuleEntry do
  begin
    if ModuleHandle = nil then ModuleHandle := LoadLib(ModuleName);
    if TTurboExteralWordPFA.Index <> -1 then ProcAddr := GetProcAddrByIndex() 
    else ProcAddr := GetProcAddrByName();
    if ProcAddr = nil then raise Error!!
  end;
end;
DLLExecutor.Params := ParamStack()
DLLExecutor.ParamTypes
DLLExecutor.Run(ProcAddr);
换句话说，该过程的参数类型也必须注册！！
我必须使用静态对象，否则手工逐个填充VMT指针太累。
或者这么说需要伪meTypes添加类型的保存，装载流机制。
如果我在模块内那不是要重复，如果多个模块调用同一个外部函数？？
不过这是没有办法的事情，只能这样，你必须把模块想成DLL。


2006-10-20
+ [ASM] 定义常量，变量
  编译通过
  不过未能实现常量表达式的合并。
  常量测试完毕
  变量测试完毕
  暂时不实现 PushByte, pushWord 指令，全部以PushInt指令的形式实现。
+ 内部过程指令(也许在最终版本中删去)：
  等俺调用外部函数的通用指令搞好后，这些就用不着了。
  + .S(aStr: pShortString); (aStr -- ) 注意该地址是相对地址＝ Addr + Integer(FMemory)
  + .LS(aStr: pAnsiString); (aStr -- )

!* 当编译时候增加内存，有可能会发生FMemory的移动，这个时候，我用的是绝对地址，就会出错！！
  我应该根据编译状态，在编译的时候全部使用相对地址！！
  
!+ [ASM] Imports XXX,XXX2; 导入指令，可以讲其它源程序单元导入到直接，相当于 Include.
!+ [ASM] Uses XXX. XXX; 单元链接指令，相当于列举要使用的DLL表！！


* [Bug]  f发现在动态数组的 Object 中使用 长字符串 Name 记录出现错误，莫名奇妙的乱指！！
  改成ShortString,后正常。
  TTurboSimpleConst = object
  public
    Name: ShortString;

  TTurboSimpleVar = object(TTurboSimpleConst)
  FVars: array of TTurboSimpleVar;
  如果name 是 string 那么就出怪事情了：
  var
    ss: string = '';
  : Add + ;
  这个时候报告 Add 是重复的，发现是FVars中最后一个的Name域乱套的原因。
  明白了，我是直接整个记录 赋值，这样就不能让Name的字符串引用增加，看看是不是这个原因。
  tmd,不行还是同样的错误！！
  

~ [Coco/R] SynError 并不引起异常退出，而是将当前错误记入List，继续编译！！


2006-10-19
~ 需要知道Delphi是怎么处理将常量字符串赋值给变量的。
  首先将常量字符串放入内存区域（在程序的最后面）。然后指明字符串所在地址，调用一个函数将其复制到变量中！！
  在俺的一次汇编中无法实现这样的东东！！只能是嵌入。换句话说，如果是常量定义就立即在内存开辟空间。

  Delphi的全局变量放在程序的后面
  
AnsiString: 常量 
'0123456789'
$FFFF(引用计数) $000A(字符Count)  '0123456789' $00 (它的所有常量在内存中都是Aligned),空白处用00填充。

2006-10-18
~  EMIT, #'' 指令为临时测试用!!
* 修改了 TTurboProgram 从CustomExecutor派生了.
  然后 增加了 ExecutorClass 使用前必须赋值!
  将Executor 的Visibility 作为私有, 这样使用Program 的内存
* TCustomTurboModule  : 当 StoredInParent 的时候不要释放内存. 
  不过是否要ClearMemory起作用??
  不要,当StoredInParent 时候,不能清除内存!!因为内存是父亲的! 
  还有对于StoredInParent 的,Unload 不会起作用,因为已经装入到父亲了,除非是父亲卸载..
+ uTurboSymbols
  准备使用

2006-10-17
+ Varaible define: 全局变量定义.
+ const define

变量分为: 
  全局变量: 在代码空间内分配的,放在LastVariableEntry
  局部变量: 在数据栈上分配的,退出的时候释放.
  堆变量: 使用GetMem分配的,多用于字符串.

- TCustomTurboModule.TIB

2006-10-16
+ define word feature done. test passed.
+ print char feature. TCustomTurboExecutor.OnPrintChar Event
  EMIT(c --): send char out.
+ #'123'(-- 43 42 41) push the reverse string to parameter stack.

2006-10-15
  文件扩展名定义:
    *.tf  Turbo Forth(ASM) Script Source

tfcc.exe : Turbo Forth Command line Compiler.

模块名称由文件名决定.

!+ uTurboModuleFileAccessor

+ tsrun.dpr 初步完成:
  能显示执行结果数据栈或返回栈的内容,如果有内容的话.

!+ 增加过程的支持.
:Word ;
 
2006-10-14
  文件扩展名定义:
    *.tpc Turbo Script program Compiled
    *.tcu Turbo Script unit Compiled 
    *.ts  Turbo Script Source
 tscc.exe : Turbo Script Command line Compiler
 tsrun.exe <filename>: Turbo Script command line intercepter.
* 修改了 coco/R delphi ,使得我能在框架文件中的自定义生成的文件名.使用开关 $M"ModuleName"

2006-10-13
~ [COCO/R]
  如何获得当前的分析处的字符串!
  使用 TParser.LexString 函数
  例子:

SQLName <var aName : string> 
      =
           ident                                                                (. aName := LexString; .) 
           | SQLNameString                                                      (. aName := StripQuotes(LexString); .)

AssertStatement<Parent: TnxSqlNode; var Assertion: TnxSqlRootNode>              (. var TableName: string; .)
  =                                                                             (. Assertion := TnxSqlAssertion.Create(Parent); .)
    "ASSERT" "TABLE" SQLName<TableName>                                         (. TnxSqlAssertion(Assertion).TableName1 := TableName; .)
    "=" "TABLE" SQLName<TableName>                                              (. TnxSqlAssertion(Assertion).TableName2 := TableName; .)

  {} 表示 0个 或任意个.
2006-10-12
~  heap 使用Delphi的heap和相应的函数，字符串管理也使用Delphi的。

2006-10-11
!+ 定义汇编语言,编写汇编语言编译器.
   支持的类型: Byte, Word, DWord, Integer, Char, ShortString, AnsiString
   不支持自定义类型
   决定采用类似于Delphi的结构,而不是类似于汇编的.
   
   [标号] 操作码 [操作数]
   [[Published] 标号] DB [初值[,初值,初值]] //预留Byte 发布的将联入变量表 
   [标号] DW [初值] //预留字
   [标号] DDW [初值] //预留双字 
   [标号] DSS ['字符串初值'|Length] //预留短字符串 
   [标号] DS ['字符串初值'] //预留AnsiString字符串 
   :[Published] DefinedWord 
   ;

  类似于Delphi的:
  Lib aName;
  Const aConstName = Value;
  [Published] Var aVarName: Type [= InitValue];
  : [Published] DefinedWord
     [标号] 操作码 [操作数]
  ;
  
  initilization
  finalization
  End. //lib 

2006-10-9
~ [语法树] 
  如果是模块,首先编译使用的模块列表(UsedModules)
  首先需要编译有些Types信息(已经发布的RTTI, 并不是动态绑定的类型)进入内存 TTurboTypeSymbolList.Compile;
  {$TYPEINFO ON}, {$DynamicBinding ON}
  接着编译变量和类型常量进入内存.如果是$TYPEINFO ON,并且该类型也是发布的那么该变量的类型指针也被编入,否则如果只有变量是发布的,那么将只是TMeTypeKind的值被编入指示其基本类型; 动态绑定的变量不会编入内存!
  接着编入子过程,如果不是StoredInParent并且发现名为@@__Initilization__@@ 和 @@__Finalization__@@ 的过程则将相对地址连入保留内存!
  最后如果是过程,那么就编译自己,如果是模块,那么就编译子模块.

~ 源程序文件与数据库的同步问题?
  当通过语法树产生虚拟机器码的时候,如果数据库有效,是否需要将它们同步到数据库中?
  不需要在此时吧,提供一个方法,在编译成功后,调用该方法就可以保存到数据库中.
  其实就是更改AccessorMgr上的默认Accessor指向DBAccessor,然后save 即可.

2006-10-5
* 继续设计 uTurboCompiler 语法树 

2006-10-4
~ 对于私有Module, 那么该Module 实际上是不存在被合并到Parent

2006-10-2
+ 设计语法树类
   TTurboWord = Class(TCustomTurboModule); //用户自定义单词
     Words: TTurboWordList; //嵌套子过程
     Parent: TTurboWord; //同上. nil means root.
     Variables: TTurbovariableList
     Symbols: TTurboTypeList;
     //根据编译开关将这些列表的类编译进入Memory. 比如如果该模块的Accessor为DBAccessor,那么就只能使用后期绑定的形式编译.
     //还有如果该模块的编译开关要求函数分别
     procedure Compile; 

   TTurboModule = Class(TTurboWord)
     Childs: TTurboModuleList; //被 Parser 使用!
     UsedModules: TList;
   //TTurboVMWord = Class(TCustomTurboSymbol); //机器码只有操作符。也许不必考虑机器码。
   TTurboOpCode

2006-9-29
* [uTurboAccessor]
  * rename  uTurboScriptAccessor to uTurboAccessor
  * RegisterAccessor 放入Module管理器了
  + GTurboModuleManager
* rename uTurboScriptConsts to uTurboConsts

通知(释放通知,卸载通知)是否能作为AOP 功能加入?我现在的AOP是基于类添加功能的,换句话说,同一类的不同实例将共享同样的AOP对象.
通知定义: 当对象实例的某事件发生的时候,通知预定了该事件的对象实例.

看样子我必须将基于实例的AOP功能类早日拿出来,不然够呛(不得不在Feature上区分具体是那一个实例):
  TMeCustomInstanceFeature = 基于实例的AOP功能类,这样可以为每一对象实例添加新的属性.
  或者将基于Class的叫做功能类: TMeCustomFeatureClass
  还有一个方法就是修改VMT, 增加Object记录的大小,这样我就可以存放附加数据了.不过这样的话,必须要小心,在注入前不能有任何已经创建的注入对象!
  TMeNotificationFeature = Class(TMeCustomInstanceFeature)
  end;


2006-9-28
!+ 移植到MeScript
!+ 构造编译器中的模块类: uTurboCompiler.pas
   TTurboModule = Class(TCustomTurboModule)
     Childs: TTurboModuleList; //被 Parser 使用!
     Parent: TTurboModule; //同上. nil means root.
     UsedModules: TList;
     Words: TTurboWordList;
     Variables: TTurbovariableList
     Symbols: TTurboTypeList;
     //根据编译开关将这些列表的类编译进入Memory. 比如如果该模块的Accessor为DBAccessor,那么就只能使用后期绑定的形式编译.
     //还有如果该模块的编译开关要求函数分别
     procedure Compile; 
     //放到TCustomTurboExecutor中:
     //property LastWordEntry: PTurboWordEntry;
     //property LastVariableEntry: PTurboVariableEntry;
   TCustomTurboWord = Class(TCustomTurboSymbol);
   TCustomTurboVMWord = Class(TCustomTurboWord); //机器码只有操作符。也许不必考虑机器码。
   TTurboWord_JMP = Class(TCustomTurboWord); //下划线开始的为VM 机器码.
  至于类型我准备用uMeTypes的.

2006-9-27
!+ 建立TurboScript异常处理中心机制

分析 Delphi 异常处理中心机制
分析的结果就是我必须在完成对象等类型处理后,才能进行,它是放在SysUtils单元中..

+ 构思出了 TurboModuleAccessor 架构 in uTurboScriptAccessor.pas

~ 想法简化直接调用Delphi函数,这样就可以直接用Delphi的异常处理机制.直接用是做梦,不过可以参考编译产生的汇编.
开始构思语法树(独立于语言之外的)

2006-9-25
+ TurboModule Stream Header
!+ 构思 TurboModuleAccessor 架构
* [VM] 修订 EnterFar ModuleIndex cfa-addr 改为 MemBase-addr(另一模块的内存基址) cfa-addr
- [VM] 放弃 ModuleIndex 机制，因为我希望我的脚本(Program)能够在内存中并行工作，并且尽量节约内存：我采用的是一个Module只在内存中存在一份拷贝。
  而显然不通的Program ModuleIndex是不同的。所以放弃 ModuleIndex, 转而使用 LastModuleEntry-addr
+ [VM] CALLFAR PTurboModuleEntry cfa-addr: if PTurboModuleEntry = nil means it's self, do not lookup.  
+ TCustomTurboObject: FreeNotification

2006-9-23
~ 装入后的流，以流的大小作为 UsedMemory.
在Executor执行脚本前，必须做的事情有？
 如果希望，接着上次没有完成的地方做，就必须保留 SP, RSP 堆栈指针（放入保留内存？）.
 但是我的堆栈，是整个程序公用的（为了快速交换数据）。所以堆栈指针有可能被别的模块修改。这样保存堆栈指针就达不到目的。
 //数据栈指针、返回栈指针如果不为0，那么必须不能设置。
   没有问题，从内部执行（一个模块调用另一个模块的函数），无影响。但是从Delphi中调用模块函数后，在执行另一个模块中函数，就～～
   想发只允许从 TProgram 中调用执行，每次执行完毕，必须将堆栈指针传递给TProgram.
   在TProgram 中终止脚本执行，必须遍历每一个Executor,设置其状态。不妨将TProgram看作 root Executor，其他则是导入的模块,
怎样在Delphi中调用脚本函数，可以连续调用，能够持续。只需要保证数据栈指针即可。而返回栈除非是调试，否则不必要。

在Executor 上有 Import Modules(uses)： 使用到模块中的函数。还有ChildModules(不过这个似乎只在编译的时候有意义)。
//扁平化处理，只有Program上才存在ChildModules(TList 汇集所有装入的),所有装入的Module实例放在该处。层次化Module名只供查找用。
这里的ChildModules实际上就是 Import Modules 啊！！反正不管，实例只能有一个地方存在！

2006-9-22
~ 发现 如果将 States 控制在一个字节，那么速度将近会提升1倍
  MOV BL, mem 速度要快于 MOV DX, mem，将近快1倍。

~ Used Modules(Import Section):
  LastModuleEntry: Pointer; //last Used module entry.
  LastWordEntry: Pointer;   //所有这些Pointer都是相对FMemory的地址(当装入后是否考虑由装入者对该地址重定位？)
  //Import Module Entry
  TTurboModuleEntry = packed record
    PriorModule: Pointer; //相对地址指针
    ModuleIndex: integer;
    Module: TCustomTurboExecutor; //nil means not assigned(or loaded).
    Name: ShortString; //packed string, full module name with path.
  end;
  暂时不考虑地址重定位，总是作为相对Fmemory的地址存在。
  但是我发现自己很难抵挡住这样的诱惑，重定位后可以提升速度。那么我必须考虑，重定位函数放在那里？
  代码装载到内存后，需要重定位，代码保存到文件或其它地方，也需要将绝对地址转为相对地址。
  RelocateTurboMem(RelatedAddrToAbsoluteAddr)
  procedure TurboConvertAddrRelatedToAbsolute(const Mem: Pointer);
  asm
  end;
  procedure TurboConvertAddrAbsoluteToRelated(const Mem: Pointer);

2006-9-21
* 使用 寄存器作为状态寄存器，但是导致不能命令指令随时停止，所以，在将状态寄存器放入保留内存中，这样，就能命令停止了。EBX 成了临时寄存器。

~ 有没有取得当前执行地址的x86指令？
  答：不能，只能通过Call 间接取得。
+ [VM] 调用 register calling（delphi）写的函数：
  CallReg: register
  CallPascal: pascal
  CallStd: stdcall
  CallFast : fastcall
  如何准备参数？那就必须要知道过程需要几个参数，才能从数据栈中取出需要的个数。也就是我需要得知ProcType, 必须的信息是：ParamCount(以Integer为单位的，不是真正意义上的参数个数)
  CallReg Addr, CallReg 有一个操作数。 Addr 为该函数注册后的索引地址。

~ 外来函数在 TProgram 上注册好，还是在 Executor 上注册好呢？还是在 Executor 上注册好，至于后期绑定的，那就无所谓了，可以自由发挥。
  注册的函数结构： TTurboRegisteredFunctionRec = packed Record //合并后放在 LastWordEntry 中。
  ParamCount: Integer; //以Integer为单位的，不是真正意义上的参数个数
  CallingStyle: TCallingConvension;
  TypeInfo: Pointer; //nil means no RTTI info.: 实际上是一个相对于FMemory的地址。

+ [VM] 当调用其他模块的函数时候，是否需要保存现场？
  至少EDI(FMemory)和ESI(PC:Program Counter)需要保存。堆栈是共用，不需要保存。除非是delphi写的。
  但是我返回的时候？如何才能返回？
  回答：增加Far word, 和 near word, 对于私有过程（只在本模块内有效），采用 near word(默认, Enter, Exit); 对于能被其他模块访问的过程
  则采用far word(EnterFar, ExitFar).
  对于外部过程，调用的VM代码： EnterFar module-index cfa-address， 也就是说，对于near 调用，只需要直接写下地址，但是对于Far调用就必须要OpCode + OpRands
  在保留内存区增加 Index, 用来保存ModuleIndex,这样对于自己内部调用EnterFar，就不必要去查找模块地址了.
  这就是ForthDLL的链接方式调用！

iVMEnterFar:
在返回栈中保存EDI(旧的 FMemory 基址), 根据 ModuleIndex 查找模块内存基址，如果找到就设置EDI成新的 FMemory 基址,然后装入该函数的地址，其它就和VMEnter一样了，转去VMEnter。

  PUSH EDI
  LODSD
  CMP  EAX, [EDI].TPreservedCodeMemory.ModuleIndex
  JZ  @@DoLocalEnterFar
@@GetModuleAddr:
  PUSH EDX
  PUSH ESI
  PUSH EBX
  PUSH EBP
  
  MOV  EDX, EAX
  MOV  EAX, [EDI].TPreservedCodeMemory.Executor
  //function TCustomTruboExecutor.GetModuleMemoryAddr(aModuleIndex: Integer): Pointer;
  CALL TCustomTruboExecutor.GetModuleMemoryAddr
  POP EBP
  POP EBX
  POP ESI
  POP EDX

  CMP  EAX, 0
  JZ   @@NotFoundError
  MOV  EDI, EAX
  JMP @@Exit

@@NotFoundError:
  POP  EDI
  MOV  [EDI].TPreservedCodeMemory.LastErrorCode, errModuleIndex
  JMP  iVMHalt

@@DoLocalEnterFar:

@@Exit:
  LODSD
  ADD EAX, EDI
  JMP iVMEnter

iVMExitFar:
  POP ESI
  POP EDI
  JMP iVMNext

2006-9-20
+ 基本实现 TTurboX86Interpreter 解释器核心
  !+ 没有单步执行 ({$Define TurboScript_Stepping_Supports})
  !+ 返回栈＆数据栈没有溢出判断。 {$Define TurboScript_DataStack_Overflow_Inspect} {$Define TurboScript_ReturnStack_Overflow_Inspect}
  !+ 内存没有溢出判断 {$Define TurboScript_Memory_Overflow_Inspect}
~ 关于控制流程指令：到底转移地址是放在数据栈中还是操作数中？
  想通了，JMP指令操作数放在内存中，GOTO指令操作数在数据栈中，而且GOTO的参数只是绝对地址。
  GetBindingVar(str-addr -- addr) return the variable address(real absolute address). nil means not found.
  GetBindingWord(str-addr -- callingConvention addr) callingConvention 是表明该word的调用类型
  CallBinding (callingConvention addr -- ) 由于该函数可以在其它模块中，所以该地址为真实地址。

2006-9-14
~如果参数栈＆返回栈使用全局内存，好处就是多个执行器可以共享数据，坏处就是多个执行器不能并行执行。
 也许在执行器上面还应有一个类，这个类就可以管理参数栈＆返回栈内存以及参数，这样在这个类上就可以并行执行。
 这个类叫什么好呢？ TTurboProgram:
   TTurboProgram: Execute

记住这里的X86堆栈： 压入则是地址减少，弹出则是地址增加，ESP总是指向栈顶。
When an item is pushed onto the stack, the processor decrements the ESP
register, then writes the item at the new top of stack. When an item is popped off the stack, the
processor reads the item from the top of stack, then increments the ESP register

2005-7-19
* 决定不在字符串后面加对齐指令!!是怎么样就是怎么样!!

手工跟踪测试：
PC: CPU的运行指针
IP: FORTH的运行指针

调用核心词汇：iVMNext, 执行当前IP.
(IP) -> W  fetch memory pointed by IP into "W" register
              ...W now holds address of the Code Field(CFA)

IP+2 -> IP advance IP, just like a program counter
              (assuming 2-byte addresses in the thread)
(W) ->  X  fetch memory pointed by W into "X" register
              ...X now holds address of the machine code 
JMP (X)     jump to the address in the X register

2005-7-18
该测试下是否我写的解释器正确！！
* [Bug] 修正编译错误！！

Win32Forth 的数据栈采用的是我所设想的技巧:
数据栈使用的是Hardware栈，不过使用EBX作为实际栈顶。

EBX    <-- TOS Data
数据栈 <-- 第二个数据

(a b -- )
EBX = a
b is in  数据栈.

TIB: Text Input Buffer

修改FORTH解释器的内存映象的结构:
FORTH解释器初始化的时候，先分配的内存：
[cTIBLengthOffset]TIBLength: DWORD (#TIB=1)
[cToINOffset]>IN:DWORD(the current TIB index)
[cTIBOffset]TIB(1024 Byte):原有内存！

从磁盘装入:
[cLastWordEntryOffset]LastWordEntry: DWORD(PForthWord); 指向该程序或单元拥有的单词入口

cTIBLengthOffset = 0;
cToINOffset = cTIBLengthOffset + SizeOf(Integer);
cTIBOffset = cToINOffset + SizeOf(Integer);
cMAXTIBCount = 1024; //Bytes
cLastWordEntryOffset = cTIBOffset + cMAXTIBCount;

我又有点昏了，既然我这里的地址是相对偏移量，那么所有的地址都应该是才对！
因此@等FORTH词汇，也是取的相对偏移量！
如果需要存取绝对地址（外部地址）的数据，应该建立专门的非标准词汇来处理！
所以，我所写的一些词汇要改！！

另外：将TIB作为固定的缓冲区放入FORTH内存中，不错（SP-FORTH 分配的是1024个字节）。
spf_parser.f

必须在系统中实现的核心词汇:
spf_defkern.f
CODE _CREATE-CODE
CODE _CONSTANT-CODE
CODE _USER-CODE (this is SP-FORTH impl, not ANSI-FORTH)
CODE _SLITERAL
CODE _CLITERAL-CODE
CODE _USER-VALUE

其次为: spf_forthproc.f
@, !, DUP, LAST-CFA, ALLOT, DP, HERE, LAST, ",", 

6.1.2450 WORD 
CORE 

        ( char "<chars>ccc<char>" -- c-addr )

Skip leading delimiters. Parse characters ccc delimited by char. 
An ambiguous condition exists if the length of the parsed string 
is greater than the implementation-defined length of a counted string. 

c-addr is the address of a transient region containing the parsed word 
as a counted string. If the parse area was empty or contained no 
characters other than the delimiter, the resulting string has a zero 
length. A space, not included in the length, follows the string. A 
program may replace characters within the string. 

Note: The requirement to follow the string with a space is obsolescent 
and is included as a concession to existing programs that use CONVERT. 
A program shall not depend on the existence of the space. 

See: 3.3.3.6 Other transient regions, 3.4.1 Parsing, 6.2.2008 PARSE , A.6.1.2450 WORD 

It' for the input buffer process(TIB).

: WORD ( char "<chars>ccc<char>" -- c-addr ) \ 94
  DUP SKIP PARSE 255 MIN
  DUP SYSTEM-PAD C! SYSTEM-PAD 1+ SWAP QCMOVE
  0 SYSTEM-PAD COUNT + C!
  SYSTEM-PAD
;

2005-7-17
开始搞核心词汇。

2005-7-15
现在我有两种字符串在FORTH中,并且它们都是会对齐地址边界（基于Pointer的大小计算）：
ShortString: (ByteCount)PChar
String: (IntCount)PChar

function StrToPChar(const aV: string): PChar;
begin
  SHowMessage(IntToStr(Length(aV)));
  Result := Pchar(aV);
end;

procedure TForm1.Button1Click(Sender: TObject);
var
  d: PChar;
  a: pChar;
begin
  d := 'Hello world';

  a := StrToPChar(d);
  {in fact delphi will call the LStrFromPChar to convert the PChar(d) to String!}
end;


重新设定单词结构：
删除掉关于库名的设定。只有单词链表。
至于库不在此处处理。
也就是说LibEntry 变成了Forth Word Entry.

文件头:
MagicWord: 'SUPER4TH'
//类型 TYPE(TSuperForthFileType): 是程序，还是库
NAME：StrLen(Byte): string
版本号：DWORD
日期：DWORD(The Data field indicates the number of calendar days since the start of the calendar (the number of days since 1/1/0001 plus one).)
参数栈大小： DWORD，0表示默认。
返回栈大小： DWORD，0表示默认。未用，使用系统的返回栈。

装入内存的映象:
LibEntry: DWORD(PForthWord); 指向该程序或单元拥有的单词入口

因为要传递数据栈中的数据,所以,SP该是指针，可以指向别人！
不过对动态数组无所谓！暂时就先用动态数组。

2005-7-12
~ 关于连接和调用其它的脚本中的单词的问题。

调用的单元中必须对其进行说明：
ImportWord WordName LibName

放弃在一个程序（单元）中使用多个库多单词的结构。
在我的FORTH中对程序和单元不加区分，以后就统称为
单元，如果在单元中存在Main的单词，那么调用没指定
Word的Execute,就会执行Main这个单词。

只有保存到文件中才存在:MagicWord, UnitName
在流中不存在(为了方便我将VMCode直接写入数据库)

对于非本单元的词的分类：
Forth 词汇
Delphi
DLL

2005-7-11
+ FORTH解释器核心词汇:
  VMFillMem

2005-7-8
+ FORTH解释器核心词汇:
  Enter
  Exit
  Next

2005-7-7
按照 delphi帮助所说，当重新分配的内存块很大，它将会移动该块的地址到能放下的地方！
当移动后，除非是相对偏移量，否则字典中的CFA地址将全部出错！除非对绝对地址进行地址重定位。
另外如果在运行状态，那么对于已经压入堆栈的绝对地址，也会出错。

所以，必须将程序和数据分开才好，或者就只有采用固定大小的内存块。
暂时采用固定内存块，因为它的单词都是PFA。当然需要在运行中动态添加单词的应用毕竟是少数。

当然，如果所有的地址全部都是相对偏移量地址，那么就不会存在地址重定位。但是这样一来，速度
必然会受一定的影响。

在我的解释其实现中，堆栈的方向是向上递增的（压栈），它的栈顶指针总是指向未用的元素。
并且使用的地址全部都是相对偏移量地址.

解释器需要两个运行指针:
1. IP 机器指令的运行指针
2. PC FORTH的PFA解释运行指针

type
  TmMethod = procedure of object;
procedure TForm1.Button1Click(Sender: TObject);
var
  aProc: procedure;
  aT, aMethod: TmMethod;
begin
  //aProc := ;
  aMethod := test;
  aProc := TMethod(aMethod).Code;
  //aMethod;
  TMethod(aT).Code := @aProc;
  TMethod(aT).Data := Self;
  aT;
end;

2005-7-6
如何Cast 数组中的元素：
aLongWord := PLongWord(@Array[3])^
PForthLibEntry := PForthLib(@Array[3])


我相通了，FORTH在内存中的组织，可以根据不同地点具体实现方式不同而不同。
但是文件映像对于任何实现都必须是一样的！
在文件中的组织：
MagicWord: 'SUPER4TH'

类型 TYPE(TSuperForthFileType): 是程序，还是库
NAME：StrLen(Byte): string
版本号：DWORD
日期：DWORD(The Data field indicates the number of calendar days since the start of the calendar (the number of days since 1/1/0001 plus one).)
如果是程序：
  参数栈大小： DWORD，0表示默认。
  返回栈大小： DWORD，0表示默认。未用，使用系统的返回栈。
如果是库：
  参数栈大小： DWORD，0表示默认。未用
  返回栈大小： DWORD，0表示默认。未用，使用系统的返回栈。

LibEntry: DWORD; 指向该程序或单元拥有的单词库入口
  PriorLibEntry: DWORD(Pointer) 文件中的相对偏移量
  LibNameLen: Byte
  LibName: array [0..LibNameLen] of char, the last char is #0
  LastWord: DWORD(Pointer) //the last word. 因为它是一个只能向prior前移动的单向链表。

单词链:
    PriorWord: DWORD(Pointer); //前一个单词 0 means 为最前面。文件中的相对偏移量
    Precedence: Byte; //优先级, 0=low, 1=high equals 1 for an IMMEDIATE word
    //1=True; 0=False; Smudge bit. used to prevent FIND from finding this word
    //this can be extent to private, protected, public, etc
    Visibility: Byte; 
    CallStyle: Byte;
    CodeFieldStyle: Byte;
    ParamFieldLength: DWORD
    NameLen: Byte
    Name: array [0..NameLen] of char, the last char is #0
    //CFA: DWORD //其实就是直接指向的某个单词的PFA，不过那个单词的PFA就是直接执行的机器码而已。
               //CFA = ParameterFields[0]
    ParameterFields: array [0..PFLen-1] of integer(DWORD);

以上为文件中的组织。
_______________________________
  在内存中组织:
  TForthLib = packed record
    Name: string; //1 DWord(Pointer)
    PLastWord: PForthWord; //the last word. 因为它是一个只能向prior前移动的单向链表。
  end;
  //TForthWords = array of TForthWord;
  PForthWord = ^ TForthWord;
  TForthWord = packed record //ITC (Indirect Threaded Code)
    PriorWord: PForthWord; //前一个单词 -1 means 为最前面。
    Name: String;
    Precedence: Byte; //优先级, 0=low, 1=high equals 1 for an IMMEDIATE word
    //1=True; 0=False; Smudge bit. used to prevent FIND from finding this word
    //this can be extent to private, protected, public, etc
    Visibility: Byte; 
    CallStyle: Byte;
    CodeFieldStyle: Byte;
    //ParameterFields: array of PForthWord; //the first PFA is CFA.
  end;

对于编译型FORTH，CFA需要特别关注。因为在原始的ITC运行模式中，CFA直接指向的是执行的机器码地址。
而对于我的编译型FORTH，当加载已经编译的FORTH虚拟机后，如果CFA的执行码在Host中，那么就必须对该地址进行重定位。
那么如何区分CFA（在Host or VM）？
在FORTH Word 头结构中增加 CodeFieldStyle 属性：
cfsHost: the CF is in Host, so the CFA is the index No for the Host. Must fix.
cfsFORTH: the CF is in FORHT, so the CFA is the offset address of the FORTH, no need to fix.

2005-7-5
字典区结构：
1、字典索引区：包含的字典库
  在文件中的组织:
  LibNameLen: Byte;
  LibName: array [0..LibNameLen-1] of char
  LastWordOffset: Integer; //该库的最后一个单词的偏移量.

  在内存中组织:
  TForthLibs = array of TForthLib;
  TForthLib = packed record
    Name: String[31]; //32 bytes
    Words: TForthWords;
  end;
  TForthWords = array of TForthWord;
  PForthWord = ^ TForthWord;
  TForthWord = packed record //ITC (Indirect Threaded Code)
    PriorWord: PForthWord; //前一个单词 -1 means 为最前面。
    Name: String[31]; //32 bytes
    State: Word; //include Precedence bit(equals 1 for an IMMEDIATE word), Smudge bit(the 2nd bit used to prevent FIND from finding this word.)
    CallStyle: Word;
    ParameterFields: array of PForthWord; //the first PFA is CFA.
  end;
  放弃这样的内存组织，清晰倒是清晰，但是速度太慢！
  还是采用分配一个固定大小的内存区域作为字典区(统一放在Memory区)。

注：
  1. 对于非汇编过程,该过程无论是否有参数或局部变量,都会有push EBP; MOV EBP, ESP的动作!
     也就是说如果我想使用一般的过程,就不能将系统堆栈作为参数栈使用！

2005-7-4
为了避免重新计算地址，全部采用相对偏移量！

词汇的数据结构：
Core 词汇: 虚拟机器码 （或者用汇编）实现的。必须的！
System 词库： 以Core词汇为基础编写的，当然也可以用汇编实现，不过为了可移植性，最好两种实现方式都有。

怎么组织Unit？
增加一个Unit指针，类似于词汇指针CP, Context, Last, Current:

称之为字典区(或词汇区),这是单独的一个空间区域，有别于代码区，由ALLOT分配空间。


2005-7-2
在ITC机制下，所有的单词内容都是地址(指向其他单词的CFA的地址)。所以必须有一个简单的解释器（其实称不上解释，因为它把适当的跳转指令早已嵌入到代码流中了“Enter, Exit, Next”）执行。
通过CFA指向真实的机器执行码。
只不过对于用户定义的单词（For all colon(冒号) definitions）中，它的入口单词总是"Enter",出口单词总是"Exit"。

注意：
  * Enter 又的FORTH上称作 DOCOL or DOCOLON。作用是保存当前IP，然后跳转到PFA中的下一个单词执行。
  * Exit 在fig-Forth 中被称作 ;S。作用是恢复保存的IP，然后跳转回去。
  * Next 无论用户单词或系统单词都有的,用在单词的最后.
  * PFA:  Parameter Field address, 用户单词的定义体（单词内容）。

(IP) -> W  fetch memory pointed by IP into "W" register
              ...W now holds address of the Code Field(CFA)

IP+2 -> IP advance IP, just like a program counter
              (assuming 2-byte addresses in the thread)
(W) ->  X  fetch memory pointed by W into "X" register
              ...X now holds address of the machine code 
JMP (X)     jump to the address in the X register

Enter 的伪流程
(the address of the Forth word just entered is kept in W. SEE NEXT)

PUSH IP to Reutrun Stack
ADD W, 3     //Parameter Field address -> W
MOV IP, W
NEXT

Exit 的伪流程
POP IP From RS
NEXT

NEXT 的伪流程
(IP) -> W  fetch memory pointed by IP into "W" register
              ...W now holds address of the Code Field(CFA)
IP + 2 -> IP //(assuming 2-byte addresses in the thread)
(W) -> X  // the machine code address of CFA in W
JMP (X)

关于8086的优化：
   AX = W         DI = scratch
   BX = TOS       SI = IP
   CX = scratch   BP = RSP
   DX = scratch   SP = PSP

Enter:
  XCHG SP,BP  //将系统堆栈指向FORTH返回栈, 注意，如果我系统堆栈作为返回栈该指令就不必!
  PUSH SI     //将IP指针压入FORTH返回栈
  XCHG SP, BP //还原, 注意，如果我系统堆栈作为返回栈该指令就不必!
  ADD AX, 3   //Parameter Field address -> W 我觉得应该是加2才对!!! ADD AX, SizeOf(Pointer)
  NEXT

Exit:
  XCHG SP,BP  //将系统堆栈指向FORTH返回栈, 注意，如果我系统堆栈作为返回栈该指令就不必!
  POP SI     //将IP指针压入FORTH返回栈
  XCHG SP, BP //还原, 注意，如果我系统堆栈作为返回栈该指令就不必!
  NEXT

Next:
  ITC:
    LODSW         // (SI) -> AX  means (IP) -> W, IP++
    MOV CX, [AX]  // (W) -> X
    JMP CX        // JMP (X)

  DTC:
    LODSW   // (SI) -> AX  means (IP) -> W, IP++
    JMP AX  // JMP (W)

== 最重要 AND wonderful DOES> 语句 ==
FORTH 单词定义的Body是由两部分构成的：CF(Code Field) and PF(Parameter Field).
 * The Code Field is the "action" taken by this Forth word, and the Parameter Field is the data on which it acts.
 * The Code Field is a subroutine call, and the Parameter Field is parameters that are included "in-line" after the call. (The assembly language programmer's view.)
 * The Code Field is the single "method" for this "class" of words, and the Parameter Field contains the "instance variables" for this particular word. (The object-oriented programmer's view.) 

Code Field过程总有一个参数――PF参数域的起始地址. CF过程用来解释PFA的内容，是单词，常量，变量，词汇表，等等。
FORTH预定了以下几种Code Field过程。

||    Code Field  || Parameter Field || 
||    routine     || contents        ||                
||    ENTER       || a high-level "thread" (series of addresses)  ||
||    DOCON       || a constant value ||
||    DOVAR       || a storage location for data  ||
||    DOVOC       || vocabulary info (varies by implementation) ||

通过DOES>语句，可以实现自己的Code Field过程。这样我可以很容易的通过扩充Code Field过程实现对Delphi过程以及stdcall,fastcall等等过程的调用。


2005-7-1
uForthCore_80386.pas
包含纯汇编过程.如果公用堆栈,那么就不能调整堆栈的大小了.不过无所谓.就当是自举好了.而且这样可以直接使用Delphi的过程。
因为汇编方法将会始终有一个默认参数（这样始终会有入口代码Push EBP），所以放弃，只用函数库的方式来实现核心词汇。


80386 中 EBP中的用法是作为堆栈的框架指针，快速访问堆栈框架中的中某个参数。

Delphi的前面三个参数放在：EAX, EDX, ECX中！接下来的参数按照从左到右的顺序依次压入堆栈.

function Test(const a: integer; const b: string; const c: TRec; const ok: integer; e: integer = 0): integer;
asm {push EBP; MOV EBP, ESP} //delphi 建立的代码
end {POP EBP; RET};//delphi 建立的代码

进入子程序访问堆栈的参数

[EBP+$04]：为CALL 指令压入的当前IP，供返回的时候用。
[EBP]：为在进入的子过程的时候Delphi压入的旧的EBP值！当退出该子过程的时候会自动恢复。注意仅当过程存在参数的时候才会压入旧的EBP

堆栈中的第一个参数(就是参数表中最后一个参数e): [EBP+$08]
堆栈中的第二个参数(就是参数表中倒数第二个参数ok): [EBP+$0C] 
：

注: 
  1. 如果是汇编方法,那么最后一个参数始终是该对象实例的地址(对于类方法而言则是该类的VMT表的地址)。
  2. 对于非汇编过程,该过程无论是否有参数或局部变量,都会有push EBP; MOV EBP, ESP的动作!也就是说如果我使用一般的过程,
     就不能将系统堆栈作为参数栈使用！

词汇的数据结构：
Core 词汇: 虚拟机器码 （或者用汇编）实现的。必须的！
System 词库： 以Core词汇为基础编写的，当然也可以用汇编实现，不过为了可移植性，最好两种实现方式都有。


2005-6-30
我对FORTH的设想：
几种执行机制都可采用，甚至可以包括Delphi Regiser, stdcall, fastcall等等这被称作调用方式。
在连接后（正式发布无调试信息状态）消除名字信息（Published的除外），只包括使用到的过程。
单词按照库名的方式分类组织。对单词的代码场的内容进行扩充。在调试状态下与原始的FORTH构架基本类似（统一用ITC机制执行）！
不过单词的代码场的内容多了调用方式、指向一下个同名的CFA域、以及参数的说明。
先实现类似解释性,然后在转向实现机器码.

  完整的Forth缓存器有下列六个。
  PSP:Parameter Stack(or data stack) Pointer
  TOS:Top Of Stack
  RSP:Return Stack Pointer
  IP :Interpreter Pointer
  UP :User Pointer
  W  :Working register
  另有其它缓存器，moving forth原文内称为X缓存器，亦有人用A(Addressing)缓存器。
  以下描述各缓存器功能。
  PSP,TOS：为数据堆栈相关缓存器，PSP为管理数据堆栈之指针器。
    而TOS为数据堆栈顶端缓存器，主因为数据堆栈动作量大，但只有一个进出口。
    若将顶端数据留在CPU之中，有加速数据处理的作用。
  RSP：为程序呼叫之返回堆栈指针器。
  IP ：执行Forth word用之地址缓存器，用以指向下次执行字为何，其运作和字典相关。
  UP ：使用者管理用缓存器，为多任务管理用缓存器，指向task作用区。记录其Task相关信息。
  W  ：辅助工作用缓存器，辅助字典动作或运算用。

FORTH编译：就是插入代码流的过程。
FORTH的执行：
  初始化
  根据不同的执行机制执行。我选ITC方式。

注意：在我的虚拟机器中TOS实质上就是 ParameterStackSize.

代码的在内存中的组织：

|Address of CFA|Address of CFA|....|NEXT

2005-6-16
！实现最简单的编译型的脚本执行器：
   只有全局变量，执行体（四则运算，赋值，显示）。
   还需要定义支持的数据类型，其余可以参考 2004-12-14。

2005-3-4
！列举需要实现的Forth核心词汇！

2005-1-12
Flowchart:
  Executor.LoadFromStream
    aFormator := GetPEFormat()
    if Assigned(aFormator) then
    else raise ESuperExecutor.Create(RSInvalidPEFormat);
2004-12-23
1、定义PE文件头格式
  定义类的方法属性
  俺的PE文件映像定义
  也许考虑定义模块: 代码，数据集合。
2、定义执行器类方法属性
3、定义编译器类方法属性

19:33 2004-12-14
任务计划：
1、VM运行器: 装入VM码，将VM码变成机器码直接运行。这样翻译一下就解决了代码重定向问题。
定义数据区域（区域划分）：
  代码区 CodeArea : 存放运行代码。
  数据区 DataArea : 存放全局变量。

  返回栈 ReturnStack: 就是用系统栈
  数据栈 DataStack: Intel CPU 上无数据栈,只有模拟？将寄存器串起来作为数据栈？
    EAX  : 1 POP Stack
    EDX  : 2
    ECX  : 3
    //EBX  : 4 注： EBX 是Delphi保留。
    决定,栈顶由最常用的三寄存器: EAX, EDX, ECX构成，然后其他数据放入系统栈！如果其他数据放入数据栈，有可能会破坏返回栈数据，如何保护？！
    算了，还是单独开辟一个数据区作为数据堆栈。备份EBX，然后将EBX作为数据堆栈指针。EBX=0 栈底
    可以同返回栈共用，不过ESP的入栈是减少一直到0，而数据栈EBX指针是增加一直到EBP（其实如果碰到ESP就不能再增加了！同样ESP如果碰到EBX那么也就不能再减少）。

定义实现的基本指令集:
    inAdd, //Add(n1+n2=n) n1 n2 -- n
    inSub, //subtract(n1-n2=n) n1 n2 -- n
    inInc, //add 1(n1+1=n) n1 1 -- n
    inDec, //subtract 1
    inMUL, //multiply (n1*n2=n) n1 n2 -- n
    inDIV, //divide(n1/n2=n) n1 n2 -- n

    {## Logical instuctions }
    inEQU, //equ(Result := n1=n2) n1 n2 -- T/F
    inNEQ, // not equ
    inLES, //less than
    inLEQ, //less than and equ
    inGET, //greater than
    inGEQ, //greater than and equ
    inNOT, //Negate(NOT)
    inAND,
    inOR,
    inXOR,

    {## Memory Operation Instruction }
    inSetValue,
    inGetValue,
    
    {## Proc Operation Instruction }
    inJMP,
    inJZ,
    inJNZ,
    inCall,
    inReturn,
    inNoop,

    {## Stack Operation Instuction }
    inPush,
    inPop,
    inDrop,
    inDUP,
    inSWAP,
    inOVER,
    inROT




_______________________________

世上最快的脚本引擎与TurboScript
原来以为Luna 是最快的，我还在为比Luna快若干倍沾沾自喜，现在知道错了，大大的错了，世界上最快的脚本引擎应该是 EUPHORIA 。
它主要被用于游戏中的脚本引擎，最近开放源码了。
 
它的解释器采用的是和我的TurboScript类似的脚本执行机构!但是在它的解释器中似乎没有提供中断、暂停的渠道，除非是编译的时候插入调试指令，而TurboScript则在每执行一个指令前都要检查是否需要停止。我想这是它比TurboScript快的原因吧，不过它的核心代码实在是太难读了，根本不是人读的，注释又少。直接虚拟指令运行效率比较，TurboScript比它慢0.25倍。不过值得高兴的是它的调用子过程的效率比 TurboScript 慢太多了，调用子过程的效率TurboScript比它高70%倍。下面是我的测试方法：
 
全部采用 QueryPerformanceCounter 高精度计数。

测试指令：简单测试加法运算；总共测试2017个加法指令与常数直接相加， 300*2017=605100
 
整数加：
x86汇编:
  ;计时开始
  MOV EBX, 300  BB2C010000
  ADD EBX, 300  81C32C010000
  ..... --- 总计 2017 次
  ADD EBX, 300  81C32C010000
  ;计时结束
 
结果运行时间：60
 
EUPHORIA 加法指令顺序执行效率测试脚本：【的内置数字类型只有 integer, 没有内置的小数类型，只能使用atom模拟。】
  --计时开始
    count = 300
    count +=300
    ..... --- 总计 2017 次
    count +=300
  --计时结束
 
结果运行时间：74 【难以置信，只比汇编慢18.9%倍】
 
Lua Script 脚本：【错误，Lua没有整数类型，它的数字类型只有一种：Double。】
  (计时开始)
  local count = 300
  count = count + 300
    ..... （总计 2017 次）
  count = count + 300
  (计时结束)

【Lua5.0.2】结果运行时间：110 【Lua5.1版本运行时间为：120 】

TurboScript ASM 脚本：
  (计时开始)
  300
  300 +
    ..... （总计 2017 次）
  300 +
  (计时结束)
 
结果运行时间：98 【比汇编慢38.8%倍,经过初步优化现在的运行时间已经是87（比汇编慢31.0%倍）； 当我进一步取消CPUStates(判断终止标志位)测试，运行时间居然和汇编差不多了：61！】
 

子过程调用效率测试
x86 汇编 子过程调用效率测试脚本:
function add(a,b: integer): integer;
asm
  mov EAX, a
  add EAX, b
end;
--计时开始
  asm
    mOV EAX, 300
    MOV EDX, 300    CALL ADD
    ..... （总计 2017 次）
    MOV EDX, 300    CALL ADD
--计时结束
结果运行时间：126
 
EUPHORIA 子过程调用效率测试脚本:
function iAdd(integer a, integer b)
  return a+b
end function
--计时开始
count = 300
count = iAdd(count, 300)
..... --- 总计 2017 次
count = iAdd(count, 300)
--计时结束
 
结果运行时间：522 【比汇编慢了近75.9%倍，比TurboScript 近调用慢近70%倍】

 
Lua Script 脚本：
function iAdd(a, b)
  return a+b
end function
  (计时开始)
  local count = 300
  count = iAdd(count, 300)
    ..... （总计 2017 次）
  count = iAdd(count, 300)
  (计时结束)

【Lua5.0.2】结果运行时间：1270 【Lua5.1版本运行时间为：1820 】

TurboScript 子过程近调用效率测试
: Add +;
--计时开始
300
300 Add
..... （总计 2017 次）
300 Add
--计时结束
结果运行时间：157【只比汇编慢19.7％倍，改用字节代码流后速度略有损失，现在是运行时间：169】

TurboScript 子过程模块内的远调用效率
结果运行时间：184【也只比汇编稍慢】

TurboScript 子过程模块之间的VM DLL远调用效率
: Add external 'test'; //该函数在另一文件中。
启用按需加载技术的结果运行时间：1082【不稳定徘徊在1082-8828】 <如果不使用Cache功能每次都要查找：2676-9980>
使用的是按需加载技术，也就是仅当该函数被调用的时候才加载，然后加上Cache技术，后面的调用就在内存中处理。
时间远远长于其它，是因为加载文件耗去了绝大部分时间
不使用按需加载技术，而是预先加载模块：
结果运行时间：202  <如果不使用Cache功能每次都要查找所花时间：1790>

原来lua 引擎是统一用double 实现的数字！不过，EUPHORIA 的数字类型却只是整数，然后就是 atom 这个应该算是variant，无法比。只有比比看看他们解释器的运行的空耗了。

以汇编运行为全速，空耗为0，计算比值！

double 汇编浮点加法直接执行的时间： 70
double 汇编浮点加法过程调用执行的时间： 80

直接 VM指令 执行：
EUPHORIA 空耗： 100-81.08=18.92
Lua  空耗： 100-63.64=36.36

VM 过程调用：
EUPHORIA 空耗： 100-24.14=75.86
Lua  空耗： 100-6.30=93.7

不管怎么说，EUPHORIA和Lua 都是是目前脚本引擎速度最快的，当然他们侧重点各有不同。通过速度比较，可以看出他们依然还有提升性能空间。

_______________________________
EUPHORIA 完整脚本
		   ---------------------------
		   -- Prime Sieve Benchmark --
		   -- "Shootout" Version    --
		   ---------------------------

without type_check
include dll.e
include machine.e


constant
         k32=open_dll("kernel32.dll"),
         qpf=define_c_func(k32,"QueryPerformanceFrequency",{C_UINT},C_INT),
         qpc=define_c_proc(k32,"QueryPerformanceCounter",{C_UINT})
--the latter is a function actually, but we don't care about the boolean
--status code it returns

if k32=-1 then --you're in trouble, or under Linux, or...
elsif qpf=-1 or qpc=-1 then --your Windows version doesn't support this
end if

constant p232=power(2,32)

--helper function to retrieve results
function int64ptr_to_atom(atom ptr)
  sequence s
  s=peek4s({ptr,2})
  return p232*s[2]+s[1]
end function
 
constant timeFactorPtr=allocate(8),
         timeRC=c_func(qpf,{timeFactorPtr}),
         timeFactor=int64ptr_to_atom(timeFactorPtr)
--counts are given in ticks, and there are timeFactor ticks per second

--now some variables
constant maxSections=6  --whatever positive integer suits you
sequence perfptr,total,times,started
perfptr=repeat(0,maxSections)
total=perfptr  --total execution time
times=total    --number of runs
started=times  --flags
for i=1 to maxSections do perfptr[i]=allocate(16) end for
--each structure will store two pairs of integers, for a total of 4*4=16 bytes

--ok, now the two procedures that start/end a timed section

procedure start(integer section)
  c_proc(qpc,{perfptr[section]})
  started[section]=1
end procedure

procedure stop(integer section)
  c_proc(qpc,{perfptr[section]+8})
  if not started[section] then return end if  --start time not valid
  started[section]=0
  times[section]+=1
  total[section] = (int64ptr_to_atom(perfptr[section]+8)-int64ptr_to_atom(perfptr[section]))
end procedure


--not sure you gain any real precision (in theory, you do) by keeping
--total[section] as a number of counts rather than an actual time.
--And you'd have to implement addition for int64s using the 31-bit Eu integer type,
--- not the best idea I'd think of.
--however: 1/ atoms don't lose arithmetic accuracy whileless than power(2,53);
--you can implement addition for int64s:

constant p229=power(2,29)  --largest Eu-integer power of 2
type int32(atom x)
  return integer(remainder(x,p229))
end type

type int64(object x)
  return integer(x) or
  (sequence(x) and length(x)=2 and int32(x[1]) and int32(x[2]))
end type


function iAdd(integer a, integer b)
  return a+b
end function

procedure main()
    integer count
start(1)
    count = 300
    count = iAdd(count, 300)
    .....
    count = iAdd(count, 300)
stop(1)
    printf(1, "Count: %d\n", count)  -- 1028
end procedure

puts(1, "Prime Sieve Benchmark\n")

atom t
t = time()  -- start timer
main()
t = time() - t -- end timer

printf(1, "time: %.2f\n", t)
printf(1, "time: %.2f\n", total[1])

if getc(0) then  -- wait for key press
end if

_______________________________
Lua 测试脚本
由于 Lua 不支持 int64 所以我不得不先为Lua添加过程:

program mLua;
{$APPTYPE CONSOLE}
uses
  Windows,  SysUtils,  Classes,
  lua;

var
  tB, tE: Int64;

function lua_startCount(L: Plua_State): Integer; cdecl;
begin
  QueryPerformanceCounter(tB);
  Result := 0;
end;

function lua_stopCount(L: Plua_State): Integer; cdecl;
begin
  QueryPerformanceCounter(tE);
  Result := 0;
end;

function lua_ShowCount(L: Plua_State): Integer; cdecl;
begin
  Writeln('Count:', tE-tB);
  Result := 0;
end;

//function to print lua data via delphi
function lua_print(L: Plua_State): Integer; cdecl;
var
  i, n: Integer;
begin
  write('Lua: ');
  n := lua_gettop(L);
  for i := 1 to n do
  begin
    if i > 1 then
      Write(#9);
    if lua_isstring(L, i) then
      Write(lua_tostring(L, i))
    else
      Write(Format('%s:%p', [lua_type(L, i), lua_topointer(L, i)]));
  end;
  WriteLn;
  Result := 0;
end;

var
  L: Plua_State = nil; //lua state
  script: tstringlist; //a stringlist to hold the lua script
  result: integer;     //0 if script executes ok

begin
  if ParamCount <= 0 then
  begin
    WriteLn('Usage: min.exe filename');
    Exit;
  end;

  //init lua dll
  LoadLua;
  LoadLuaLib;
  L := lua_open;
 try
 //register pseudo delphi array (class) in lua
  luaopen_array(L);

  //Register a delphi procedure/funtion for use in Lua
  lua_register(L, 'print', lua_print);
  lua_register(L, 'startCount', lua_startCount);
  lua_register(L, 'stopCount', lua_stopCount);
  lua_register(L, 'showCount', lua_ShowCount);

  //Load a lua script from a buffer
  script:=tstringList.Create;
  try
    try
     script.LoadFromFile(PChar(ParamStr(1)));
    except
      writeln('Can not load Script File:'+ParamStr(1));
      exit;
    end;
    lual_loadbuffer(L, script.gettext, length(script.gettext), 'myluascript');
  finally
    Script.Free; //clean up
  end;

  //Ask Lua to run our little script
  result := 0;
  result := lua_pcall(l, 0, LUA_MULTRET, 0);
  if result>0 then
  begin
    writeln('bad, bad script'); //should provide more usefull info
    lua_error(L);
  end
  else
    writeln('done with script');

 finally
  //close lua dll
  lua_close(L);
  UnLoadLua;
  UnLoadLuaLib;
 end;
end;

Lua 脚本：
――――――――――――――――――――――――――――――――
function iAdd(a, b)
  return a + b
end

startCount()
local count = 300
    count = iAdd(count, 300)
    --....
    count = iAdd(count, 300)
stopCount()

print("hello world, from Lua!\n")
showCount()
print("\nthe resut:")
print(count)
――――――――――――――――――――――――――――――――
