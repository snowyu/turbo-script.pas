2005-7-1
uForthCore_80386.pas
包含纯汇编过程.如果公用堆栈,那么就不能调整堆栈的大小了.不过无所谓.就当是自举好了.而且这样可以直接使用Delphi的过程。
因为汇编方法将会始终有一个默认参数（这样始终会有入口代码Push EBP），所以放弃，只用函数库的方式来实现核心词汇。


80386 中 EBP中的用法是作为堆栈的框架指针，快速访问堆栈框架中的中某个参数。

Delphi的前面三个参数放在：EAX, EDX, ECX中！接下来的参数按照从左到右的顺序依次压入堆栈.

function Test(const a: integer; const b: string; const c: TRec; const ok: integer; e: integer = 0): integer;
asm {push EBP; MOV EBP, ESP} //delphi 建立的代码
end {POP EBP; RET};//delphi 建立的代码

进入子程序访问堆栈的参数

[EBP+$04]：为CALL 指令压入的当前IP，供返回的时候用。
[EBP]：为在进入的子过程的时候Delphi压入的旧的EBP值！当退出该子过程的时候会自动恢复。注意仅当过程存在参数的时候才会压入旧的EBP

堆栈中的第一个参数(就是参数表中最后一个参数e): [EBP+$08]
堆栈中的第二个参数(就是参数表中倒数第二个参数ok): [EBP+$0C] 
：

注: 如果是汇编方法,那么最后一个参数始终是该对象实例的地址(对于类方法而言则是该类的VMT表的地址)。

词汇的数据结构：
Core 词汇: 虚拟机器码 （或者用汇编）实现的。必须的！
System 词库： 以Core词汇为基础编写的，当然也可以用汇编实现，不过为了可移植性，最好两种实现方式都有。


2005-6-30
我对FORTH的设想：
几种执行机制都可采用，甚至可以包括Delphi Regiser, stdcall, fastcall等等这被称作调用方式。
在连接后（正式发布无调试信息状态）消除名字信息（Published的除外），只包括使用到的过程。
单词按照库名的方式分类组织。对单词的代码场的内容进行扩充。在调试状态下与原始的FORTH构架基本类似（统一用ITC机制执行）！
不过单词的代码场的内容多了调用方式、指向一下个同名的CFA域、以及参数的说明。
先实现类似解释性,然后在转向实现机器码.

  完整的Forth缓存器有下列六个。
  PSP:Parameter Stack(or data stack) Pointer
  TOS:Top Of Stack
  RSP:Return Stack Pointer
  IP :Interpreter Pointer
  UP :User Pointer
  W  :Working register
  另有其它缓存器，moving forth原文内称为X缓存器，亦有人用A(Addressing)缓存器。
  以下描述各缓存器功能。
  PSP,TOS：为数据堆栈相关缓存器，PSP为管理数据堆栈之指针器。
    而TOS为数据堆栈顶端缓存器，主因为数据堆栈动作量大，但只有一个进出口。
    若将顶端数据留在CPU之中，有加速数据处理的作用。
  RSP：为程序呼叫之返回堆栈指针器。
  IP ：执行Forth word用之地址缓存器，用以指向下次执行字为何，其运作和字典相关。
  UP ：使用者管理用缓存器，为多任务管理用缓存器，指向task作用区。记录其Task相关信息。
  W  ：辅助工作用缓存器，辅助字典动作或运算用。

FORTH编译：就是插入代码流的过程。
FORTH的执行：
  初始化
  根据不同的执行机制执行。我选ITC方式。

注意：在我的虚拟机器中TOS实质上就是 ParameterStackSize.

代码的在内存中的组织：

|Address of CFA|Address of CFA|....|NEXT

2005-6-16
！实现最简单的编译型的脚本执行器：
   只有全局变量，执行体（四则运算，赋值，显示）。
   还需要定义支持的数据类型，其余可以参考 2004-12-14。

2005-3-4
！列举需要实现的Forth核心词汇！

2005-1-12
Flowchart:
  Executor.LoadFromStream
    aFormator := GetPEFormat()
    if Assigned(aFormator) then
    else raise ESuperExecutor.Create(RSInvalidPEFormat);
2004-12-23
1、定义PE文件头格式
  定义类的方法属性
  俺的PE文件映像定义
  也许考虑定义模块: 代码，数据集合。
2、定义执行器类方法属性
3、定义编译器类方法属性

19:33 2004-12-14
任务计划：
1、VM运行器: 装入VM码，将VM码变成机器码直接运行。这样翻译一下就解决了代码重定向问题。
定义数据区域（区域划分）：
  代码区 CodeArea : 存放运行代码。
  数据区 DataArea : 存放全局变量。

  返回栈 ReturnStack: 就是用系统栈
  数据栈 DataStack: Intel CPU 上无数据栈,只有模拟？将寄存器串起来作为数据栈？
    EAX  : 1 POP Stack
    EDX  : 2
    ECX  : 3
    //EBX  : 4 注： EBX 是Delphi保留。
    决定,栈顶由最常用的三寄存器: EAX, EDX, ECX构成，然后其他数据放入系统栈！如果其他数据放入数据栈，有可能会破坏返回栈数据，如何保护？！
    算了，还是单独开辟一个数据区作为数据堆栈。备份EBX，然后将EBX作为数据堆栈指针。EBX=0 栈底
    可以同返回栈共用，不过ESP的入栈是减少一直到0，而数据栈EBX指针是增加一直到EBP（其实如果碰到ESP就不能再增加了！同样ESP如果碰到EBX那么也就不能再减少）。

定义实现的基本指令集:
    inAdd, //Add(n1+n2=n) n1 n2 -- n
    inSub, //subtract(n1-n2=n) n1 n2 -- n
    inInc, //add 1(n1+1=n) n1 1 -- n
    inDec, //subtract 1
    inMUL, //multiply (n1*n2=n) n1 n2 -- n
    inDIV, //divide(n1/n2=n) n1 n2 -- n

    {## Logical instuctions }
    inEQU, //equ(Result := n1=n2) n1 n2 -- T/F
    inNEQ, // not equ
    inLES, //less than
    inLEQ, //less than and equ
    inGET, //greater than
    inGEQ, //greater than and equ
    inNOT, //Negate(NOT)
    inAND,
    inOR,
    inXOR,

    {## Memory Operation Instruction }
    inSetValue,
    inGetValue,
    
    {## Proc Operation Instruction }
    inJMP,
    inJZ,
    inJNZ,
    inCall,
    inReturn,
    inNoop,

    {## Stack Operation Instuction }
    inPush,
    inPop,
    inDrop,
    inDUP,
    inSWAP,
    inOVER,
    inROT
