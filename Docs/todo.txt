2006-11-21
～ 关于 JIT 即使编译器是可行的，保留内存区头部和数据区即可。

2006-11-15
~ 使用链表的意义在于可以在运行时刻快速的添加新的过程到模块而不必惊动编译器进行编译，这样极大的提高了速度。
  现在剩下的问题就是编译时刻的Meta信息和运行时刻的Meta信息的侧重点不一样，如何处理？
  TTurboMetaInfo = object //for typecast the memory.
  TTurboSymbol = class //for compiler
    FMetaInfo: PTurboMetaInfo; //通过连接的形式
  end;

终于明白自己为什么在Type定义这里卡住了原因，混淆了Delphi编译中使用，和让自己脚本本身能使用类型两个目的！
!+ 定义于Type有关的指令，将TurboMetaInfo作为Delphi写的编译或供外部【Delphi】使用。
   然后逐步过渡到使用脚本来写编译器。嘿嘿。
   VarType (var-addr -- varTypeAddr)
   现在我为啥需要编写TypeMetainfo，是因为编译的需要，建立语法树的需要！！所以~~~暂不管指令实现！


~ 使用外部变量来表述该变量是运行时绑定的: var [external] myvar。

!+ uTurboMetaInfo.pas  [将XXXEntry 里面的数据分离到本单元]
  the turboScript basic metadata for type, constants etc.
里面的字符串全部使用偏移量指向PShortString!
是否启动virtual 方法，也就是使用动态对象，这样的话，必须保留第一个字段指向VMT, 而且必须在装入后对该地址重定位。如果不用就没有VMT表！
先不管，做下去，看需要而定！
  //定义最基本的类型，所有的用户扩展类型，全部都是由下面的基本类型派生的！！
  TTurboTypeKind = ();
  TTurboMetaInfoRec = record
    VMT: Pointer; //使用动态方法
    TypeKind:  TTurboTypeKind;
    Name: PShortString;
  end;

  //the abstract 
  TTurboMetaInfo = object
    TypeKind:  TTurboTypeKind;
    Name: PShortString; //point to the offset
  end;

2006-11-13
!+ uTurboSymbols
  TTurboMetaData: in fact the symbols are the metaData. 最后我觉得还是命名为 TurboSymbol 吧。
  TTurboType = Class: the abstract turboScript base type.
  TTurboConstant = 
  TTurboVaraible = Class(TTurboConstant)
  
!+ uTurboTypes
~ 重新规划保留区内存：
  内存分配：
    代码区分为两部分，前面部分为系统数据区，保存模块参数。注意系统数据区编译好后就不能改变！除非重新编译。
    更改数据区为：MetaData数据区，用来保存类型信息，模块变量【字段】，字符串常量。
  文件流中：
    MetaData字段 保存的是MetaData在流中的偏移量。GlobalOptions 为MetaData大小。Executor 为代码区在流中的偏移量。
  TPreservedCodeMemory = packed record
    MetaData: Pointer; //point to the data memory.
    GlobalOptions: PTurboGlobalOptions;
    Executor: TCustomTurboModule;
    //##abondoned:this Module unique Index in this program, allocated by compiler.
    //##ModuleIndex: Integer;
    ModuleType: TTurboModuleType;
    UsedMemory: tsInt; //实际使用的大小
    MemorySize: tsInt; //分配代码区的大小
  end;
  
  //模块 MetaData 数据区前端内存分配
  TTurboMetaData = record
    InitializeProcEntry: PTurboProcEntry; //it is the offset address of the FMemory
    FinalizeProcEntry: PTurboProcEntry; //当从内存中unload之前被调用如果存在的话。
    //last Used(import) module entry.
    LastModuleEntry: PTurboModuleEntry;
    //有名字的函数链表，指向最后一个函数入口。
    LastWordEntry: PTurboWordEntry;
    //有名字的变量链表
    LastVariableEntry: PTurboVariableEntry;
    //RTTI TypeInfo 链表
    LastTypeInfoEntry: PTurboTypeInfoEntry;
  
  end;

  PTurboProcEntry = ^TTurboProcEntry;
  TTurboProcEntry = record
    Prior: PTurboTypeInfoEntry; //nil means no more
    Proc: Pointer;
  end;
  TTurboTypeInfoEntry = record
    Prior: PTurboTypeInfoEntry;
    TypeInfo: PTurboType;
  end;

//废弃：
PackageInfoTable: see system.pas:
  PackageInfo = ^PackageInfoTable;
  PackageInfoTable = packed record
    UnitCount : Integer;      { number of entries in UnitInfo array; always >= 0 }
    UnitInfo : PUnitEntryTable;
  end;
  { Compiler generated table to be processed sequentially to init & finit all package units }
  { Init: 0..Max-1; Final: Last Initialized..0                                              }
  UnitEntryTable = array [0..9999999] of PackageUnitEntry;
  PUnitEntryTable = ^UnitEntryTable;
  PackageUnitEntry = packed record
    Init, FInit : Pointer;
  end;


2006-11-12
!+ 定义最基础的数据类型：
  按用途来说： Type, Contant, Variable, Statement
  按Type来说： Integer, Float, String, Array, Record  //, Sequence(序列)
  分析清楚这些最基本的MetaType，我才能在运行时刻定义新的数据类型.
  【这只是一种尝试，暂缓构思】
  TypeDef
    Sequence = Type //也许这个类型该放入基本类型
    Grammar:
      '[' Element {, Element} ']'.

    Protected
      Count: Integer;
      Element: Type;
      Contents: array[1..Count] of Element;default;
    end;
    If = Statement
    Grammar:
      'IF' BoolVar:Identity 'THEN' DoThenStatementBlock:StatementBlock  'ELSE' DoElseStatementBlock:StatementBlock
    end;
  类型定义:
    Integer(Ordinal): Int8(1byte), Int16(2Byte), Int32(4Byte), Int64(8Byte); 
             UInt8(unsigned 8-bit integer), UInt16, UInt32, UInt64, 
             Boolean, Char(1Byte), WideChar(2Byte)
    
  Float: float32(Single), float64(Double).
  String:
  
!+ 构思语法树(=就是 TypeInfo):
  语法结构不是等于类型，而是类型是语法结构中的一种！
~ 阅读了 CLR扩展PE结构分析 后，发觉我完全可以参考 metadata中的#~流【heap】来实现我的类型流！
  不过它把所有的名称字符串单独放入一个堆中，效率？当然在流中的时候肯定是该堆的偏移量。

2006-11-11
* TTurboVMInstruction prefix from in to op
~ 是否所有的控制指令都使用偏移地址？CLR就是全部用偏移量！
  暂时不管吧！
!+ TTurboAddressRelocator： 哈，我想到了，可以将重定位功能放到 TPreservedCodeMemory 上面，呵呵我真聪明。
   代码区地址重定位：
     【本地】Call 地址
     【本地】变量地址
   数据区地址重定位：
     为了能够在运行时刻动态添加新类型和方法过程，所以将类型、过程链表等结构放在数据区。另外我的主要设计目的是编译时刻的速度
     所以那个需要在运行时候添加过程肯定稍微慢些。
     【2006-11-12】今天又想了下，其实可以不用链表的形式，对于编译时刻定义的类型过程可以用数组的形式在代码区前面确定下来，这样代码区实际上由参数区，类型定义区，代码区构成。
                   然后，运行时刻添加的类型过程，放入堆中。
                   很显然，这样一来，Data区就没有必要存在了，因为模块变量也可以用这样的数组形式固定在代码区。而运行时刻的新变量则只在堆中。
        

2006-11-8
* 分离代码区数据区
  * 重新调整文件结构
    将数据区放在代码区后面，数据区的偏移量 ＝ SizeOf(StreamHeader) + UsedMemory + 1。
  + TCustomTurboModule.DataMemory
  + TPreservedCodeMemory.Data
  * TCustomTurboModule
    * FindXXXEntry
    * LoadFromStream, SaveToStream, Reset
    + DataMemorySize
    * LoadUsedModules
    + UsedDataSize
    + AllocDataSpace, GrowData, AddXXXToData
  * TX86Interpreter
    CallFar, EmitString, EmitLString, FetchXXX, StoreXXX
!* 重新整理VM指令集
!+ 运行时刻将指令中的变量相对地址变为绝对地址
   + GetTurboInstructionLength(aOp: TTurboInstruction): Byte;
   + TTurboAddressRelocator
     + TranslateYoRelated
     + TranslateYoAbsoluted

2006-11-7
~ 【x86ASM】TEST :  AND imm8 with AL; set SF, ZF, PF according to result
* [Bug] ForthCompiler: 对于定义为>= Protected 的单词，需要使用远调用！
* [Bug] ForthCompiler: LastModuleEntry 忘记连接了。
* [Bug] 对齐算法有错误，造成有时变量无法存入数据！
* [TurboModule]  终于决定将 CPU States 移到全局参数中！
~ TurboScript 子过程模块之间的VM DLL远调用效率
  : Add external 'test'; //该函数在另一文件中。
  结果运行时间：1082 <如果不使用Cache功能每次都要查找：2676>
  使用的是按需加载技术，也就是仅当该函数被调用的时候才加载，然后加上Cache技术，后面的调用就在内存中处理。
* [TurboModule] 加上soLoadOnDemand参数功能，控制是否使能按需加载，在装入的时候判断，如果没有使能按需加载，就在这个时候将DLL装入。
  要不在模块上也加入这个参数呢？？
~ TODO:
  * 分离代码区数据区
  * 增加地址重定位器，当处于非编译状态时，地址为绝对地址（包括代码数据中的所有指针）。而当切换到编译状态的时候地址为相对地址。
    * 修改 X86Interpreter, 适应新的绝对地址，这样速度又将提升。
  * TypeInfo: 抽象基本类型，类型定义
  * 变量后期绑定，Word后期绑定
  * 改写汇编编译器，采用语法树生成代码，而不是现在的直接生成。
    * 制定Word参数类型（这样能实现对过程参数的语法检查）
  * DLL 远调用， Host 远调用
  * 制定类的底层规范
  * 制定异常处理机制
  * 制定高级语言规范
  小任务：
    * 完善单元初始和终止过程链
    * 增加编译开关：(Max)MemSize; (Max)ParamStackSize, (Max)ReturnStackSize, (Max)DataSize
      有个问题如果在文件里也有定义，到底是以命令行为准，还是以文件，我想是以文件！

2006-11-6
!* [Bug] !Tick 出现问题，值没有能保存进去！
* [VM] Forth DLL 调用初步测试通过！
* [Bug] 使用Unit的时候 全局参数 忘记 需要设置！！
* [Bug] ForthCompiler 对于Published 的定义的单词应该是用ExitFar!
  为了设置该参数，还是只有让Executor创建对象！！
~ ModuleFileAccessor
  如果要考虑支持树型Module名称： Module1.SubModule1.SubModule2，那么必须要有
    BasePath: 用于指明项目的库的基本Root目录，同时需要增加编译开关: "-Base:"，用来在编译单元的时候指明该单元的Base目录。
    SysPath: 用于指明TurboScript系统的Root目录
  搜索顺序为先找BasePath,再找SysPath. 这样BasePath就可以重载SysPath中的内容。
  为了测试，先不管这些，只实现flat Modules.
~ 注意ModuleEntry中的单元全部都是真实的需要引用的单元，对于那些直接嵌入的单元在运行时刻中是并不存在的。
  而对于真实的单元（类似于DLL），Module.Parant属性是没有用处的（它的目的是为直接嵌入的提供到底嵌入到哪里）。
  既然如此那就无所谓了，还是让Accessor 负责创建Module。
~ [奇思妙想] 将FastPrint控件包改造成能够编辑录入的界面设计系统。

2006-11-5
* ModuleAccessor 需要得知是用哪一种Executor Class,要不我把这个责任扔回去？
  * RequireModule 增加一个参数:
   + aModuleClass: TTurboModuleClass
   这样似乎不行啊，还是只能让上面一级（TurboModule负责创建，否则Create的参数无法设置！！）
* [ForthCompiler]
  + display error infomations on the console.
  + the switch options: -ge : generate the deatil error list file (*.lst)

2006-11-4 
~ 关于后期绑定，内部实现的初步设想是返回一个aBindingHandle，然后操作该handle.  FindVarBinding('aVarName'， aBindingHandle， pValue); 
   SetVarBinding(aBindingHandle) //变量被修改。
   不过，建议还可以参考CLR的实现，如果能找到的话。
~ 异常：采用表的形式，而不是嵌套堆栈的形式来存放异常处理过程，这样做的好处是：执行的时候不用在堆栈中压入处理过程，加快执行速度，缺点是错误发生的时候，查表速度慢。
  + 全局参数中加上 ExceptionProcessor: 指向该模块的异常处理中心的地址【该地址为"System"单元的过程偏移地址,也许该地址为绝对地址由主程序单元在初始化的时候设置更为妥当？】。
  + TurboWrodEntry中加上 ExceptionProcessBlock 字段指明当错误发生的时候该跳转到哪里去进行该处的异常处理？但是嵌套异常如何办？？嵌套异常全部写入该块中，并注明拦截的终止地址即可。
    try.finally 和 try..except的异同：都是捕获异常。
    try.finally 执行完成finally 的语句照样触发异常,跳过finally后面的语句退出过程；
    try..except 执行完成except 的语句后，如果没有raise不会触发异常，后面的语句照样执行；
  【注意：如果该单词不在WordEntry上那么就无法进行异常处理】
~ 关于远调用，先只实现  Forth, stdcall, pascal 三种，stdcall, pascal由于参数全部在堆栈所以根本无需要知道参数的个数，只需要知道有无返回值以及返回值的大小。
~ 关于可视性，将其排序，按照 published, public, ... 的顺序排列这样 published 能被最先找到！
~ 发现如果将过程从模块中分离存放在数据库中，似乎过于零散，这样不便于我异常处理的实现。我觉得可以将模块设想成原子动作表（如：某对象的所有动作，某模块的所有动作，某动作的所有原子动作），集中存放。
  还是必须分开存放，原因如下：
  1、便于运行时刻对该过程动态添加过程（动作）的参数，和修改。
~ 是否需要象CLR一样，将数据区独立出来？在代码区只有临时数据区，通过 Ldc.1 ..ldc.5 等指令直接访问。
  的确有必要，理由：代码区全是代码之后，便于地址重定位。将地址全部变成绝对地址后，性能绝对是提高，而不是降低。当然在启动性能上受到了损失。
  不过我这里的模块都是小模块，所以也谈不上损失多少的问题。
~ 在定义外部word的时候如何区分该word的module类型？？
  : Public Word external ["moduleName" [Lib|DLL|Host]] [stdcall|pascal|forth] [name "procname"] [index 1];
!* ModuleEntry.
  + Revision:
  + BuildDate TitmeStamp
  由于我在编译的时候将使用单元的过程的偏移量直接编入了代码中，所以必须判断单元的版本和日期，这样该单元被改变后会自动重新编译，取得最新的偏移量。
!+ [ForthCompiler] 需要加上使用 RequireModule(),然后取得过程的偏移量。
  + 需要完成 TurboFileAccessor.
~ 关于外部调用的实现，我有两个方案
  1、建立 CallExternal PTurboWordEntry 指令 这样具体外部函数的类型在该指令中解析
  1、在编译时刻分别解析不同的外部函数类型，然后产生对应调用指令。

2006-11-3
* [BUG] [ForthCompiler] 因为我在Object使用了string，但是却没有初始化object内存，在对赋值该string赋值的出现严重错误！！改为Shortstring即可。
* [BUG] [ForthCompiler] Int64, Integer 这类的变量必须AlignMem.
* [VM] reanme TTurboWordEntry packed record to TTurboWordBlock object!
+ [VM] !TICK:: store tickcount to variable address directly. (int64Addr -- )
+ [VM] StoreInt(!), StoreInt64(!i8), StoreByte(!i1), StoreWord(!i2)
+ [VM] FetchInt(@), FetchInt64(@i8), FetchByte(@i1), FetchWord(@i2)
* [VM] 修改指令长度为 Byte 而不是 Int32，这样保留内存区只有256个字节，最大基本指令只有255个，现目前使用了大概100多个，需要根据 CLR
  做最后修订。

~ packed record
  只有对里面的 Pointer, Integer, Int64, string 才会对齐。shortstring类型不会产生对齐。
!* change the TTurboWordEntry record to TTurboWordBlock object
  这样我就能在上面加上地址重定位到其它模块等的过程。
  ?!* Name to PPackedShortString;
~ 在64位的机器上同样可以使用32位指针！！而且并不存在64位的指针，指针最多到48位！

2006-11-2
* [ForthCompiler]
  + @Tick : push the QueryPerformanceCounter: int64 to stack. [临时指令]
  + i8+: add int64
  + i8-: sub int64  (i1 i2 -- int64= i2`-i1)

2006-11-1
~ TASK
  + [ForthCompiler] 完成 Word 结构:
    + FWords: array of PTurboWordEntry;
    + FUsedModules: array of PTurboModuleEntry;
    + extend Define Word 
      WordDefine : [WordVisibility] WordName ("external" FORTHCALL|STDCALL|PASCAL|REGISTER|FASTCALL) |CodeParts ;
        注意，默认为 ForthCall,其它的调用则是外部DLL调用！对于>Protected的ForthCall的过程，全部使用远调用。
      : [WordVisibility] WordName 
        ExternalWord
        |WordPart
      ";".
      ExternalWord = "EXTENAL" 
        StdCall
        |PascalCall
        |RegisterCall
        |FastCall
        |DefaultCall //the default forth call.
      
      StdCall ＝"STDCALL" ExternalWordPart.
      ExternalWordPart = Identity 
        "Name" Identity
        |"Index" Integer
      .

    + 测试远调用
    + 完成VM指令：调用 CallEntry WordEntry
    + 完成DLL调用

~ 关于地址，在代码区的地址为相对偏移地址，而使用内存分配的地址为绝对地址（如局部变量的字符串）。

CLR 的即使编译器优化得很好，至少在这个加法运算上:
    CFA := 300;
    QueryPerformanceCounter(tBegin);
    CFA:= CFA+300;
    CFA:= CFA+300;
    ....
    CFA:= CFA+300;
  他使用JIT编译后的：
  MOV ESI, 300  BE2C010000
  ADD ESI, 300  81C62C010000
  ...
  ADD ESI, 300
  Delphi 编译的：
  MOV EBX, 300  BB2C010000
  ADD EBX, 300  81C32C010000

  和Delphi编译的一样，只是使用的寄存器不一样，但是为啥时间差别这么大？？.net = 15; delphi=60;
  我在内存种强制将EBX改成ESI发现是和EBX一样的时间。这只能说明CLR在即时编译的时候做的优化 ＝ 300*XXX;不然不可能这么快。

EUPHORIA 脚本引擎才是最快的，多用于游戏开发中。它采用的是和我类似的脚本执行机构!但是在它的运行器中似乎没有中断的办法，而TurboScript则每执行一个指令前都要检查是否需要停止，除非是编译的时候插入调试指令。【它的核心代码写得简直不是人看的】
因此它比我的快，我的TurboScript要比它慢0.25倍(虚拟指令执行)。【1/74 = 0.01351(EUPHORIA)  1/98 = 0.01020(TurboScript), 1351:1020】
再测试下它的调用子过程的效率：1/522 = 0.0019157; TurboScript: 1/157 =  0.006369. 19157/63690 嘿嘿，俺的调用子程序的效率简直比它高到哪里去了！～！我调用子过程的速度比它快70%倍.
EUPHORIA 脚本:
function iAdd(integer a, integer b)
  return a+b
end function
--计时开始
count = 300
iAdd(count, 300)
...
iAdd(count, 300)
--计时结束

TurboScript脚本
: Add +;
--计时开始
300
300 Add
...
300 Add
--计时结束

2006-10-31
* [Bug] 将远调用作为对另一程序的调用，不要互相影响。
  也就是说，另一程序的状态和错误是完全独立的！
  当然这样的唯一遗憾就是：调用后无法得知其真实运行态。
  他们之间只有参数栈和返回栈是共享的。还有全局参数区。
!+ 全局参数区，将状态，和参数栈大小等参数纳入，这样才能减少远调用的复制操作。而且也能解决停止状态。
  TTurboGlobalOptions = record  //do not use the packed.
    //States: TTurboProcessorStates; //如果放在这里，速度会下降
    LastErrorCode: TTurboProcessorErrorCode;
    ParamStackBase: Pointer;
    ParamStackSize: Integer; //bytes
    ParamStackBottom: Pointer;
    ReturnStackBase: Pointer;
    ReturnStackSize: Integer; //bytes
    ReturnStackBottom: Pointer;
  end;
  
~ 近调用过程的性能损耗：
  以加法为例： 
  定义过程 : Add +; 与直接调用 "+" 虚拟指令比较：
  "+" 指令的速度＝ 1 (1/100)
  Add 过程调用的速度 ＝  0.568 (1/176)
  速度下降了43.2％[100-56.8].
  俺稍微优化了下，Add 过程调用的速度 ＝ 0.613(1/163)， 速度现在是虚拟指令速度的61.3%,下降了38.7％ 和没有优化前比，速度提升了4.5%.

2006-10-26
!+ 单元初始化(Init)and Final 过程要改变成链表形式，从第一个执行，加是到最后一个。
  目的：对于那些没有自己的内存的模块，但是有自己的初始化过程的，也要执行啊。
  PTurboWordLink = ^TTurboWordLink;
  TTurboWordLink = packed record
    Next: PTurboWordLink;
    Word: PTurboWordEntry;
  end;

!* 现在放在wordEntry上的全部都是近调用，应该是远调用才对。近调用的只有私有word,或在WordEntry上的visibility in [<=fsPrivate]。

2006-10-25
在内存中RTTI信息的链接方式，决定采用和VM机器指令同样的方式，当数值小于保留区为简单类型常量(TTurboSimpleType)，否则为相对偏移地址。
使用 Delphi单元 TypInfo 的 TTypeData。只不过里面的所有 PPTypeInfo 类型的字段变成了上述说明的。

+ uTurboTypes.pas
  专门处理 读入内存，创建装载MeTypes.
  //Create PMeProcType and load 
  LoadMeProcTypeFrom(aProcTypeData: PTurboProcTypeData): PMeProcType;
  既然只有一个过程，那么还是暂时放在TurboExecutor一起。



2006-10-24
+ Function RemoveModuleTypes(aModuleName: string)
  //remove registered types of this module
* call RemoveModuleTypes function when module is unloaded.
2. 是否缓存ProcType，也就是放到注册类型列表中，先不缓存：
  vProcType :=  getProcType(const Buffer):PMeProcType;
  New(vProc, Create);
  vProc.InitFrom(vProcType);
  vProc.AssignFromStack(ParamStack);
  Inc(ParamStackPointer, vProc.StackSize);

!+ MeString: 
  Length(Word) String #0(Byte)
  this string length can be 0-$FFFF
  MeString = packed record
    Len: Word;
    Str: array [1..Len] of char;default;
    EndOfString: char; //#0 always. EndOfString
  end;

  ShortString = packed record
    Len: Byte;
    Str: array [1..Len] of char;default;
  end;

  AnsiString ＝ ^ TAnsiString.Str;
  TAnsiString = packed record
    RefCount: Integer;
    Len: LongWord;
    Str: array [1..Len] of char; default;
    EndOfString: char; //#0 always. EndOfString
  end;

2006-10-23
~  开始弄 TypeInfo,
* TCustomModule
  + RegisteredTypes: TMeTypes;
+ [uTurboConsts] TStaticMemoryStream
基本类型：基本类型是内置的不需要放入流中。如何区分基本类型和自定义类型在流中。
在流中可以通过 数字的大小来区分，如： >=0 是基本类型，>0 的则是指向自定义类型的偏移地址。
过程类型不是基本类型

基本类型: TTurboType

定义流格式: 嘿嘿，我可以按照Delphi RTTI 的内存格式进行啊（TypInfoEx.pas）
TuroType: integer; //>=0 是基本类型，>0 的则是指向自定义类型的偏移地址。

ProcType Stream:
  Kind: TMethodKind
  //Name: packed ShortSting
  ParamCount: Byte
  ParamList: array[1,,ParamCount] of record
      Flags: TParamFlags;
      ParamType: Integer;
      ParamName: Packed ShortString;
  end;
  [ResultType: integer] //如果是函数

1. 需要函数来装入BufferToMeType
2. 是否缓存ProcType
3. 只建立一个RegisteredTypes 管理所有的类型？然后通过
  类型名称为： ModuleName.TypeName 来区分
  既然只用一个那么就可以使用MeType的全局GRegisteredTypes变量！！

自定义类型的生存周期：就是模块的生存周期。
后期绑定的类型不存在生存周期问题。

~ 考虑如何将类型纳入我的知识数据库
模块和类型放入知识库中：
  模块和类型的关系： krCollection

粒度：
  模块里面的类型过程等全部内容被放入一个字段（相当于文件存放在了数据库中）。
  模块里面的内容被拆散，每一个类型，过程被分别存放在不同的字段中(这时候，这些东西全部是后期绑定的)。

2006-10-21
~ 发现一种新的语言 Seed: 它的特点是可以自定义新的语法结构(for 语句，while语句等)，它的自身就是这样弄出来来的。
  http://seed7.sourceforge.net
~ 在网上看了看关于 ECMA standard common intermediate language CIL（也就是Dot.net 的CLR Microsoft Intermediate Language (MSIL)） 的实现，
  其思路和俺的差不多，都是面向堆栈，支持后期绑定（它称之为反射refelection）,metadata（运行时刻类型信息，还不知道是否是所有的都有，还是自己定义，不过如果想做到safecode，那么就必须知道meta信息，这样才能防止传入非法数据，我想managed code 一定有metainfo,最多名称没有）。
  我感兴趣的是，它是怎么实现不同大小的push指令的（它叫load）。
  所有的东西都是类，其实俺的实现也可以这么理解，模块＝类，至于说必须要传递自己这个参数，那不就是FMemory基址指针(我放在EDI中的)，就差一个VMT表了。
  不过有点乱的是对象实例和类如何区分？我这定义的应该是对象的类！而不是对象实例。
!+ 定义外部函数的 TTurboWordEntry CFA域的内容：
  外部的定义： 模块外部的Forth函数（可从调用约定看出）；在宿主(MainApp)中的函数；在DLL中的函数。
   PModuleEntry:
   PFunctionIndex:
   FunctionName: PTPackedString
   //参数个数
   //参数描述列表: Size InRegister(如果为0表示要压入堆栈，该域供Register and FastCall使用)
   
   返回值类型＝无，在EAX中；在EAX:EDX中；在浮点小数栈中；
   必须获知每一个参数类型，才能决定压入堆栈的参数是那些，尤其是register调用。
!* [CustomModule] 当在编译状态的时候，不作地址变换。
!+ 虚拟 CPU 识别的基本类型:
   Address
   Integer(int1, int2, int4(32位), int8(64位), nativeInt)
   Float
   String
- [FullSpeedFeature] From TTurboX86Interpreter
!* TTurboCodeFieldStyle = (cfsFunction, cfsHostFunction, cfsDLLFunction);
  cfsFunction: 
    published-protectd Function 就统一采用外部调用Foth函数的形式： ModuleAddr FunctionAddr
    而privated 的则是私有函数，只能在模块内使用。
  cfsHostFunction, cfsDLLFunction: 
    PModuleEntry: Pointer;
    Index: Integer; -1 means non-index visits.
    Name: PChar; //the function name in the DLL/Host.
* TTurboModuleEntry: 对其扩充
  + ModuleType: mtLib, mtHost, mtDLL
  * Module: Pointer:
      DLL Module(mtDLL): it's the DLL handle.
      ForthLib module(mtLib): loaded the instance of TCustomTurboModule.
      Host Module(mtHost): 如果不把host里的函数按模块组织就不用，否则就该设计一个新类来处理。
      nil means not assigned(or loaded).
外部DLL/Host函数执行流程如下：
根据 TTurboWordEntry的 TTurboExteralWordPFA.PModuleEntry获得 ModuleHandle,如果 ModuleHandle ＝ nil 那么装载该DLL,
还是用伪代码写：
if TTurboExteralWordPFA.ProcAddr = nil then
begin
  with TTurboExteralWordPFA.PModuleEntry do
  begin
    if ModuleHandle = nil then ModuleHandle := LoadLib(ModuleName);
    if TTurboExteralWordPFA.Index <> -1 then ProcAddr := GetProcAddrByIndex() 
    else ProcAddr := GetProcAddrByName();
    if ProcAddr = nil then raise Error!!
  end;
end;
DLLExecutor.Params := ParamStack()
DLLExecutor.ParamTypes
DLLExecutor.Run(ProcAddr);
换句话说，该过程的参数类型也必须注册！！
我必须使用静态对象，否则手工逐个填充VMT指针太累。
或者这么说需要伪meTypes添加类型的保存，装载流机制。
如果我在模块内那不是要重复，如果多个模块调用同一个外部函数？？
不过这是没有办法的事情，只能这样，你必须把模块想成DLL。


2006-10-20
+ [ASM] 定义常量，变量
  编译通过
  不过未能实现常量表达式的合并。
  常量测试完毕
  变量测试完毕
  暂时不实现 PushByte, pushWord 指令，全部以PushInt指令的形式实现。
+ 内部过程指令(也许在最终版本中删去)：
  等俺调用外部函数的通用指令搞好后，这些就用不着了。
  + .S(aStr: pShortString); (aStr -- ) 注意该地址是相对地址＝ Addr + Integer(FMemory)
  + .LS(aStr: pAnsiString); (aStr -- )

!* 当编译时候增加内存，有可能会发生FMemory的移动，这个时候，我用的是绝对地址，就会出错！！
  我应该根据编译状态，在编译的时候全部使用相对地址！！
  
!+ [ASM] Imports XXX,XXX2; 导入指令，可以讲其它源程序单元导入到直接，相当于 Include.
!+ [ASM] Uses XXX. XXX; 单元链接指令，相当于列举要使用的DLL表！！


* [Bug]  f发现在动态数组的 Object 中使用 长字符串 Name 记录出现错误，莫名奇妙的乱指！！
  改成ShortString,后正常。
  TTurboSimpleConst = object
  public
    Name: ShortString;

  TTurboSimpleVar = object(TTurboSimpleConst)
  FVars: array of TTurboSimpleVar;
  如果name 是 string 那么就出怪事情了：
  var
    ss: string = '';
  : Add + ;
  这个时候报告 Add 是重复的，发现是FVars中最后一个的Name域乱套的原因。
  明白了，我是直接整个记录 赋值，这样就不能让Name的字符串引用增加，看看是不是这个原因。
  tmd,不行还是同样的错误！！
  

~ [Coco/R] SynError 并不引起异常退出，而是将当前错误记入List，继续编译！！


2006-10-19
~ 需要知道Delphi是怎么处理将常量字符串赋值给变量的。
  首先将常量字符串放入内存区域（在程序的最后面）。然后指明字符串所在地址，调用一个函数将其复制到变量中！！
  在俺的一次汇编中无法实现这样的东东！！只能是嵌入。换句话说，如果是常量定义就立即在内存开辟空间。

  Delphi的全局变量放在程序的后面
  
AnsiString: 常量 
'0123456789'
$FFFF(引用计数) $000A(字符Count)  '0123456789' $00 (它的所有常量在内存中都是Aligned),空白处用00填充。

2006-10-18
~  EMIT, #'' 指令为临时测试用!!
* 修改了 TTurboProgram 从CustomExecutor派生了.
  然后 增加了 ExecutorClass 使用前必须赋值!
  将Executor 的Visibility 作为私有, 这样使用Program 的内存
* TCustomTurboModule  : 当 StoredInParent 的时候不要释放内存. 
  不过是否要ClearMemory起作用??
  不要,当StoredInParent 时候,不能清除内存!!因为内存是父亲的! 
  还有对于StoredInParent 的,Unload 不会起作用,因为已经装入到父亲了,除非是父亲卸载..
+ uTurboSymbols
  准备使用

2006-10-17
+ Varaible define: 全局变量定义.
+ const define

变量分为: 
  全局变量: 在代码空间内分配的,放在LastVariableEntry
  局部变量: 在数据栈上分配的,退出的时候释放.
  堆变量: 使用GetMem分配的,多用于字符串.

- TCustomTurboModule.TIB

2006-10-16
+ define word feature done. test passed.
+ print char feature. TCustomTurboExecutor.OnPrintChar Event
  EMIT(c --): send char out.
+ #'123'(-- 43 42 41) push the reverse string to parameter stack.

2006-10-15
  文件扩展名定义:
    *.tf  Turbo Forth(ASM) Script Source

tfcc.exe : Turbo Forth Command line Compiler.

模块名称由文件名决定.

!+ uTurboModuleFileAccessor

+ tsrun.dpr 初步完成:
  能显示执行结果数据栈或返回栈的内容,如果有内容的话.

!+ 增加过程的支持.
:Word ;
 
2006-10-14
  文件扩展名定义:
    *.tpc Turbo Script program Compiled
    *.tcu Turbo Script unit Compiled 
    *.ts  Turbo Script Source
 tscc.exe : Turbo Script Command line Compiler
 tsrun.exe <filename>: Turbo Script command line intercepter.
* 修改了 coco/R delphi ,使得我能在框架文件中的自定义生成的文件名.使用开关 $M"ModuleName"

2006-10-13
~ [COCO/R]
  如何获得当前的分析处的字符串!
  使用 TParser.LexString 函数
  例子:

SQLName <var aName : string> 
      =
           ident                                                                (. aName := LexString; .) 
           | SQLNameString                                                      (. aName := StripQuotes(LexString); .)

AssertStatement<Parent: TnxSqlNode; var Assertion: TnxSqlRootNode>              (. var TableName: string; .)
  =                                                                             (. Assertion := TnxSqlAssertion.Create(Parent); .)
    "ASSERT" "TABLE" SQLName<TableName>                                         (. TnxSqlAssertion(Assertion).TableName1 := TableName; .)
    "=" "TABLE" SQLName<TableName>                                              (. TnxSqlAssertion(Assertion).TableName2 := TableName; .)

  {} 表示 0个 或任意个.
2006-10-12
~  heap 使用Delphi的heap和相应的函数，字符串管理也使用Delphi的。

2006-10-11
!+ 定义汇编语言,编写汇编语言编译器.
   支持的类型: Byte, Word, DWord, Integer, Char, ShortString, AnsiString
   不支持自定义类型
   决定采用类似于Delphi的结构,而不是类似于汇编的.
   
   [标号] 操作码 [操作数]
   [[Published] 标号] DB [初值[,初值,初值]] //预留Byte 发布的将联入变量表 
   [标号] DW [初值] //预留字
   [标号] DDW [初值] //预留双字 
   [标号] DSS ['字符串初值'|Length] //预留短字符串 
   [标号] DS ['字符串初值'] //预留AnsiString字符串 
   :[Published] DefinedWord 
   ;

  类似于Delphi的:
  Lib aName;
  Const aConstName = Value;
  [Published] Var aVarName: Type [= InitValue];
  : [Published] DefinedWord
     [标号] 操作码 [操作数]
  ;
  
  initilization
  finalization
  End. //lib 

2006-10-9
~ [语法树] 
  如果是模块,首先编译使用的模块列表(UsedModules)
  首先需要编译有些Types信息(已经发布的RTTI, 并不是动态绑定的类型)进入内存 TTurboTypeSymbolList.Compile;
  {$TYPEINFO ON}, {$DynamicBinding ON}
  接着编译变量和类型常量进入内存.如果是$TYPEINFO ON,并且该类型也是发布的那么该变量的类型指针也被编入,否则如果只有变量是发布的,那么将只是TMeTypeKind的值被编入指示其基本类型; 动态绑定的变量不会编入内存!
  接着编入子过程,如果不是StoredInParent并且发现名为@@__Initilization__@@ 和 @@__Finalization__@@ 的过程则将相对地址连入保留内存!
  最后如果是过程,那么就编译自己,如果是模块,那么就编译子模块.

~ 源程序文件与数据库的同步问题?
  当通过语法树产生虚拟机器码的时候,如果数据库有效,是否需要将它们同步到数据库中?
  不需要在此时吧,提供一个方法,在编译成功后,调用该方法就可以保存到数据库中.
  其实就是更改AccessorMgr上的默认Accessor指向DBAccessor,然后save 即可.

2006-10-5
* 继续设计 uTurboCompiler 语法树 

2006-10-4
~ 对于私有Module, 那么该Module 实际上是不存在被合并到Parent

2006-10-2
+ 设计语法树类
   TTurboWord = Class(TCustomTurboModule); //用户自定义单词
     Words: TTurboWordList; //嵌套子过程
     Parent: TTurboWord; //同上. nil means root.
     Variables: TTurbovariableList
     Symbols: TTurboTypeList;
     //根据编译开关将这些列表的类编译进入Memory. 比如如果该模块的Accessor为DBAccessor,那么就只能使用后期绑定的形式编译.
     //还有如果该模块的编译开关要求函数分别
     procedure Compile; 

   TTurboModule = Class(TTurboWord)
     Childs: TTurboModuleList; //被 Parser 使用!
     UsedModules: TList;
   //TTurboVMWord = Class(TCustomTurboSymbol); //机器码只有操作符。也许不必考虑机器码。
   TTurboOpCode

2006-9-29
* [uTurboAccessor]
  * rename  uTurboScriptAccessor to uTurboAccessor
  * RegisterAccessor 放入Module管理器了
  + GTurboModuleManager
* rename uTurboScriptConsts to uTurboConsts

通知(释放通知,卸载通知)是否能作为AOP 功能加入?我现在的AOP是基于类添加功能的,换句话说,同一类的不同实例将共享同样的AOP对象.
通知定义: 当对象实例的某事件发生的时候,通知预定了该事件的对象实例.

看样子我必须将基于实例的AOP功能类早日拿出来,不然够呛(不得不在Feature上区分具体是那一个实例):
  TMeCustomInstanceFeature = 基于实例的AOP功能类,这样可以为每一对象实例添加新的属性.
  或者将基于Class的叫做功能类: TMeCustomFeatureClass
  还有一个方法就是修改VMT, 增加Object记录的大小,这样我就可以存放附加数据了.不过这样的话,必须要小心,在注入前不能有任何已经创建的注入对象!
  TMeNotificationFeature = Class(TMeCustomInstanceFeature)
  end;


2006-9-28
!+ 移植到MeScript
!+ 构造编译器中的模块类: uTurboCompiler.pas
   TTurboModule = Class(TCustomTurboModule)
     Childs: TTurboModuleList; //被 Parser 使用!
     Parent: TTurboModule; //同上. nil means root.
     UsedModules: TList;
     Words: TTurboWordList;
     Variables: TTurbovariableList
     Symbols: TTurboTypeList;
     //根据编译开关将这些列表的类编译进入Memory. 比如如果该模块的Accessor为DBAccessor,那么就只能使用后期绑定的形式编译.
     //还有如果该模块的编译开关要求函数分别
     procedure Compile; 
     //放到TCustomTurboExecutor中:
     //property LastWordEntry: PTurboWordEntry;
     //property LastVariableEntry: PTurboVariableEntry;
   TCustomTurboWord = Class(TCustomTurboSymbol);
   TCustomTurboVMWord = Class(TCustomTurboWord); //机器码只有操作符。也许不必考虑机器码。
   TTurboWord_JMP = Class(TCustomTurboWord); //下划线开始的为VM 机器码.
  至于类型我准备用uMeTypes的.

2006-9-27
!+ 建立TurboScript异常处理中心机制

分析 Delphi 异常处理中心机制
分析的结果就是我必须在完成对象等类型处理后,才能进行,它是放在SysUtils单元中..

+ 构思出了 TurboModuleAccessor 架构 in uTurboScriptAccessor.pas

~ 想法简化直接调用Delphi函数,这样就可以直接用Delphi的异常处理机制.直接用是做梦,不过可以参考编译产生的汇编.
开始构思语法树(独立于语言之外的)

2006-9-25
+ TurboModule Stream Header
!+ 构思 TurboModuleAccessor 架构
* [VM] 修订 EnterFar ModuleIndex cfa-addr 改为 MemBase-addr(另一模块的内存基址) cfa-addr
- [VM] 放弃 ModuleIndex 机制，因为我希望我的脚本(Program)能够在内存中并行工作，并且尽量节约内存：我采用的是一个Module只在内存中存在一份拷贝。
  而显然不通的Program ModuleIndex是不同的。所以放弃 ModuleIndex, 转而使用 LastModuleEntry-addr
+ [VM] CALLFAR PTurboModuleEntry cfa-addr: if PTurboModuleEntry = nil means it's self, do not lookup.  
+ TCustomTurboObject: FreeNotification

2006-9-23
~ 装入后的流，以流的大小作为 UsedMemory.
在Executor执行脚本前，必须做的事情有？
 如果希望，接着上次没有完成的地方做，就必须保留 SP, RSP 堆栈指针（放入保留内存？）.
 但是我的堆栈，是整个程序公用的（为了快速交换数据）。所以堆栈指针有可能被别的模块修改。这样保存堆栈指针就达不到目的。
 //数据栈指针、返回栈指针如果不为0，那么必须不能设置。
   没有问题，从内部执行（一个模块调用另一个模块的函数），无影响。但是从Delphi中调用模块函数后，在执行另一个模块中函数，就～～
   想发只允许从 TProgram 中调用执行，每次执行完毕，必须将堆栈指针传递给TProgram.
   在TProgram 中终止脚本执行，必须遍历每一个Executor,设置其状态。不妨将TProgram看作 root Executor，其他则是导入的模块,
怎样在Delphi中调用脚本函数，可以连续调用，能够持续。只需要保证数据栈指针即可。而返回栈除非是调试，否则不必要。

在Executor 上有 Import Modules(uses)： 使用到模块中的函数。还有ChildModules(不过这个似乎只在编译的时候有意义)。
//扁平化处理，只有Program上才存在ChildModules(TList 汇集所有装入的),所有装入的Module实例放在该处。层次化Module名只供查找用。
这里的ChildModules实际上就是 Import Modules 啊！！反正不管，实例只能有一个地方存在！

2006-9-22
~ 发现 如果将 States 控制在一个字节，那么速度将近会提升1倍
  MOV BL, mem 速度要快于 MOV DX, mem，将近快1倍。

~ Used Modules(Import Section):
  LastModuleEntry: Pointer; //last Used module entry.
  LastWordEntry: Pointer;   //所有这些Pointer都是相对FMemory的地址(当装入后是否考虑由装入者对该地址重定位？)
  //Import Module Entry
  TTurboModuleEntry = packed record
    PriorModule: Pointer; //相对地址指针
    ModuleIndex: integer;
    Module: TCustomTurboExecutor; //nil means not assigned(or loaded).
    Name: ShortString; //packed string, full module name with path.
  end;
  暂时不考虑地址重定位，总是作为相对Fmemory的地址存在。
  但是我发现自己很难抵挡住这样的诱惑，重定位后可以提升速度。那么我必须考虑，重定位函数放在那里？
  代码装载到内存后，需要重定位，代码保存到文件或其它地方，也需要将绝对地址转为相对地址。
  RelocateTurboMem(RelatedAddrToAbsoluteAddr)
  procedure TurboConvertAddrRelatedToAbsolute(const Mem: Pointer);
  asm
  end;
  procedure TurboConvertAddrAbsoluteToRelated(const Mem: Pointer);

2006-9-21
* 使用 寄存器作为状态寄存器，但是导致不能命令指令随时停止，所以，在将状态寄存器放入保留内存中，这样，就能命令停止了。EBX 成了临时寄存器。

~ 有没有取得当前执行地址的x86指令？
  答：不能，只能通过Call 间接取得。
+ [VM] 调用 register calling（delphi）写的函数：
  CallReg: register
  CallPascal: pascal
  CallStd: stdcall
  CallFast : fastcall
  如何准备参数？那就必须要知道过程需要几个参数，才能从数据栈中取出需要的个数。也就是我需要得知ProcType, 必须的信息是：ParamCount(以Integer为单位的，不是真正意义上的参数个数)
  CallReg Addr, CallReg 有一个操作数。 Addr 为该函数注册后的索引地址。

~ 外来函数在 TProgram 上注册好，还是在 Executor 上注册好呢？还是在 Executor 上注册好，至于后期绑定的，那就无所谓了，可以自由发挥。
  注册的函数结构： TTurboRegisteredFunctionRec = packed Record //合并后放在 LastWordEntry 中。
  ParamCount: Integer; //以Integer为单位的，不是真正意义上的参数个数
  CallingStyle: TCallingConvension;
  TypeInfo: Pointer; //nil means no RTTI info.: 实际上是一个相对于FMemory的地址。

+ [VM] 当调用其他模块的函数时候，是否需要保存现场？
  至少EDI(FMemory)和ESI(PC:Program Counter)需要保存。堆栈是共用，不需要保存。除非是delphi写的。
  但是我返回的时候？如何才能返回？
  回答：增加Far word, 和 near word, 对于私有过程（只在本模块内有效），采用 near word(默认, Enter, Exit); 对于能被其他模块访问的过程
  则采用far word(EnterFar, ExitFar).
  对于外部过程，调用的VM代码： EnterFar module-index cfa-address， 也就是说，对于near 调用，只需要直接写下地址，但是对于Far调用就必须要OpCode + OpRands
  在保留内存区增加 Index, 用来保存ModuleIndex,这样对于自己内部调用EnterFar，就不必要去查找模块地址了.
  这就是ForthDLL的链接方式调用！

iVMEnterFar:
在返回栈中保存EDI(旧的 FMemory 基址), 根据 ModuleIndex 查找模块内存基址，如果找到就设置EDI成新的 FMemory 基址,然后装入该函数的地址，其它就和VMEnter一样了，转去VMEnter。

  PUSH EDI
  LODSD
  CMP  EAX, [EDI].TPreservedCodeMemory.ModuleIndex
  JZ  @@DoLocalEnterFar
@@GetModuleAddr:
  PUSH EDX
  PUSH ESI
  PUSH EBX
  PUSH EBP
  
  MOV  EDX, EAX
  MOV  EAX, [EDI].TPreservedCodeMemory.Executor
  //function TCustomTruboExecutor.GetModuleMemoryAddr(aModuleIndex: Integer): Pointer;
  CALL TCustomTruboExecutor.GetModuleMemoryAddr
  POP EBP
  POP EBX
  POP ESI
  POP EDX

  CMP  EAX, 0
  JZ   @@NotFoundError
  MOV  EDI, EAX
  JMP @@Exit

@@NotFoundError:
  POP  EDI
  MOV  [EDI].TPreservedCodeMemory.LastErrorCode, errModuleIndex
  JMP  iVMHalt

@@DoLocalEnterFar:

@@Exit:
  LODSD
  ADD EAX, EDI
  JMP iVMEnter

iVMExitFar:
  POP ESI
  POP EDI
  JMP iVMNext

2006-9-20
+ 基本实现 TTurboX86Interpreter 解释器核心
  !+ 没有单步执行 ({$Define TurboScript_Stepping_Supports})
  !+ 返回栈＆数据栈没有溢出判断。 {$Define TurboScript_DataStack_Overflow_Inspect} {$Define TurboScript_ReturnStack_Overflow_Inspect}
  !+ 内存没有溢出判断 {$Define TurboScript_Memory_Overflow_Inspect}
~ 关于控制流程指令：到底转移地址是放在数据栈中还是操作数中？
  想通了，JMP指令操作数放在内存中，GOTO指令操作数在数据栈中，而且GOTO的参数只是绝对地址。
  GetBindingVar(str-addr -- addr) return the variable address(real absolute address). nil means not found.
  GetBindingWord(str-addr -- callingConvention addr) callingConvention 是表明该word的调用类型
  CallBinding (callingConvention addr -- ) 由于该函数可以在其它模块中，所以该地址为真实地址。

2006-9-14
~如果参数栈＆返回栈使用全局内存，好处就是多个执行器可以共享数据，坏处就是多个执行器不能并行执行。
 也许在执行器上面还应有一个类，这个类就可以管理参数栈＆返回栈内存以及参数，这样在这个类上就可以并行执行。
 这个类叫什么好呢？ TTurboProgram:
   TTurboProgram: Execute

记住这里的X86堆栈： 压入则是地址减少，弹出则是地址增加，ESP总是指向栈顶。
When an item is pushed onto the stack, the processor decrements the ESP
register, then writes the item at the new top of stack. When an item is popped off the stack, the
processor reads the item from the top of stack, then increments the ESP register

2005-7-19
* 决定不在字符串后面加对齐指令!!是怎么样就是怎么样!!

手工跟踪测试：
PC: CPU的运行指针
IP: FORTH的运行指针

调用核心词汇：iVMNext, 执行当前IP.
(IP) -> W  fetch memory pointed by IP into "W" register
              ...W now holds address of the Code Field(CFA)

IP+2 -> IP advance IP, just like a program counter
              (assuming 2-byte addresses in the thread)
(W) ->  X  fetch memory pointed by W into "X" register
              ...X now holds address of the machine code 
JMP (X)     jump to the address in the X register

2005-7-18
该测试下是否我写的解释器正确！！
* [Bug] 修正编译错误！！

Win32Forth 的数据栈采用的是我所设想的技巧:
数据栈使用的是Hardware栈，不过使用EBX作为实际栈顶。

EBX    <-- TOS Data
数据栈 <-- 第二个数据

(a b -- )
EBX = a
b is in  数据栈.

TIB: Text Input Buffer

修改FORTH解释器的内存映象的结构:
FORTH解释器初始化的时候，先分配的内存：
[cTIBLengthOffset]TIBLength: DWORD (#TIB=1)
[cToINOffset]>IN:DWORD(the current TIB index)
[cTIBOffset]TIB(1024 Byte):原有内存！

从磁盘装入:
[cLastWordEntryOffset]LastWordEntry: DWORD(PForthWord); 指向该程序或单元拥有的单词入口

cTIBLengthOffset = 0;
cToINOffset = cTIBLengthOffset + SizeOf(Integer);
cTIBOffset = cToINOffset + SizeOf(Integer);
cMAXTIBCount = 1024; //Bytes
cLastWordEntryOffset = cTIBOffset + cMAXTIBCount;

我又有点昏了，既然我这里的地址是相对偏移量，那么所有的地址都应该是才对！
因此@等FORTH词汇，也是取的相对偏移量！
如果需要存取绝对地址（外部地址）的数据，应该建立专门的非标准词汇来处理！
所以，我所写的一些词汇要改！！

另外：将TIB作为固定的缓冲区放入FORTH内存中，不错（SP-FORTH 分配的是1024个字节）。
spf_parser.f

必须在系统中实现的核心词汇:
spf_defkern.f
CODE _CREATE-CODE
CODE _CONSTANT-CODE
CODE _USER-CODE (this is SP-FORTH impl, not ANSI-FORTH)
CODE _SLITERAL
CODE _CLITERAL-CODE
CODE _USER-VALUE

其次为: spf_forthproc.f
@, !, DUP, LAST-CFA, ALLOT, DP, HERE, LAST, ",", 

6.1.2450 WORD 
CORE 

        ( char "<chars>ccc<char>" -- c-addr )

Skip leading delimiters. Parse characters ccc delimited by char. 
An ambiguous condition exists if the length of the parsed string 
is greater than the implementation-defined length of a counted string. 

c-addr is the address of a transient region containing the parsed word 
as a counted string. If the parse area was empty or contained no 
characters other than the delimiter, the resulting string has a zero 
length. A space, not included in the length, follows the string. A 
program may replace characters within the string. 

Note: The requirement to follow the string with a space is obsolescent 
and is included as a concession to existing programs that use CONVERT. 
A program shall not depend on the existence of the space. 

See: 3.3.3.6 Other transient regions, 3.4.1 Parsing, 6.2.2008 PARSE , A.6.1.2450 WORD 

It' for the input buffer process(TIB).

: WORD ( char "<chars>ccc<char>" -- c-addr ) \ 94
  DUP SKIP PARSE 255 MIN
  DUP SYSTEM-PAD C! SYSTEM-PAD 1+ SWAP QCMOVE
  0 SYSTEM-PAD COUNT + C!
  SYSTEM-PAD
;

2005-7-17
开始搞核心词汇。

2005-7-15
现在我有两种字符串在FORTH中,并且它们都是会对齐地址边界（基于Pointer的大小计算）：
ShortString: (ByteCount)PChar
String: (IntCount)PChar

function StrToPChar(const aV: string): PChar;
begin
  SHowMessage(IntToStr(Length(aV)));
  Result := Pchar(aV);
end;

procedure TForm1.Button1Click(Sender: TObject);
var
  d: PChar;
  a: pChar;
begin
  d := 'Hello world';

  a := StrToPChar(d);
  {in fact delphi will call the LStrFromPChar to convert the PChar(d) to String!}
end;


重新设定单词结构：
删除掉关于库名的设定。只有单词链表。
至于库不在此处处理。
也就是说LibEntry 变成了Forth Word Entry.

文件头:
MagicWord: 'SUPER4TH'
//类型 TYPE(TSuperForthFileType): 是程序，还是库
NAME：StrLen(Byte): string
版本号：DWORD
日期：DWORD(The Data field indicates the number of calendar days since the start of the calendar (the number of days since 1/1/0001 plus one).)
参数栈大小： DWORD，0表示默认。
返回栈大小： DWORD，0表示默认。未用，使用系统的返回栈。

装入内存的映象:
LibEntry: DWORD(PForthWord); 指向该程序或单元拥有的单词入口

因为要传递数据栈中的数据,所以,SP该是指针，可以指向别人！
不过对动态数组无所谓！暂时就先用动态数组。

2005-7-12
~ 关于连接和调用其它的脚本中的单词的问题。

调用的单元中必须对其进行说明：
ImportWord WordName LibName

放弃在一个程序（单元）中使用多个库多单词的结构。
在我的FORTH中对程序和单元不加区分，以后就统称为
单元，如果在单元中存在Main的单词，那么调用没指定
Word的Execute,就会执行Main这个单词。

只有保存到文件中才存在:MagicWord, UnitName
在流中不存在(为了方便我将VMCode直接写入数据库)

对于非本单元的词的分类：
Forth 词汇
Delphi
DLL

2005-7-11
+ FORTH解释器核心词汇:
  VMFillMem

2005-7-8
+ FORTH解释器核心词汇:
  Enter
  Exit
  Next

2005-7-7
按照 delphi帮助所说，当重新分配的内存块很大，它将会移动该块的地址到能放下的地方！
当移动后，除非是相对偏移量，否则字典中的CFA地址将全部出错！除非对绝对地址进行地址重定位。
另外如果在运行状态，那么对于已经压入堆栈的绝对地址，也会出错。

所以，必须将程序和数据分开才好，或者就只有采用固定大小的内存块。
暂时采用固定内存块，因为它的单词都是PFA。当然需要在运行中动态添加单词的应用毕竟是少数。

当然，如果所有的地址全部都是相对偏移量地址，那么就不会存在地址重定位。但是这样一来，速度
必然会受一定的影响。

在我的解释其实现中，堆栈的方向是向上递增的（压栈），它的栈顶指针总是指向未用的元素。
并且使用的地址全部都是相对偏移量地址.

解释器需要两个运行指针:
1. IP 机器指令的运行指针
2. PC FORTH的PFA解释运行指针

type
  TmMethod = procedure of object;
procedure TForm1.Button1Click(Sender: TObject);
var
  aProc: procedure;
  aT, aMethod: TmMethod;
begin
  //aProc := ;
  aMethod := test;
  aProc := TMethod(aMethod).Code;
  //aMethod;
  TMethod(aT).Code := @aProc;
  TMethod(aT).Data := Self;
  aT;
end;

2005-7-6
如何Cast 数组中的元素：
aLongWord := PLongWord(@Array[3])^
PForthLibEntry := PForthLib(@Array[3])


我相通了，FORTH在内存中的组织，可以根据不同地点具体实现方式不同而不同。
但是文件映像对于任何实现都必须是一样的！
在文件中的组织：
MagicWord: 'SUPER4TH'

类型 TYPE(TSuperForthFileType): 是程序，还是库
NAME：StrLen(Byte): string
版本号：DWORD
日期：DWORD(The Data field indicates the number of calendar days since the start of the calendar (the number of days since 1/1/0001 plus one).)
如果是程序：
  参数栈大小： DWORD，0表示默认。
  返回栈大小： DWORD，0表示默认。未用，使用系统的返回栈。
如果是库：
  参数栈大小： DWORD，0表示默认。未用
  返回栈大小： DWORD，0表示默认。未用，使用系统的返回栈。

LibEntry: DWORD; 指向该程序或单元拥有的单词库入口
  PriorLibEntry: DWORD(Pointer) 文件中的相对偏移量
  LibNameLen: Byte
  LibName: array [0..LibNameLen] of char, the last char is #0
  LastWord: DWORD(Pointer) //the last word. 因为它是一个只能向prior前移动的单向链表。

单词链:
    PriorWord: DWORD(Pointer); //前一个单词 0 means 为最前面。文件中的相对偏移量
    Precedence: Byte; //优先级, 0=low, 1=high equals 1 for an IMMEDIATE word
    //1=True; 0=False; Smudge bit. used to prevent FIND from finding this word
    //this can be extent to private, protected, public, etc
    Visibility: Byte; 
    CallStyle: Byte;
    CodeFieldStyle: Byte;
    ParamFieldLength: DWORD
    NameLen: Byte
    Name: array [0..NameLen] of char, the last char is #0
    //CFA: DWORD //其实就是直接指向的某个单词的PFA，不过那个单词的PFA就是直接执行的机器码而已。
               //CFA = ParameterFields[0]
    ParameterFields: array [0..PFLen-1] of integer(DWORD);

以上为文件中的组织。
_______________________________
  在内存中组织:
  TForthLib = packed record
    Name: string; //1 DWord(Pointer)
    PLastWord: PForthWord; //the last word. 因为它是一个只能向prior前移动的单向链表。
  end;
  //TForthWords = array of TForthWord;
  PForthWord = ^ TForthWord;
  TForthWord = packed record //ITC (Indirect Threaded Code)
    PriorWord: PForthWord; //前一个单词 -1 means 为最前面。
    Name: String;
    Precedence: Byte; //优先级, 0=low, 1=high equals 1 for an IMMEDIATE word
    //1=True; 0=False; Smudge bit. used to prevent FIND from finding this word
    //this can be extent to private, protected, public, etc
    Visibility: Byte; 
    CallStyle: Byte;
    CodeFieldStyle: Byte;
    //ParameterFields: array of PForthWord; //the first PFA is CFA.
  end;

对于编译型FORTH，CFA需要特别关注。因为在原始的ITC运行模式中，CFA直接指向的是执行的机器码地址。
而对于我的编译型FORTH，当加载已经编译的FORTH虚拟机后，如果CFA的执行码在Host中，那么就必须对该地址进行重定位。
那么如何区分CFA（在Host or VM）？
在FORTH Word 头结构中增加 CodeFieldStyle 属性：
cfsHost: the CF is in Host, so the CFA is the index No for the Host. Must fix.
cfsFORTH: the CF is in FORHT, so the CFA is the offset address of the FORTH, no need to fix.

2005-7-5
字典区结构：
1、字典索引区：包含的字典库
  在文件中的组织:
  LibNameLen: Byte;
  LibName: array [0..LibNameLen-1] of char
  LastWordOffset: Integer; //该库的最后一个单词的偏移量.

  在内存中组织:
  TForthLibs = array of TForthLib;
  TForthLib = packed record
    Name: String[31]; //32 bytes
    Words: TForthWords;
  end;
  TForthWords = array of TForthWord;
  PForthWord = ^ TForthWord;
  TForthWord = packed record //ITC (Indirect Threaded Code)
    PriorWord: PForthWord; //前一个单词 -1 means 为最前面。
    Name: String[31]; //32 bytes
    State: Word; //include Precedence bit(equals 1 for an IMMEDIATE word), Smudge bit(the 2nd bit used to prevent FIND from finding this word.)
    CallStyle: Word;
    ParameterFields: array of PForthWord; //the first PFA is CFA.
  end;
  放弃这样的内存组织，清晰倒是清晰，但是速度太慢！
  还是采用分配一个固定大小的内存区域作为字典区(统一放在Memory区)。

注：
  1. 对于非汇编过程,该过程无论是否有参数或局部变量,都会有push EBP; MOV EBP, ESP的动作!
     也就是说如果我想使用一般的过程,就不能将系统堆栈作为参数栈使用！

2005-7-4
为了避免重新计算地址，全部采用相对偏移量！

词汇的数据结构：
Core 词汇: 虚拟机器码 （或者用汇编）实现的。必须的！
System 词库： 以Core词汇为基础编写的，当然也可以用汇编实现，不过为了可移植性，最好两种实现方式都有。

怎么组织Unit？
增加一个Unit指针，类似于词汇指针CP, Context, Last, Current:

称之为字典区(或词汇区),这是单独的一个空间区域，有别于代码区，由ALLOT分配空间。


2005-7-2
在ITC机制下，所有的单词内容都是地址(指向其他单词的CFA的地址)。所以必须有一个简单的解释器（其实称不上解释，因为它把适当的跳转指令早已嵌入到代码流中了“Enter, Exit, Next”）执行。
通过CFA指向真实的机器执行码。
只不过对于用户定义的单词（For all colon(冒号) definitions）中，它的入口单词总是"Enter",出口单词总是"Exit"。

注意：
  * Enter 又的FORTH上称作 DOCOL or DOCOLON。作用是保存当前IP，然后跳转到PFA中的下一个单词执行。
  * Exit 在fig-Forth 中被称作 ;S。作用是恢复保存的IP，然后跳转回去。
  * Next 无论用户单词或系统单词都有的,用在单词的最后.
  * PFA:  Parameter Field address, 用户单词的定义体（单词内容）。

(IP) -> W  fetch memory pointed by IP into "W" register
              ...W now holds address of the Code Field(CFA)

IP+2 -> IP advance IP, just like a program counter
              (assuming 2-byte addresses in the thread)
(W) ->  X  fetch memory pointed by W into "X" register
              ...X now holds address of the machine code 
JMP (X)     jump to the address in the X register

Enter 的伪流程
(the address of the Forth word just entered is kept in W. SEE NEXT)

PUSH IP to Reutrun Stack
ADD W, 3     //Parameter Field address -> W
MOV IP, W
NEXT

Exit 的伪流程
POP IP From RS
NEXT

NEXT 的伪流程
(IP) -> W  fetch memory pointed by IP into "W" register
              ...W now holds address of the Code Field(CFA)
IP + 2 -> IP //(assuming 2-byte addresses in the thread)
(W) -> X  // the machine code address of CFA in W
JMP (X)

关于8086的优化：
   AX = W         DI = scratch
   BX = TOS       SI = IP
   CX = scratch   BP = RSP
   DX = scratch   SP = PSP

Enter:
  XCHG SP,BP  //将系统堆栈指向FORTH返回栈, 注意，如果我系统堆栈作为返回栈该指令就不必!
  PUSH SI     //将IP指针压入FORTH返回栈
  XCHG SP, BP //还原, 注意，如果我系统堆栈作为返回栈该指令就不必!
  ADD AX, 3   //Parameter Field address -> W 我觉得应该是加2才对!!! ADD AX, SizeOf(Pointer)
  NEXT

Exit:
  XCHG SP,BP  //将系统堆栈指向FORTH返回栈, 注意，如果我系统堆栈作为返回栈该指令就不必!
  POP SI     //将IP指针压入FORTH返回栈
  XCHG SP, BP //还原, 注意，如果我系统堆栈作为返回栈该指令就不必!
  NEXT

Next:
  ITC:
    LODSW         // (SI) -> AX  means (IP) -> W, IP++
    MOV CX, [AX]  // (W) -> X
    JMP CX        // JMP (X)

  DTC:
    LODSW   // (SI) -> AX  means (IP) -> W, IP++
    JMP AX  // JMP (W)

== 最重要 AND wonderful DOES> 语句 ==
FORTH 单词定义的Body是由两部分构成的：CF(Code Field) and PF(Parameter Field).
 * The Code Field is the "action" taken by this Forth word, and the Parameter Field is the data on which it acts.
 * The Code Field is a subroutine call, and the Parameter Field is parameters that are included "in-line" after the call. (The assembly language programmer's view.)
 * The Code Field is the single "method" for this "class" of words, and the Parameter Field contains the "instance variables" for this particular word. (The object-oriented programmer's view.) 

Code Field过程总有一个参数――PF参数域的起始地址. CF过程用来解释PFA的内容，是单词，常量，变量，词汇表，等等。
FORTH预定了以下几种Code Field过程。

||    Code Field  || Parameter Field || 
||    routine     || contents        ||                
||    ENTER       || a high-level "thread" (series of addresses)  ||
||    DOCON       || a constant value ||
||    DOVAR       || a storage location for data  ||
||    DOVOC       || vocabulary info (varies by implementation) ||

通过DOES>语句，可以实现自己的Code Field过程。这样我可以很容易的通过扩充Code Field过程实现对Delphi过程以及stdcall,fastcall等等过程的调用。


2005-7-1
uForthCore_80386.pas
包含纯汇编过程.如果公用堆栈,那么就不能调整堆栈的大小了.不过无所谓.就当是自举好了.而且这样可以直接使用Delphi的过程。
因为汇编方法将会始终有一个默认参数（这样始终会有入口代码Push EBP），所以放弃，只用函数库的方式来实现核心词汇。


80386 中 EBP中的用法是作为堆栈的框架指针，快速访问堆栈框架中的中某个参数。

Delphi的前面三个参数放在：EAX, EDX, ECX中！接下来的参数按照从左到右的顺序依次压入堆栈.

function Test(const a: integer; const b: string; const c: TRec; const ok: integer; e: integer = 0): integer;
asm {push EBP; MOV EBP, ESP} //delphi 建立的代码
end {POP EBP; RET};//delphi 建立的代码

进入子程序访问堆栈的参数

[EBP+$04]：为CALL 指令压入的当前IP，供返回的时候用。
[EBP]：为在进入的子过程的时候Delphi压入的旧的EBP值！当退出该子过程的时候会自动恢复。注意仅当过程存在参数的时候才会压入旧的EBP

堆栈中的第一个参数(就是参数表中最后一个参数e): [EBP+$08]
堆栈中的第二个参数(就是参数表中倒数第二个参数ok): [EBP+$0C] 
：

注: 
  1. 如果是汇编方法,那么最后一个参数始终是该对象实例的地址(对于类方法而言则是该类的VMT表的地址)。
  2. 对于非汇编过程,该过程无论是否有参数或局部变量,都会有push EBP; MOV EBP, ESP的动作!也就是说如果我使用一般的过程,
     就不能将系统堆栈作为参数栈使用！

词汇的数据结构：
Core 词汇: 虚拟机器码 （或者用汇编）实现的。必须的！
System 词库： 以Core词汇为基础编写的，当然也可以用汇编实现，不过为了可移植性，最好两种实现方式都有。


2005-6-30
我对FORTH的设想：
几种执行机制都可采用，甚至可以包括Delphi Regiser, stdcall, fastcall等等这被称作调用方式。
在连接后（正式发布无调试信息状态）消除名字信息（Published的除外），只包括使用到的过程。
单词按照库名的方式分类组织。对单词的代码场的内容进行扩充。在调试状态下与原始的FORTH构架基本类似（统一用ITC机制执行）！
不过单词的代码场的内容多了调用方式、指向一下个同名的CFA域、以及参数的说明。
先实现类似解释性,然后在转向实现机器码.

  完整的Forth缓存器有下列六个。
  PSP:Parameter Stack(or data stack) Pointer
  TOS:Top Of Stack
  RSP:Return Stack Pointer
  IP :Interpreter Pointer
  UP :User Pointer
  W  :Working register
  另有其它缓存器，moving forth原文内称为X缓存器，亦有人用A(Addressing)缓存器。
  以下描述各缓存器功能。
  PSP,TOS：为数据堆栈相关缓存器，PSP为管理数据堆栈之指针器。
    而TOS为数据堆栈顶端缓存器，主因为数据堆栈动作量大，但只有一个进出口。
    若将顶端数据留在CPU之中，有加速数据处理的作用。
  RSP：为程序呼叫之返回堆栈指针器。
  IP ：执行Forth word用之地址缓存器，用以指向下次执行字为何，其运作和字典相关。
  UP ：使用者管理用缓存器，为多任务管理用缓存器，指向task作用区。记录其Task相关信息。
  W  ：辅助工作用缓存器，辅助字典动作或运算用。

FORTH编译：就是插入代码流的过程。
FORTH的执行：
  初始化
  根据不同的执行机制执行。我选ITC方式。

注意：在我的虚拟机器中TOS实质上就是 ParameterStackSize.

代码的在内存中的组织：

|Address of CFA|Address of CFA|....|NEXT

2005-6-16
！实现最简单的编译型的脚本执行器：
   只有全局变量，执行体（四则运算，赋值，显示）。
   还需要定义支持的数据类型，其余可以参考 2004-12-14。

2005-3-4
！列举需要实现的Forth核心词汇！

2005-1-12
Flowchart:
  Executor.LoadFromStream
    aFormator := GetPEFormat()
    if Assigned(aFormator) then
    else raise ESuperExecutor.Create(RSInvalidPEFormat);
2004-12-23
1、定义PE文件头格式
  定义类的方法属性
  俺的PE文件映像定义
  也许考虑定义模块: 代码，数据集合。
2、定义执行器类方法属性
3、定义编译器类方法属性

19:33 2004-12-14
任务计划：
1、VM运行器: 装入VM码，将VM码变成机器码直接运行。这样翻译一下就解决了代码重定向问题。
定义数据区域（区域划分）：
  代码区 CodeArea : 存放运行代码。
  数据区 DataArea : 存放全局变量。

  返回栈 ReturnStack: 就是用系统栈
  数据栈 DataStack: Intel CPU 上无数据栈,只有模拟？将寄存器串起来作为数据栈？
    EAX  : 1 POP Stack
    EDX  : 2
    ECX  : 3
    //EBX  : 4 注： EBX 是Delphi保留。
    决定,栈顶由最常用的三寄存器: EAX, EDX, ECX构成，然后其他数据放入系统栈！如果其他数据放入数据栈，有可能会破坏返回栈数据，如何保护？！
    算了，还是单独开辟一个数据区作为数据堆栈。备份EBX，然后将EBX作为数据堆栈指针。EBX=0 栈底
    可以同返回栈共用，不过ESP的入栈是减少一直到0，而数据栈EBX指针是增加一直到EBP（其实如果碰到ESP就不能再增加了！同样ESP如果碰到EBX那么也就不能再减少）。

定义实现的基本指令集:
    inAdd, //Add(n1+n2=n) n1 n2 -- n
    inSub, //subtract(n1-n2=n) n1 n2 -- n
    inInc, //add 1(n1+1=n) n1 1 -- n
    inDec, //subtract 1
    inMUL, //multiply (n1*n2=n) n1 n2 -- n
    inDIV, //divide(n1/n2=n) n1 n2 -- n

    {## Logical instuctions }
    inEQU, //equ(Result := n1=n2) n1 n2 -- T/F
    inNEQ, // not equ
    inLES, //less than
    inLEQ, //less than and equ
    inGET, //greater than
    inGEQ, //greater than and equ
    inNOT, //Negate(NOT)
    inAND,
    inOR,
    inXOR,

    {## Memory Operation Instruction }
    inSetValue,
    inGetValue,
    
    {## Proc Operation Instruction }
    inJMP,
    inJZ,
    inJNZ,
    inCall,
    inReturn,
    inNoop,

    {## Stack Operation Instuction }
    inPush,
    inPop,
    inDrop,
    inDUP,
    inSWAP,
    inOVER,
    inROT




_______________________________

世上最快的脚本引擎与TurboScript
原来以为Luna 是最快的，我还在为比Luna快若干倍沾沾自喜，现在知道错了，大大的错了，世界上最快的脚本引擎应该是 EUPHORIA 。
它主要被用于游戏中的脚本引擎，最近开放源码了。
 
它的解释器采用的是和我的TurboScript类似的脚本执行机构!但是在它的解释器中似乎没有提供中断、暂停的渠道，除非是编译的时候插入调试指令，而TurboScript则在每执行一个指令前都要检查是否需要停止。我想这是它比TurboScript快的原因吧，不过它的核心代码实在是太难读了，根本不是人读的，注释又少。直接虚拟指令运行效率比较，TurboScript比它慢0.25倍。不过值得高兴的是它的调用子过程的效率比 TurboScript 慢太多了，调用子过程的效率TurboScript比它高70%倍。下面是我的测试方法：
 
全部采用 QueryPerformanceCounter 高精度计数。
 
x86汇编:
  ;计时开始
  MOV EBX, 300  BB2C010000
  ADD EBX, 300  81C32C010000
  ..... --- 总计 2017 次
  ADD EBX, 300  81C32C010000
  ;计时结束
 
结果运行时间：60
 
EUPHORIA 加法指令顺序执行效率测试脚本：
  --计时开始
    count = 300
    count +=300
    ..... --- 总计 2017 次
    count +=300
  --计时结束
 
结果运行时间：74 【难以置信，只比汇编慢18.9%倍】
 
TurboScript ASM 脚本：
  (计时开始)
  300
  300 +
    ..... （总计 2017 次）
  300 +
  (计时结束)
 
结果运行时间：98 【比汇编慢38.8%倍,经过初步优化现在的运行时间已经是88（比汇编慢31.8%倍）； 当我进一步取消CPUStates(判断终止标志位)测试，运行时间居然和汇编差不多了：61！】
 
子过程调用效率测试
x86 汇编 子过程调用效率测试脚本:
function add(a,b: integer): integer;
asm
  mov EAX, a
  add EAX, b
end;
--计时开始
  asm
    mOV EAX, 300
    MOV EDX, 300    CALL ADD
    ..... （总计 2017 次）
    MOV EDX, 300    CALL ADD
--计时结束
结果运行时间：126
 
EUPHORIA 子过程调用效率测试脚本:
function iAdd(integer a, integer b)
  return a+b
end function
--计时开始
count = 300
iAdd(count, 300)
..... --- 总计 2017 次
iAdd(count, 300)
--计时结束
 
结果运行时间：522 【比汇编慢了近75.9%倍，比TurboScript 近调用慢近70%倍】
 
TurboScript 子过程近调用效率测试
: Add +;
--计时开始
300
300 Add
..... （总计 2017 次）
300 Add
--计时结束
结果运行时间：157【只比汇编慢19.7％倍，改用字节代码流后速度略有损失，现在是运行时间：169】

TurboScript 子过程模块内的远调用效率
结果运行时间：184【也只比汇编稍慢】

TurboScript 子过程模块之间的VM DLL远调用效率
: Add external 'test'; //该函数在另一文件中。
需加载技术的结果运行时间：1082【不稳定徘徊在1082-8828】 <如果不使用Cache功能每次都要查找：2676-9980>
使用的是按需加载技术，也就是仅当该函数被调用的时候才加载，然后加上Cache技术，后面的调用就在内存中处理。
时间远远长于其它，是因为加载文件耗去了绝大部分时间
不使用按需加载技术，而是预先加载模块：
结果运行时间：212  <如果不使用Cache功能每次都要查找所花时间：1790>

_______________________________
EUPHORIA 完整脚本
		   ---------------------------
		   -- Prime Sieve Benchmark --
		   -- "Shootout" Version    --
		   ---------------------------

without type_check
include dll.e
include machine.e


constant
         k32=open_dll("kernel32.dll"),
         qpf=define_c_func(k32,"QueryPerformanceFrequency",{C_UINT},C_INT),
         qpc=define_c_proc(k32,"QueryPerformanceCounter",{C_UINT})
--the latter is a function actually, but we don't care about the boolean
--status code it returns

if k32=-1 then --you're in trouble, or under Linux, or...
elsif qpf=-1 or qpc=-1 then --your Windows version doesn't support this
end if

constant p232=power(2,32)

--helper function to retrieve results
function int64ptr_to_atom(atom ptr)
  sequence s
  s=peek4s({ptr,2})
  return p232*s[2]+s[1]
end function
 
constant timeFactorPtr=allocate(8),
         timeRC=c_func(qpf,{timeFactorPtr}),
         timeFactor=int64ptr_to_atom(timeFactorPtr)
--counts are given in ticks, and there are timeFactor ticks per second

--now some variables
constant maxSections=6  --whatever positive integer suits you
sequence perfptr,total,times,started
perfptr=repeat(0,maxSections)
total=perfptr  --total execution time
times=total    --number of runs
started=times  --flags
for i=1 to maxSections do perfptr[i]=allocate(16) end for
--each structure will store two pairs of integers, for a total of 4*4=16 bytes

--ok, now the two procedures that start/end a timed section

procedure start(integer section)
  c_proc(qpc,{perfptr[section]})
  started[section]=1
end procedure

procedure stop(integer section)
  c_proc(qpc,{perfptr[section]+8})
  if not started[section] then return end if  --start time not valid
  started[section]=0
  times[section]+=1
  total[section] = (int64ptr_to_atom(perfptr[section]+8)-int64ptr_to_atom(perfptr[section]))
end procedure


--not sure you gain any real precision (in theory, you do) by keeping
--total[section] as a number of counts rather than an actual time.
--And you'd have to implement addition for int64s using the 31-bit Eu integer type,
--- not the best idea I'd think of.
--however: 1/ atoms don't lose arithmetic accuracy whileless than power(2,53);
--you can implement addition for int64s:

constant p229=power(2,29)  --largest Eu-integer power of 2
type int32(atom x)
  return integer(remainder(x,p229))
end type

type int64(object x)
  return integer(x) or
  (sequence(x) and length(x)=2 and int32(x[1]) and int32(x[2]))
end type


function iAdd(integer a, integer b)
  return a+b
end function

procedure main()
    integer count
start(1)
    count = 300
    count = iAdd(count, 300)
    .....
    count = iAdd(count, 300)
stop(1)
    printf(1, "Count: %d\n", count)  -- 1028
end procedure

puts(1, "Prime Sieve Benchmark\n")

atom t
t = time()  -- start timer
main()
t = time() - t -- end timer

printf(1, "time: %.2f\n", t)
printf(1, "time: %.2f\n", total[1])

if getc(0) then  -- wait for key press
end if

    