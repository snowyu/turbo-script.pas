2006-10-26
!+ 单元初始化(Init)and Final 过程要改变成链表形式，从第一个执行，加是到最后一个。
  目的：对于那些没有自己的内存的模块，但是有自己的初始化过程的，也要执行啊。
  PTurboWordLink = ^TTurboWordLink;
  TTurboWordLink = packed record
    Next: PTurboWordLink;
    Word: PTurboWordEntry;
  end;

!* 现在放在wordEntry上的全部都是近调用，应该是远调用才对。近调用的只有私有word,或在WordEntry上的visibility in [<=fsPrivate]。

2006-10-25
在内存中RTTI信息的链接方式，决定采用和VM机器指令同样的方式，当数值小于保留区为简单类型常量(TTurboSimpleType)，否则为相对偏移地址。
使用 Delphi单元 TypInfo 的 TTypeData。只不过里面的所有 PPTypeInfo 类型的字段变成了上述说明的。

+ uTurboTypes.pas
  专门处理 读入内存，创建装载MeTypes.
  //Create PMeProcType and load 
  LoadMeProcTypeFrom(aProcTypeData: PTurboProcTypeData): PMeProcType;
  既然只有一个过程，那么还是暂时放在TurboExecutor一起。



2006-10-24
+ Function RemoveModuleTypes(aModuleName: string)
  //remove registered types of this module
* call RemoveModuleTypes function when module is unloaded.
2. 是否缓存ProcType，也就是放到注册类型列表中，先不缓存：
  vProcType :=  getProcType(const Buffer):PMeProcType;
  New(vProc, Create);
  vProc.InitFrom(vProcType);
  vProc.AssignFromStack(ParamStack);
  Inc(ParamStackPointer, vProc.StackSize);

!+ MeString: 
  Length(Word) String #0(Byte)
  this string length can be 0-$FFFF
  MeString = packed record
    Len: Word;
    Str: array [1..Len] of char;default;
    EndOfString: char; //#0 always. EndOfString
  end;

  ShortString = packed record
    Len: Byte;
    Str: array [1..Len] of char;default;
  end;

  AnsiString ＝ ^ TAnsiString.Str;
  TAnsiString = packed record
    RefCount: Integer;
    Len: LongWord;
    Str: array [1..Len] of char; default;
    EndOfString: char; //#0 always. EndOfString
  end;

2006-10-23
~  开始弄 TypeInfo,
* TCustomModule
  + RegisteredTypes: TMeTypes;
+ [uTurboConsts] TStaticMemoryStream
基本类型：基本类型是内置的不需要放入流中。如何区分基本类型和自定义类型在流中。
在流中可以通过 数字的大小来区分，如： >=0 是基本类型，>0 的则是指向自定义类型的偏移地址。
过程类型不是基本类型

基本类型: TTurboType

定义流格式: 嘿嘿，我可以按照Delphi RTTI 的内存格式进行啊（TypInfoEx.pas）
TuroType: integer; //>=0 是基本类型，>0 的则是指向自定义类型的偏移地址。

ProcType Stream:
  Kind: TMethodKind
  //Name: packed ShortSting
  ParamCount: Byte
  ParamList: array[1,,ParamCount] of record
      Flags: TParamFlags;
      ParamType: Integer;
      ParamName: Packed ShortString;
  end;
  [ResultType: integer] //如果是函数

1. 需要函数来装入BufferToMeType
2. 是否缓存ProcType
3. 只建立一个RegisteredTypes 管理所有的类型？然后通过
  类型名称为： ModuleName.TypeName 来区分
  既然只用一个那么就可以使用MeType的全局GRegisteredTypes变量！！

自定义类型的生存周期：就是模块的生存周期。
后期绑定的类型不存在生存周期问题。

~ 考虑如何将类型纳入我的知识数据库
模块和类型放入知识库中：
  模块和类型的关系： krCollection

粒度：
  模块里面的类型过程等全部内容被放入一个字段（相当于文件存放在了数据库中）。
  模块里面的内容被拆散，每一个类型，过程被分别存放在不同的字段中(这时候，这些东西全部是后期绑定的)。

2006-10-21
~ 发现一种新的语言 Seed: 它的特点是可以自定义新的语法结构(for 语句，while语句等)，它的自身就是这样弄出来来的。
  http://seed7.sourceforge.net
~ 在网上看了看关于 ECMA standard common intermediate language CIL（也就是Dot.net 的CLR Microsoft Intermediate Language (MSIL)） 的实现，
  其思路和俺的差不多，都是面向堆栈，支持后期绑定（它称之为反射refelection）,metadata（运行时刻类型信息，还不知道是否是所有的都有，还是自己定义，不过如果想做到safecode，那么就必须知道meta信息，这样才能防止传入非法数据，我想managed code 一定有metainfo,最多名称没有）。
  我感兴趣的是，它是怎么实现不同大小的push指令的（它叫load）。
  所有的东西都是类，其实俺的实现也可以这么理解，模块＝类，至于说必须要传递自己这个参数，那不就是FMemory基址指针(我放在EDI中的)，就差一个VMT表了。
  不过有点乱的是对象实例和类如何区分？我这定义的应该是对象的类！而不是对象实例。
!+ 定义外部函数的 TTurboWordEntry CFA域的内容：
  外部的定义： 模块外部的Forth函数（可从调用约定看出）；在宿主(MainApp)中的函数；在DLL中的函数。
   PModuleEntry:
   PFunctionIndex:
   FunctionName: PTPackedString
   //参数个数
   //参数描述列表: Size InRegister(如果为0表示要压入堆栈，该域供Register and FastCall使用)
   
   返回值类型＝无，在EAX中；在EAX:EDX中；在浮点小数栈中；
   必须获知每一个参数类型，才能决定压入堆栈的参数是那些，尤其是register调用。
!* [CustomModule] 当在编译状态的时候，不作地址变换。
!+ 虚拟 CPU 识别的基本类型:
   Address
   Integer(int1, int2, int4(32位), int8(64位), nativeInt)
   Float
   String
- [FullSpeedFeature] From TTurboX86Interpreter
!* TTurboCodeFieldStyle = (cfsFunction, cfsHostFunction, cfsDLLFunction);
  cfsFunction: 
    published-protectd Function 就统一采用外部调用Foth函数的形式： ModuleAddr FunctionAddr
    而privated 的则是私有函数，只能在模块内使用。
  cfsHostFunction, cfsDLLFunction: 
    PModuleEntry: Pointer;
    Index: Integer; -1 means non-index visits.
    Name: PChar; //the function name in the DLL/Host.
* TTurboModuleEntry: 对其扩充
  + ModuleType: mtLib, mtHost, mtDLL
  * Module: Pointer:
      DLL Module(mtDLL): it's the DLL handle.
      ForthLib module(mtLib): loaded the instance of TCustomTurboModule.
      Host Module(mtHost): 如果不把host里的函数按模块组织就不用，否则就该设计一个新类来处理。
      nil means not assigned(or loaded).
外部DLL/Host函数执行流程如下：
根据 TTurboWordEntry的 TTurboExteralWordPFA.PModuleEntry获得 ModuleHandle,如果 ModuleHandle ＝ nil 那么装载该DLL,
还是用伪代码写：
if TTurboExteralWordPFA.ProcAddr = nil then
begin
  with TTurboExteralWordPFA.PModuleEntry do
  begin
    if ModuleHandle = nil then ModuleHandle := LoadLib(ModuleName);
    if TTurboExteralWordPFA.Index <> -1 then ProcAddr := GetProcAddrByIndex() 
    else ProcAddr := GetProcAddrByName();
    if ProcAddr = nil then raise Error!!
  end;
end;
DLLExecutor.Params := ParamStack()
DLLExecutor.ParamTypes
DLLExecutor.Run(ProcAddr);
换句话说，该过程的参数类型也必须注册！！
我必须使用静态对象，否则手工逐个填充VMT指针太累。
或者这么说需要伪meTypes添加类型的保存，装载流机制。
如果我在模块内那不是要重复，如果多个模块调用同一个外部函数？？
不过这是没有办法的事情，只能这样，你必须把模块想成DLL。


2006-10-20
+ [ASM] 定义常量，变量
  编译通过
  不过未能实现常量表达式的合并。
  常量测试完毕
  变量测试完毕
  暂时不实现 PushByte, pushWord 指令，全部以PushInt指令的形式实现。
+ 内部过程指令(也许在最终版本中删去)：
  等俺调用外部函数的通用指令搞好后，这些就用不着了。
  + .S(aStr: pShortString); (aStr -- ) 注意该地址是相对地址＝ Addr + Integer(FMemory)
  + .LS(aStr: pAnsiString); (aStr -- )

!* 当编译时候增加内存，有可能会发生FMemory的移动，这个时候，我用的是绝对地址，就会出错！！
  我应该根据编译状态，在编译的时候全部使用相对地址！！
  
!+ [ASM] Imports XXX,XXX2; 导入指令，可以讲其它源程序单元导入到直接，相当于 Include.
!+ [ASM] Uses XXX. XXX; 单元链接指令，相当于列举要使用的DLL表！！


* [Bug]  f发现在动态数组的 Object 中使用 长字符串 Name 记录出现错误，莫名奇妙的乱指！！
  改成ShortString,后正常。
  TTurboSimpleConst = object
  public
    Name: ShortString;

  TTurboSimpleVar = object(TTurboSimpleConst)
  FVars: array of TTurboSimpleVar;
  如果name 是 string 那么就出怪事情了：
  var
    ss: string = '';
  : Add + ;
  这个时候报告 Add 是重复的，发现是FVars中最后一个的Name域乱套的原因。
  明白了，我是直接整个记录 赋值，这样就不能让Name的字符串引用增加，看看是不是这个原因。
  tmd,不行还是同样的错误！！
  

~ [Coco/R] SynError 并不引起异常退出，而是将当前错误记入List，继续编译！！


2006-10-19
~ 需要知道Delphi是怎么处理将常量字符串赋值给变量的。
  首先将常量字符串放入内存区域（在程序的最后面）。然后指明字符串所在地址，调用一个函数将其复制到变量中！！
  在俺的一次汇编中无法实现这样的东东！！只能是嵌入。换句话说，如果是常量定义就立即在内存开辟空间。

  Delphi的全局变量放在程序的后面
  
AnsiString: 常量 
'0123456789'
$FFFF(引用计数) $000A(字符Count)  '0123456789' $00 (它的所有常量在内存中都是Aligned),空白处用00填充。

2006-10-18
~  EMIT, #'' 指令为临时测试用!!
* 修改了 TTurboProgram 从CustomExecutor派生了.
  然后 增加了 ExecutorClass 使用前必须赋值!
  将Executor 的Visibility 作为私有, 这样使用Program 的内存
* TCustomTurboModule  : 当 StoredInParent 的时候不要释放内存. 
  不过是否要ClearMemory起作用??
  不要,当StoredInParent 时候,不能清除内存!!因为内存是父亲的! 
  还有对于StoredInParent 的,Unload 不会起作用,因为已经装入到父亲了,除非是父亲卸载..
+ uTurboSymbols
  准备使用

2006-10-17
+ Varaible define: 全局变量定义.
+ const define

变量分为: 
  全局变量: 在代码空间内分配的,放在LastVariableEntry
  局部变量: 在数据栈上分配的,退出的时候释放.
  堆变量: 使用GetMem分配的,多用于字符串.

- TCustomTurboModule.TIB

2006-10-16
+ define word feature done. test passed.
+ print char feature. TCustomTurboExecutor.OnPrintChar Event
  EMIT(c --): send char out.
+ #'123'(-- 43 42 41) push the reverse string to parameter stack.

2006-10-15
  文件扩展名定义:
    *.tf  Turbo Forth(ASM) Script Source

tfcc.exe : Turbo Forth Command line Compiler.

模块名称由文件名决定.

!+ uTurboModuleFileAccessor

+ tsrun.dpr 初步完成:
  能显示执行结果数据栈或返回栈的内容,如果有内容的话.

!+ 增加过程的支持.
:Word ;
 
2006-10-14
  文件扩展名定义:
    *.tpc Turbo Script program Compiled
    *.tcu Turbo Script unit Compiled 
    *.ts  Turbo Script Source
 tscc.exe : Turbo Script Command line Compiler
 tsrun.exe <filename>: Turbo Script command line intercepter.
* 修改了 coco/R delphi ,使得我能在框架文件中的自定义生成的文件名.使用开关 $M"ModuleName"

2006-10-13
~ [COCO/R]
  如何获得当前的分析处的字符串!
  使用 TParser.LexString 函数
  例子:

SQLName <var aName : string> 
      =
           ident                                                                (. aName := LexString; .) 
           | SQLNameString                                                      (. aName := StripQuotes(LexString); .)

AssertStatement<Parent: TnxSqlNode; var Assertion: TnxSqlRootNode>              (. var TableName: string; .)
  =                                                                             (. Assertion := TnxSqlAssertion.Create(Parent); .)
    "ASSERT" "TABLE" SQLName<TableName>                                         (. TnxSqlAssertion(Assertion).TableName1 := TableName; .)
    "=" "TABLE" SQLName<TableName>                                              (. TnxSqlAssertion(Assertion).TableName2 := TableName; .)

  {} 表示 0个 或任意个.
2006-10-12
~  heap 使用Delphi的heap和相应的函数，字符串管理也使用Delphi的。

2006-10-11
!+ 定义汇编语言,编写汇编语言编译器.
   支持的类型: Byte, Word, DWord, Integer, Char, ShortString, AnsiString
   不支持自定义类型
   决定采用类似于Delphi的结构,而不是类似于汇编的.
   
   [标号] 操作码 [操作数]
   [[Published] 标号] DB [初值[,初值,初值]] //预留Byte 发布的将联入变量表 
   [标号] DW [初值] //预留字
   [标号] DDW [初值] //预留双字 
   [标号] DSS ['字符串初值'|Length] //预留短字符串 
   [标号] DS ['字符串初值'] //预留AnsiString字符串 
   :[Published] DefinedWord 
   ;

  类似于Delphi的:
  Lib aName;
  Const aConstName = Value;
  [Published] Var aVarName: Type [= InitValue];
  : [Published] DefinedWord
     [标号] 操作码 [操作数]
  ;
  
  initilization
  finalization
  End. //lib 

2006-10-9
~ [语法树] 
  如果是模块,首先编译使用的模块列表(UsedModules)
  首先需要编译有些Types信息(已经发布的RTTI, 并不是动态绑定的类型)进入内存 TTurboTypeSymbolList.Compile;
  {$TYPEINFO ON}, {$DynamicBinding ON}
  接着编译变量和类型常量进入内存.如果是$TYPEINFO ON,并且该类型也是发布的那么该变量的类型指针也被编入,否则如果只有变量是发布的,那么将只是TMeTypeKind的值被编入指示其基本类型; 动态绑定的变量不会编入内存!
  接着编入子过程,如果不是StoredInParent并且发现名为@@__Initilization__@@ 和 @@__Finalization__@@ 的过程则将相对地址连入保留内存!
  最后如果是过程,那么就编译自己,如果是模块,那么就编译子模块.

~ 源程序文件与数据库的同步问题?
  当通过语法树产生虚拟机器码的时候,如果数据库有效,是否需要将它们同步到数据库中?
  不需要在此时吧,提供一个方法,在编译成功后,调用该方法就可以保存到数据库中.
  其实就是更改AccessorMgr上的默认Accessor指向DBAccessor,然后save 即可.

2006-10-5
* 继续设计 uTurboCompiler 语法树 

2006-10-4
~ 对于私有Module, 那么该Module 实际上是不存在被合并到Parent

2006-10-2
+ 设计语法树类
   TTurboWord = Class(TCustomTurboModule); //用户自定义单词
     Words: TTurboWordList; //嵌套子过程
     Parent: TTurboWord; //同上. nil means root.
     Variables: TTurbovariableList
     Symbols: TTurboTypeList;
     //根据编译开关将这些列表的类编译进入Memory. 比如如果该模块的Accessor为DBAccessor,那么就只能使用后期绑定的形式编译.
     //还有如果该模块的编译开关要求函数分别
     procedure Compile; 

   TTurboModule = Class(TTurboWord)
     Childs: TTurboModuleList; //被 Parser 使用!
     UsedModules: TList;
   //TTurboVMWord = Class(TCustomTurboSymbol); //机器码只有操作符。也许不必考虑机器码。
   TTurboOpCode

2006-9-29
* [uTurboAccessor]
  * rename  uTurboScriptAccessor to uTurboAccessor
  * RegisterAccessor 放入Module管理器了
  + GTurboModuleManager
* rename uTurboScriptConsts to uTurboConsts

通知(释放通知,卸载通知)是否能作为AOP 功能加入?我现在的AOP是基于类添加功能的,换句话说,同一类的不同实例将共享同样的AOP对象.
通知定义: 当对象实例的某事件发生的时候,通知预定了该事件的对象实例.

看样子我必须将基于实例的AOP功能类早日拿出来,不然够呛(不得不在Feature上区分具体是那一个实例):
  TMeCustomInstanceFeature = 基于实例的AOP功能类,这样可以为每一对象实例添加新的属性.
  或者将基于Class的叫做功能类: TMeCustomFeatureClass
  还有一个方法就是修改VMT, 增加Object记录的大小,这样我就可以存放附加数据了.不过这样的话,必须要小心,在注入前不能有任何已经创建的注入对象!
  TMeNotificationFeature = Class(TMeCustomInstanceFeature)
  end;


2006-9-28
!+ 移植到MeScript
!+ 构造编译器中的模块类: uTurboCompiler.pas
   TTurboModule = Class(TCustomTurboModule)
     Childs: TTurboModuleList; //被 Parser 使用!
     Parent: TTurboModule; //同上. nil means root.
     UsedModules: TList;
     Words: TTurboWordList;
     Variables: TTurbovariableList
     Symbols: TTurboTypeList;
     //根据编译开关将这些列表的类编译进入Memory. 比如如果该模块的Accessor为DBAccessor,那么就只能使用后期绑定的形式编译.
     //还有如果该模块的编译开关要求函数分别
     procedure Compile; 
     //放到TCustomTurboExecutor中:
     //property LastWordEntry: PTurboWordEntry;
     //property LastVariableEntry: PTurboVariableEntry;
   TCustomTurboWord = Class(TCustomTurboSymbol);
   TCustomTurboVMWord = Class(TCustomTurboWord); //机器码只有操作符。也许不必考虑机器码。
   TTurboWord_JMP = Class(TCustomTurboWord); //下划线开始的为VM 机器码.
  至于类型我准备用uMeTypes的.

2006-9-27
!+ 建立TurboScript异常处理中心机制

分析 Delphi 异常处理中心机制
分析的结果就是我必须在完成对象等类型处理后,才能进行,它是放在SysUtils单元中..

+ 构思出了 TurboModuleAccessor 架构 in uTurboScriptAccessor.pas

~ 想法简化直接调用Delphi函数,这样就可以直接用Delphi的异常处理机制.直接用是做梦,不过可以参考编译产生的汇编.
开始构思语法树(独立于语言之外的)

2006-9-25
+ TurboModule Stream Header
!+ 构思 TurboModuleAccessor 架构
* [VM] 修订 EnterFar ModuleIndex cfa-addr 改为 MemBase-addr(另一模块的内存基址) cfa-addr
- [VM] 放弃 ModuleIndex 机制，因为我希望我的脚本(Program)能够在内存中并行工作，并且尽量节约内存：我采用的是一个Module只在内存中存在一份拷贝。
  而显然不通的Program ModuleIndex是不同的。所以放弃 ModuleIndex, 转而使用 LastModuleEntry-addr
+ [VM] CALLFAR PTurboModuleEntry cfa-addr: if PTurboModuleEntry = nil means it's self, do not lookup.  
+ TCustomTurboObject: FreeNotification

2006-9-23
~ 装入后的流，以流的大小作为 UsedMemory.
在Executor执行脚本前，必须做的事情有？
 如果希望，接着上次没有完成的地方做，就必须保留 SP, RSP 堆栈指针（放入保留内存？）.
 但是我的堆栈，是整个程序公用的（为了快速交换数据）。所以堆栈指针有可能被别的模块修改。这样保存堆栈指针就达不到目的。
 //数据栈指针、返回栈指针如果不为0，那么必须不能设置。
   没有问题，从内部执行（一个模块调用另一个模块的函数），无影响。但是从Delphi中调用模块函数后，在执行另一个模块中函数，就～～
   想发只允许从 TProgram 中调用执行，每次执行完毕，必须将堆栈指针传递给TProgram.
   在TProgram 中终止脚本执行，必须遍历每一个Executor,设置其状态。不妨将TProgram看作 root Executor，其他则是导入的模块,
怎样在Delphi中调用脚本函数，可以连续调用，能够持续。只需要保证数据栈指针即可。而返回栈除非是调试，否则不必要。

在Executor 上有 Import Modules(uses)： 使用到模块中的函数。还有ChildModules(不过这个似乎只在编译的时候有意义)。
//扁平化处理，只有Program上才存在ChildModules(TList 汇集所有装入的),所有装入的Module实例放在该处。层次化Module名只供查找用。
这里的ChildModules实际上就是 Import Modules 啊！！反正不管，实例只能有一个地方存在！

2006-9-22
~ 发现 如果将 States 控制在一个字节，那么速度将近会提升1倍
  MOV BL, mem 速度要快于 MOV DX, mem，将近快1倍。

~ Used Modules(Import Section):
  LastModuleEntry: Pointer; //last Used module entry.
  LastWordEntry: Pointer;   //所有这些Pointer都是相对FMemory的地址(当装入后是否考虑由装入者对该地址重定位？)
  //Import Module Entry
  TTurboModuleEntry = packed record
    PriorModule: Pointer; //相对地址指针
    ModuleIndex: integer;
    Module: TCustomTurboExecutor; //nil means not assigned(or loaded).
    Name: ShortString; //packed string, full module name with path.
  end;
  暂时不考虑地址重定位，总是作为相对Fmemory的地址存在。
  但是我发现自己很难抵挡住这样的诱惑，重定位后可以提升速度。那么我必须考虑，重定位函数放在那里？
  代码装载到内存后，需要重定位，代码保存到文件或其它地方，也需要将绝对地址转为相对地址。
  RelocateTurboMem(RelatedAddrToAbsoluteAddr)
  procedure TurboConvertAddrRelatedToAbsolute(const Mem: Pointer);
  asm
  end;
  procedure TurboConvertAddrAbsoluteToRelated(const Mem: Pointer);

2006-9-21
* 使用 寄存器作为状态寄存器，但是导致不能命令指令随时停止，所以，在将状态寄存器放入保留内存中，这样，就能命令停止了。EBX 成了临时寄存器。

~ 有没有取得当前执行地址的x86指令？
  答：不能，只能通过Call 间接取得。
+ [VM] 调用 register calling（delphi）写的函数：
  CallReg: register
  CallPascal: pascal
  CallStd: stdcall
  CallFast : fastcall
  如何准备参数？那就必须要知道过程需要几个参数，才能从数据栈中取出需要的个数。也就是我需要得知ProcType, 必须的信息是：ParamCount(以Integer为单位的，不是真正意义上的参数个数)
  CallReg Addr, CallReg 有一个操作数。 Addr 为该函数注册后的索引地址。

~ 外来函数在 TProgram 上注册好，还是在 Executor 上注册好呢？还是在 Executor 上注册好，至于后期绑定的，那就无所谓了，可以自由发挥。
  注册的函数结构： TTurboRegisteredFunctionRec = packed Record //合并后放在 LastWordEntry 中。
  ParamCount: Integer; //以Integer为单位的，不是真正意义上的参数个数
  CallingStyle: TCallingConvension;
  TypeInfo: Pointer; //nil means no RTTI info.: 实际上是一个相对于FMemory的地址。

+ [VM] 当调用其他模块的函数时候，是否需要保存现场？
  至少EDI(FMemory)和ESI(PC:Program Counter)需要保存。堆栈是共用，不需要保存。除非是delphi写的。
  但是我返回的时候？如何才能返回？
  回答：增加Far word, 和 near word, 对于私有过程（只在本模块内有效），采用 near word(默认, Enter, Exit); 对于能被其他模块访问的过程
  则采用far word(EnterFar, ExitFar).
  对于外部过程，调用的VM代码： EnterFar module-index cfa-address， 也就是说，对于near 调用，只需要直接写下地址，但是对于Far调用就必须要OpCode + OpRands
  在保留内存区增加 Index, 用来保存ModuleIndex,这样对于自己内部调用EnterFar，就不必要去查找模块地址了.
  这就是ForthDLL的链接方式调用！

iVMEnterFar:
在返回栈中保存EDI(旧的 FMemory 基址), 根据 ModuleIndex 查找模块内存基址，如果找到就设置EDI成新的 FMemory 基址,然后装入该函数的地址，其它就和VMEnter一样了，转去VMEnter。

  PUSH EDI
  LODSD
  CMP  EAX, [EDI].TPreservedCodeMemory.ModuleIndex
  JZ  @@DoLocalEnterFar
@@GetModuleAddr:
  PUSH EDX
  PUSH ESI
  PUSH EBX
  PUSH EBP
  
  MOV  EDX, EAX
  MOV  EAX, [EDI].TPreservedCodeMemory.Executor
  //function TCustomTruboExecutor.GetModuleMemoryAddr(aModuleIndex: Integer): Pointer;
  CALL TCustomTruboExecutor.GetModuleMemoryAddr
  POP EBP
  POP EBX
  POP ESI
  POP EDX

  CMP  EAX, 0
  JZ   @@NotFoundError
  MOV  EDI, EAX
  JMP @@Exit

@@NotFoundError:
  POP  EDI
  MOV  [EDI].TPreservedCodeMemory.LastErrorCode, errModuleIndex
  JMP  iVMHalt

@@DoLocalEnterFar:

@@Exit:
  LODSD
  ADD EAX, EDI
  JMP iVMEnter

iVMExitFar:
  POP ESI
  POP EDI
  JMP iVMNext

2006-9-20
+ 基本实现 TTurboX86Interpreter 解释器核心
  !+ 没有单步执行 ({$Define TurboScript_Stepping_Supports})
  !+ 返回栈＆数据栈没有溢出判断。 {$Define TurboScript_DataStack_Overflow_Inspect} {$Define TurboScript_ReturnStack_Overflow_Inspect}
  !+ 内存没有溢出判断 {$Define TurboScript_Memory_Overflow_Inspect}
~ 关于控制流程指令：到底转移地址是放在数据栈中还是操作数中？
  想通了，JMP指令操作数放在内存中，GOTO指令操作数在数据栈中，而且GOTO的参数只是绝对地址。
  GetBindingVar(str-addr -- addr) return the variable address(real absolute address). nil means not found.
  GetBindingWord(str-addr -- callingConvention addr) callingConvention 是表明该word的调用类型
  CallBinding (callingConvention addr -- ) 由于该函数可以在其它模块中，所以该地址为真实地址。

2006-9-14
~如果参数栈＆返回栈使用全局内存，好处就是多个执行器可以共享数据，坏处就是多个执行器不能并行执行。
 也许在执行器上面还应有一个类，这个类就可以管理参数栈＆返回栈内存以及参数，这样在这个类上就可以并行执行。
 这个类叫什么好呢？ TTurboProgram:
   TTurboProgram: Execute

记住这里的X86堆栈： 压入则是地址减少，弹出则是地址增加，ESP总是指向栈顶。
When an item is pushed onto the stack, the processor decrements the ESP
register, then writes the item at the new top of stack. When an item is popped off the stack, the
processor reads the item from the top of stack, then increments the ESP register

2005-7-19
* 决定不在字符串后面加对齐指令!!是怎么样就是怎么样!!

手工跟踪测试：
PC: CPU的运行指针
IP: FORTH的运行指针

调用核心词汇：iVMNext, 执行当前IP.
(IP) -> W  fetch memory pointed by IP into "W" register
              ...W now holds address of the Code Field(CFA)

IP+2 -> IP advance IP, just like a program counter
              (assuming 2-byte addresses in the thread)
(W) ->  X  fetch memory pointed by W into "X" register
              ...X now holds address of the machine code 
JMP (X)     jump to the address in the X register

2005-7-18
该测试下是否我写的解释器正确！！
* [Bug] 修正编译错误！！

Win32Forth 的数据栈采用的是我所设想的技巧:
数据栈使用的是Hardware栈，不过使用EBX作为实际栈顶。

EBX    <-- TOS Data
数据栈 <-- 第二个数据

(a b -- )
EBX = a
b is in  数据栈.

TIB: Text Input Buffer

修改FORTH解释器的内存映象的结构:
FORTH解释器初始化的时候，先分配的内存：
[cTIBLengthOffset]TIBLength: DWORD (#TIB=1)
[cToINOffset]>IN:DWORD(the current TIB index)
[cTIBOffset]TIB(1024 Byte):原有内存！

从磁盘装入:
[cLastWordEntryOffset]LastWordEntry: DWORD(PForthWord); 指向该程序或单元拥有的单词入口

cTIBLengthOffset = 0;
cToINOffset = cTIBLengthOffset + SizeOf(Integer);
cTIBOffset = cToINOffset + SizeOf(Integer);
cMAXTIBCount = 1024; //Bytes
cLastWordEntryOffset = cTIBOffset + cMAXTIBCount;

我又有点昏了，既然我这里的地址是相对偏移量，那么所有的地址都应该是才对！
因此@等FORTH词汇，也是取的相对偏移量！
如果需要存取绝对地址（外部地址）的数据，应该建立专门的非标准词汇来处理！
所以，我所写的一些词汇要改！！

另外：将TIB作为固定的缓冲区放入FORTH内存中，不错（SP-FORTH 分配的是1024个字节）。
spf_parser.f

必须在系统中实现的核心词汇:
spf_defkern.f
CODE _CREATE-CODE
CODE _CONSTANT-CODE
CODE _USER-CODE (this is SP-FORTH impl, not ANSI-FORTH)
CODE _SLITERAL
CODE _CLITERAL-CODE
CODE _USER-VALUE

其次为: spf_forthproc.f
@, !, DUP, LAST-CFA, ALLOT, DP, HERE, LAST, ",", 

6.1.2450 WORD 
CORE 

        ( char "<chars>ccc<char>" -- c-addr )

Skip leading delimiters. Parse characters ccc delimited by char. 
An ambiguous condition exists if the length of the parsed string 
is greater than the implementation-defined length of a counted string. 

c-addr is the address of a transient region containing the parsed word 
as a counted string. If the parse area was empty or contained no 
characters other than the delimiter, the resulting string has a zero 
length. A space, not included in the length, follows the string. A 
program may replace characters within the string. 

Note: The requirement to follow the string with a space is obsolescent 
and is included as a concession to existing programs that use CONVERT. 
A program shall not depend on the existence of the space. 

See: 3.3.3.6 Other transient regions, 3.4.1 Parsing, 6.2.2008 PARSE , A.6.1.2450 WORD 

It' for the input buffer process(TIB).

: WORD ( char "<chars>ccc<char>" -- c-addr ) \ 94
  DUP SKIP PARSE 255 MIN
  DUP SYSTEM-PAD C! SYSTEM-PAD 1+ SWAP QCMOVE
  0 SYSTEM-PAD COUNT + C!
  SYSTEM-PAD
;

2005-7-17
开始搞核心词汇。

2005-7-15
现在我有两种字符串在FORTH中,并且它们都是会对齐地址边界（基于Pointer的大小计算）：
ShortString: (ByteCount)PChar
String: (IntCount)PChar

function StrToPChar(const aV: string): PChar;
begin
  SHowMessage(IntToStr(Length(aV)));
  Result := Pchar(aV);
end;

procedure TForm1.Button1Click(Sender: TObject);
var
  d: PChar;
  a: pChar;
begin
  d := 'Hello world';

  a := StrToPChar(d);
  {in fact delphi will call the LStrFromPChar to convert the PChar(d) to String!}
end;


重新设定单词结构：
删除掉关于库名的设定。只有单词链表。
至于库不在此处处理。
也就是说LibEntry 变成了Forth Word Entry.

文件头:
MagicWord: 'SUPER4TH'
//类型 TYPE(TSuperForthFileType): 是程序，还是库
NAME：StrLen(Byte): string
版本号：DWORD
日期：DWORD(The Data field indicates the number of calendar days since the start of the calendar (the number of days since 1/1/0001 plus one).)
参数栈大小： DWORD，0表示默认。
返回栈大小： DWORD，0表示默认。未用，使用系统的返回栈。

装入内存的映象:
LibEntry: DWORD(PForthWord); 指向该程序或单元拥有的单词入口

因为要传递数据栈中的数据,所以,SP该是指针，可以指向别人！
不过对动态数组无所谓！暂时就先用动态数组。

2005-7-12
~ 关于连接和调用其它的脚本中的单词的问题。

调用的单元中必须对其进行说明：
ImportWord WordName LibName

放弃在一个程序（单元）中使用多个库多单词的结构。
在我的FORTH中对程序和单元不加区分，以后就统称为
单元，如果在单元中存在Main的单词，那么调用没指定
Word的Execute,就会执行Main这个单词。

只有保存到文件中才存在:MagicWord, UnitName
在流中不存在(为了方便我将VMCode直接写入数据库)

对于非本单元的词的分类：
Forth 词汇
Delphi
DLL

2005-7-11
+ FORTH解释器核心词汇:
  VMFillMem

2005-7-8
+ FORTH解释器核心词汇:
  Enter
  Exit
  Next

2005-7-7
按照 delphi帮助所说，当重新分配的内存块很大，它将会移动该块的地址到能放下的地方！
当移动后，除非是相对偏移量，否则字典中的CFA地址将全部出错！除非对绝对地址进行地址重定位。
另外如果在运行状态，那么对于已经压入堆栈的绝对地址，也会出错。

所以，必须将程序和数据分开才好，或者就只有采用固定大小的内存块。
暂时采用固定内存块，因为它的单词都是PFA。当然需要在运行中动态添加单词的应用毕竟是少数。

当然，如果所有的地址全部都是相对偏移量地址，那么就不会存在地址重定位。但是这样一来，速度
必然会受一定的影响。

在我的解释其实现中，堆栈的方向是向上递增的（压栈），它的栈顶指针总是指向未用的元素。
并且使用的地址全部都是相对偏移量地址.

解释器需要两个运行指针:
1. IP 机器指令的运行指针
2. PC FORTH的PFA解释运行指针

type
  TmMethod = procedure of object;
procedure TForm1.Button1Click(Sender: TObject);
var
  aProc: procedure;
  aT, aMethod: TmMethod;
begin
  //aProc := ;
  aMethod := test;
  aProc := TMethod(aMethod).Code;
  //aMethod;
  TMethod(aT).Code := @aProc;
  TMethod(aT).Data := Self;
  aT;
end;

2005-7-6
如何Cast 数组中的元素：
aLongWord := PLongWord(@Array[3])^
PForthLibEntry := PForthLib(@Array[3])


我相通了，FORTH在内存中的组织，可以根据不同地点具体实现方式不同而不同。
但是文件映像对于任何实现都必须是一样的！
在文件中的组织：
MagicWord: 'SUPER4TH'

类型 TYPE(TSuperForthFileType): 是程序，还是库
NAME：StrLen(Byte): string
版本号：DWORD
日期：DWORD(The Data field indicates the number of calendar days since the start of the calendar (the number of days since 1/1/0001 plus one).)
如果是程序：
  参数栈大小： DWORD，0表示默认。
  返回栈大小： DWORD，0表示默认。未用，使用系统的返回栈。
如果是库：
  参数栈大小： DWORD，0表示默认。未用
  返回栈大小： DWORD，0表示默认。未用，使用系统的返回栈。

LibEntry: DWORD; 指向该程序或单元拥有的单词库入口
  PriorLibEntry: DWORD(Pointer) 文件中的相对偏移量
  LibNameLen: Byte
  LibName: array [0..LibNameLen] of char, the last char is #0
  LastWord: DWORD(Pointer) //the last word. 因为它是一个只能向prior前移动的单向链表。

单词链:
    PriorWord: DWORD(Pointer); //前一个单词 0 means 为最前面。文件中的相对偏移量
    Precedence: Byte; //优先级, 0=low, 1=high equals 1 for an IMMEDIATE word
    //1=True; 0=False; Smudge bit. used to prevent FIND from finding this word
    //this can be extent to private, protected, public, etc
    Visibility: Byte; 
    CallStyle: Byte;
    CodeFieldStyle: Byte;
    ParamFieldLength: DWORD
    NameLen: Byte
    Name: array [0..NameLen] of char, the last char is #0
    //CFA: DWORD //其实就是直接指向的某个单词的PFA，不过那个单词的PFA就是直接执行的机器码而已。
               //CFA = ParameterFields[0]
    ParameterFields: array [0..PFLen-1] of integer(DWORD);

以上为文件中的组织。
_______________________________
  在内存中组织:
  TForthLib = packed record
    Name: string; //1 DWord(Pointer)
    PLastWord: PForthWord; //the last word. 因为它是一个只能向prior前移动的单向链表。
  end;
  //TForthWords = array of TForthWord;
  PForthWord = ^ TForthWord;
  TForthWord = packed record //ITC (Indirect Threaded Code)
    PriorWord: PForthWord; //前一个单词 -1 means 为最前面。
    Name: String;
    Precedence: Byte; //优先级, 0=low, 1=high equals 1 for an IMMEDIATE word
    //1=True; 0=False; Smudge bit. used to prevent FIND from finding this word
    //this can be extent to private, protected, public, etc
    Visibility: Byte; 
    CallStyle: Byte;
    CodeFieldStyle: Byte;
    //ParameterFields: array of PForthWord; //the first PFA is CFA.
  end;

对于编译型FORTH，CFA需要特别关注。因为在原始的ITC运行模式中，CFA直接指向的是执行的机器码地址。
而对于我的编译型FORTH，当加载已经编译的FORTH虚拟机后，如果CFA的执行码在Host中，那么就必须对该地址进行重定位。
那么如何区分CFA（在Host or VM）？
在FORTH Word 头结构中增加 CodeFieldStyle 属性：
cfsHost: the CF is in Host, so the CFA is the index No for the Host. Must fix.
cfsFORTH: the CF is in FORHT, so the CFA is the offset address of the FORTH, no need to fix.

2005-7-5
字典区结构：
1、字典索引区：包含的字典库
  在文件中的组织:
  LibNameLen: Byte;
  LibName: array [0..LibNameLen-1] of char
  LastWordOffset: Integer; //该库的最后一个单词的偏移量.

  在内存中组织:
  TForthLibs = array of TForthLib;
  TForthLib = packed record
    Name: String[31]; //32 bytes
    Words: TForthWords;
  end;
  TForthWords = array of TForthWord;
  PForthWord = ^ TForthWord;
  TForthWord = packed record //ITC (Indirect Threaded Code)
    PriorWord: PForthWord; //前一个单词 -1 means 为最前面。
    Name: String[31]; //32 bytes
    State: Word; //include Precedence bit(equals 1 for an IMMEDIATE word), Smudge bit(the 2nd bit used to prevent FIND from finding this word.)
    CallStyle: Word;
    ParameterFields: array of PForthWord; //the first PFA is CFA.
  end;
  放弃这样的内存组织，清晰倒是清晰，但是速度太慢！
  还是采用分配一个固定大小的内存区域作为字典区(统一放在Memory区)。

注：
  1. 对于非汇编过程,该过程无论是否有参数或局部变量,都会有push EBP; MOV EBP, ESP的动作!
     也就是说如果我想使用一般的过程,就不能将系统堆栈作为参数栈使用！

2005-7-4
为了避免重新计算地址，全部采用相对偏移量！

词汇的数据结构：
Core 词汇: 虚拟机器码 （或者用汇编）实现的。必须的！
System 词库： 以Core词汇为基础编写的，当然也可以用汇编实现，不过为了可移植性，最好两种实现方式都有。

怎么组织Unit？
增加一个Unit指针，类似于词汇指针CP, Context, Last, Current:

称之为字典区(或词汇区),这是单独的一个空间区域，有别于代码区，由ALLOT分配空间。


2005-7-2
在ITC机制下，所有的单词内容都是地址(指向其他单词的CFA的地址)。所以必须有一个简单的解释器（其实称不上解释，因为它把适当的跳转指令早已嵌入到代码流中了“Enter, Exit, Next”）执行。
通过CFA指向真实的机器执行码。
只不过对于用户定义的单词（For all colon(冒号) definitions）中，它的入口单词总是"Enter",出口单词总是"Exit"。

注意：
  * Enter 又的FORTH上称作 DOCOL or DOCOLON。作用是保存当前IP，然后跳转到PFA中的下一个单词执行。
  * Exit 在fig-Forth 中被称作 ;S。作用是恢复保存的IP，然后跳转回去。
  * Next 无论用户单词或系统单词都有的,用在单词的最后.
  * PFA:  Parameter Field address, 用户单词的定义体（单词内容）。

(IP) -> W  fetch memory pointed by IP into "W" register
              ...W now holds address of the Code Field(CFA)

IP+2 -> IP advance IP, just like a program counter
              (assuming 2-byte addresses in the thread)
(W) ->  X  fetch memory pointed by W into "X" register
              ...X now holds address of the machine code 
JMP (X)     jump to the address in the X register

Enter 的伪流程
(the address of the Forth word just entered is kept in W. SEE NEXT)

PUSH IP to Reutrun Stack
ADD W, 3     //Parameter Field address -> W
MOV IP, W
NEXT

Exit 的伪流程
POP IP From RS
NEXT

NEXT 的伪流程
(IP) -> W  fetch memory pointed by IP into "W" register
              ...W now holds address of the Code Field(CFA)
IP + 2 -> IP //(assuming 2-byte addresses in the thread)
(W) -> X  // the machine code address of CFA in W
JMP (X)

关于8086的优化：
   AX = W         DI = scratch
   BX = TOS       SI = IP
   CX = scratch   BP = RSP
   DX = scratch   SP = PSP

Enter:
  XCHG SP,BP  //将系统堆栈指向FORTH返回栈, 注意，如果我系统堆栈作为返回栈该指令就不必!
  PUSH SI     //将IP指针压入FORTH返回栈
  XCHG SP, BP //还原, 注意，如果我系统堆栈作为返回栈该指令就不必!
  ADD AX, 3   //Parameter Field address -> W 我觉得应该是加2才对!!! ADD AX, SizeOf(Pointer)
  NEXT

Exit:
  XCHG SP,BP  //将系统堆栈指向FORTH返回栈, 注意，如果我系统堆栈作为返回栈该指令就不必!
  POP SI     //将IP指针压入FORTH返回栈
  XCHG SP, BP //还原, 注意，如果我系统堆栈作为返回栈该指令就不必!
  NEXT

Next:
  ITC:
    LODSW         // (SI) -> AX  means (IP) -> W, IP++
    MOV CX, [AX]  // (W) -> X
    JMP CX        // JMP (X)

  DTC:
    LODSW   // (SI) -> AX  means (IP) -> W, IP++
    JMP AX  // JMP (W)

== 最重要 AND wonderful DOES> 语句 ==
FORTH 单词定义的Body是由两部分构成的：CF(Code Field) and PF(Parameter Field).
 * The Code Field is the "action" taken by this Forth word, and the Parameter Field is the data on which it acts.
 * The Code Field is a subroutine call, and the Parameter Field is parameters that are included "in-line" after the call. (The assembly language programmer's view.)
 * The Code Field is the single "method" for this "class" of words, and the Parameter Field contains the "instance variables" for this particular word. (The object-oriented programmer's view.) 

Code Field过程总有一个参数――PF参数域的起始地址. CF过程用来解释PFA的内容，是单词，常量，变量，词汇表，等等。
FORTH预定了以下几种Code Field过程。

||    Code Field  || Parameter Field || 
||    routine     || contents        ||                
||    ENTER       || a high-level "thread" (series of addresses)  ||
||    DOCON       || a constant value ||
||    DOVAR       || a storage location for data  ||
||    DOVOC       || vocabulary info (varies by implementation) ||

通过DOES>语句，可以实现自己的Code Field过程。这样我可以很容易的通过扩充Code Field过程实现对Delphi过程以及stdcall,fastcall等等过程的调用。


2005-7-1
uForthCore_80386.pas
包含纯汇编过程.如果公用堆栈,那么就不能调整堆栈的大小了.不过无所谓.就当是自举好了.而且这样可以直接使用Delphi的过程。
因为汇编方法将会始终有一个默认参数（这样始终会有入口代码Push EBP），所以放弃，只用函数库的方式来实现核心词汇。


80386 中 EBP中的用法是作为堆栈的框架指针，快速访问堆栈框架中的中某个参数。

Delphi的前面三个参数放在：EAX, EDX, ECX中！接下来的参数按照从左到右的顺序依次压入堆栈.

function Test(const a: integer; const b: string; const c: TRec; const ok: integer; e: integer = 0): integer;
asm {push EBP; MOV EBP, ESP} //delphi 建立的代码
end {POP EBP; RET};//delphi 建立的代码

进入子程序访问堆栈的参数

[EBP+$04]：为CALL 指令压入的当前IP，供返回的时候用。
[EBP]：为在进入的子过程的时候Delphi压入的旧的EBP值！当退出该子过程的时候会自动恢复。注意仅当过程存在参数的时候才会压入旧的EBP

堆栈中的第一个参数(就是参数表中最后一个参数e): [EBP+$08]
堆栈中的第二个参数(就是参数表中倒数第二个参数ok): [EBP+$0C] 
：

注: 
  1. 如果是汇编方法,那么最后一个参数始终是该对象实例的地址(对于类方法而言则是该类的VMT表的地址)。
  2. 对于非汇编过程,该过程无论是否有参数或局部变量,都会有push EBP; MOV EBP, ESP的动作!也就是说如果我使用一般的过程,
     就不能将系统堆栈作为参数栈使用！

词汇的数据结构：
Core 词汇: 虚拟机器码 （或者用汇编）实现的。必须的！
System 词库： 以Core词汇为基础编写的，当然也可以用汇编实现，不过为了可移植性，最好两种实现方式都有。


2005-6-30
我对FORTH的设想：
几种执行机制都可采用，甚至可以包括Delphi Regiser, stdcall, fastcall等等这被称作调用方式。
在连接后（正式发布无调试信息状态）消除名字信息（Published的除外），只包括使用到的过程。
单词按照库名的方式分类组织。对单词的代码场的内容进行扩充。在调试状态下与原始的FORTH构架基本类似（统一用ITC机制执行）！
不过单词的代码场的内容多了调用方式、指向一下个同名的CFA域、以及参数的说明。
先实现类似解释性,然后在转向实现机器码.

  完整的Forth缓存器有下列六个。
  PSP:Parameter Stack(or data stack) Pointer
  TOS:Top Of Stack
  RSP:Return Stack Pointer
  IP :Interpreter Pointer
  UP :User Pointer
  W  :Working register
  另有其它缓存器，moving forth原文内称为X缓存器，亦有人用A(Addressing)缓存器。
  以下描述各缓存器功能。
  PSP,TOS：为数据堆栈相关缓存器，PSP为管理数据堆栈之指针器。
    而TOS为数据堆栈顶端缓存器，主因为数据堆栈动作量大，但只有一个进出口。
    若将顶端数据留在CPU之中，有加速数据处理的作用。
  RSP：为程序呼叫之返回堆栈指针器。
  IP ：执行Forth word用之地址缓存器，用以指向下次执行字为何，其运作和字典相关。
  UP ：使用者管理用缓存器，为多任务管理用缓存器，指向task作用区。记录其Task相关信息。
  W  ：辅助工作用缓存器，辅助字典动作或运算用。

FORTH编译：就是插入代码流的过程。
FORTH的执行：
  初始化
  根据不同的执行机制执行。我选ITC方式。

注意：在我的虚拟机器中TOS实质上就是 ParameterStackSize.

代码的在内存中的组织：

|Address of CFA|Address of CFA|....|NEXT

2005-6-16
！实现最简单的编译型的脚本执行器：
   只有全局变量，执行体（四则运算，赋值，显示）。
   还需要定义支持的数据类型，其余可以参考 2004-12-14。

2005-3-4
！列举需要实现的Forth核心词汇！

2005-1-12
Flowchart:
  Executor.LoadFromStream
    aFormator := GetPEFormat()
    if Assigned(aFormator) then
    else raise ESuperExecutor.Create(RSInvalidPEFormat);
2004-12-23
1、定义PE文件头格式
  定义类的方法属性
  俺的PE文件映像定义
  也许考虑定义模块: 代码，数据集合。
2、定义执行器类方法属性
3、定义编译器类方法属性

19:33 2004-12-14
任务计划：
1、VM运行器: 装入VM码，将VM码变成机器码直接运行。这样翻译一下就解决了代码重定向问题。
定义数据区域（区域划分）：
  代码区 CodeArea : 存放运行代码。
  数据区 DataArea : 存放全局变量。

  返回栈 ReturnStack: 就是用系统栈
  数据栈 DataStack: Intel CPU 上无数据栈,只有模拟？将寄存器串起来作为数据栈？
    EAX  : 1 POP Stack
    EDX  : 2
    ECX  : 3
    //EBX  : 4 注： EBX 是Delphi保留。
    决定,栈顶由最常用的三寄存器: EAX, EDX, ECX构成，然后其他数据放入系统栈！如果其他数据放入数据栈，有可能会破坏返回栈数据，如何保护？！
    算了，还是单独开辟一个数据区作为数据堆栈。备份EBX，然后将EBX作为数据堆栈指针。EBX=0 栈底
    可以同返回栈共用，不过ESP的入栈是减少一直到0，而数据栈EBX指针是增加一直到EBP（其实如果碰到ESP就不能再增加了！同样ESP如果碰到EBX那么也就不能再减少）。

定义实现的基本指令集:
    inAdd, //Add(n1+n2=n) n1 n2 -- n
    inSub, //subtract(n1-n2=n) n1 n2 -- n
    inInc, //add 1(n1+1=n) n1 1 -- n
    inDec, //subtract 1
    inMUL, //multiply (n1*n2=n) n1 n2 -- n
    inDIV, //divide(n1/n2=n) n1 n2 -- n

    {## Logical instuctions }
    inEQU, //equ(Result := n1=n2) n1 n2 -- T/F
    inNEQ, // not equ
    inLES, //less than
    inLEQ, //less than and equ
    inGET, //greater than
    inGEQ, //greater than and equ
    inNOT, //Negate(NOT)
    inAND,
    inOR,
    inXOR,

    {## Memory Operation Instruction }
    inSetValue,
    inGetValue,
    
    {## Proc Operation Instruction }
    inJMP,
    inJZ,
    inJNZ,
    inCall,
    inReturn,
    inNoop,

    {## Stack Operation Instuction }
    inPush,
    inPop,
    inDrop,
    inDUP,
    inSWAP,
    inOVER,
    inROT
