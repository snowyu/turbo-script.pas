$C-  //Generate Delphi test project
$E-  //Generate a component registration unit
$Z+  //Generate console app

COMPILER TurboForthProgram

DELPHI

USES (INTERFACE) uStrUtils, uTurboConsts, uTurboExecutor 

TYPE
  TTurboLabelDeclarationRec = packed record
    Name: string;
    Addr: Integer;
  end;
  

PRIVATE
  FInitProcCFA: Integer;
  FLastWordEntry: PTurboWordEntry;
  FLastWordCfa: Integer;
  FModule: TCustomTurboModule;
  FLabels: array of TTurboLabelDeclarationRec;
  procedure Init;
  procedure Final;
  procedure WriteStr(S : string);
  procedure WriteStrLn(S : string);
  procedure DefineWordBegin(const aName: ShortString);
  procedure DefineWordEnd;
  function AddLabel(const aName: string): Integer;
  //if find retrun label index else -1
  function FindLabel(const aName: string): Integer;
  //if not find then add new label, return label index else raise error.
  function AddLabelEx(const aName: string): Integer;
PROTECTED

PUBLIC
  FileName: string;

CREATE
  FModule := TCustomTurboModule.Create;
DESTROY
  FreeAndNil(FModule);
ERRORS
    cLabelRedeclarationError : Result := rsLabelRedeclarationSyntaxError;
    cWordNameIsNilDeclarationError: Result := rsWordNameIsNilDeclarationError;

PUBLISHED

END_DELPHI

Const
  cMaxMemorySize = 64 * 1024;
  cLabelRedeclarationError = 300;
  cWordNameIsNilDeclarationError = 301;

function T-->Grammar<--.AddLabel(const aName: string): Integer;
begin
    Result := Length(FLabels);
    SetLength(FLabels, Result+1);
    with FLabels[Result] do
    begin
      Name := aName;
      Addr := FModule.UsedMemory;
    end;
end;

function T-->Grammar<--.AddLabelEx(const aName: string): Integer;
begin
  Result := FindLabel(aName);
  if Result = -1 then
  begin
    Result := AddLabel(aName);
  end
  else 
    SynError(cLabelRedeclarationError);

end;

procedure T-->Grammar<--.DefineWordBegin(const aName: ShortString);
var
  p: pointer;
begin
  if aName = '' then 
    SynError(cWordNameIsNilDeclarationError)
  else begin
    Integer(FLastWordEntry) := Integer(FModule.Memory) + FModule.UsedMemory;
    p := FModule.LastWordEntry;
    FModule.AddIntToMem(Integer(p));
    FModule.AllocSpace(SizeOf(TTurboWordOptions));
    FModule.AllocSpace(SizeOf(LongWord)); //the ParamFieldLength
    FModule.AddByteToMem(Length(aName));
    FModule.AddBufferToMem(aName[1], Length(aName));
    FLastWordCfa := FModule.UsedMemory;
  end;
end;

procedure T-->Grammar<--.DefineWordEnd;
begin
  FModule.AddIntToMem(Integer(inExit));
  FLastWordEntry.ParamFieldLength := FModule.UsedMemory - FLastWordCfa + 1;
end;

function T-->Grammar<--.FindLabel(const aName: string): Integer;
var
  i: integer;
begin
  Result := -1;
  for i := 0 to length(FLabels) -1 do
  begin
    if SameText(aName, FLabels[i].Name) then
    begin
      Result := i;
      break;
    end;
  end;
end;


procedure T-->Grammar<--.Init;
begin
  with FModule do
  begin
    ClearMemory;
    MemorySize := cMaxMemorySize;
  end;
  SetLength(FLabels, 0);
  //writeln('SourceFileName=', SourceFileName);
  FileName := ExtractFileBaseName(SourceFileName) + cTurboCompiledProgramFileExt;
  //writeln('FileName=', FileName);
end;

procedure T-->Grammar<--.Final;
var
  vStream: TFileStream;
begin
  //writeln('Final');
  if ErrorList.Count = 0 then
  begin
   //writeln('No error');
    //WriteStrLn('The Result: '+FloatToStr(fResult));
    if FileName <> '' then
    begin
      FModule.IsLoaded := True;
      //writeln('InitProcCFA=', FInitProcCFA+SizeOf(TTurboModuleStreamHeader));
      with PPreservedCodeMemory(FModule.Memory)^ do
      begin
        Integer(InitializeProc) := FInitProcCFA;
      end;
      if LowerCase(ExtractFileExt(FileName)) <> cTurboCompiledProgramFileExt then
        FileName := ChangeFileExt(FileName, cTurboCompiledProgramFileExt);
      vStream := TFileStream.Create(FileName, fmCreate);
      try
        writeln('saving to ' + FileName);
        FModule.SaveToStream(vStream);
      finally
        vStream.Free;
      end;
    end;
  end;
  FModule.ClearMemory;
  SetLength(FLabels, 0);
end;

procedure T-->Grammar<--.WriteStrLn(S : string);
begin
  WriteStr(s+#13#10); 
end;

procedure T-->Grammar<--.WriteStr(S : string);
begin
  ListStream.WriteBuffer(S[1],length(S));
end;



IGNORE CASE

CHARACTERS
 LETTER="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_".
 DIGIT =  "0123456789".
 CTRL=CHR(1)..CHR(31).
 SpecialChar = "*,()%:".
 TAB=CHR(9).
 EOL=CHR(13).
 LF=CHR(10).
 noQuote = ANY - "'" .
 noDblQuote = ANY - '"' .               
 HexDigit = "0123456789ABCDEF" .

TOKENS
 Identifier = LETTER {LETTER|DIGIT}.
 IntegerToken = DIGIT {DIGIT} | DIGIT {DIGIT} CONTEXT ( ".." ).
 HexNumberToken = "$" HexDigit {HexDigit}.
 FloatToken = DIGIT {DIGIT} "." DIGIT {DIGIT} ["E" ["+" |"-"] DIGIT {DIGIT}].
 
NAMES


IGNORE TAB+EOL+LF
PRAGMAS

COMMENTS FROM "(" TO ")"
COMMENTS FROM "//" TO EOL
//COMMENTS FROM "{" TO "}"



PRODUCTIONS

  (* TurboForthProgram = Statement {Statement}  . *)  
  TurboForthProgram 
    =                                                  (. Init ; .)  
    "PROGRAM" Identifier                               (. FModule.Name := LexString; .)
    [DefineWord]
    "BEGIN"                                            (. FInitProcCFA := FModule.UsedMemory; writeln('FInitProcCFA=',FInitProcCFA); .)
    StatementBlock
    "END."                                             (. FModule.AddIntToMem(Integer(inHalt)); .)
    (. Final ; .) .

  DefineWord
    =
    ":" Identifier                                     (. DefineWordBegin(LexString); .)
    StatementBlock
    ";"                                                (. DefineWordEnd; .)
  .

  StatementBlock 
    = 
    Statement {Statement}
    .

  Statement 
    = 
    [LabelDeclaration]
     PushIntStatement
    | AddIntStatement
    | SubIntStatement
    | WordStatement
  .

  LabelDeclaration =
    "Label" Identifier(. AddLabelEx(LexString); .)  .

  PushIntStatement = IntegerToken (. FModule.AddIntToMem(Integer(inPushInt)); FModule.AddIntToMem(StrToInt(LexString));.) .
  AddIntStatement  = "+" (. FModule.AddIntToMem(Integer(inAddInt)); .) .
  SubIntStatement  = "-" (. FModule.AddIntToMem(Integer(inSubInt)); .) .

  WordStatement = Identifier (..).
END TurboForthProgram.
