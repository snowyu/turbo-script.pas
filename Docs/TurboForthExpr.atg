$C-  //Generate Delphi test project
$E-  //Generate a component registration unit
$Z+  //Generate console app

//{$IFDEF MSWINDOWS}Windows,{$ENDIF}
COMPILER TurboForthCompiler

DELPHI

USES (INTERFACE) uStrUtils, uTurboConsts, uTurboExecutor, uTurboAccessor, uTurboModuleFileAccessor

TYPE
  TTurboLabelDeclarationRec = packed record
    Name: String;
    WordName: String;
    Addr: Integer;
  end;
  
  TTurboValueRec = packed record
    case Integer of
      0: (
        case TTurboSimpleTypeKind of
          //ttkUByte: (VByte: Byte);
          ttkSByte: (VShortInt: ShortInt);
          //ttkUWord: (VWord: Word);
          ttkSWord: (VSmallInt: SmallInt);
          ttkULong: (VLong: LongWord);
          ttkSLong: (VInteger: Integer);
          ttkSet:        (VSet: Byte);
          ttkLString:    (VAnsiString: Pointer);
          ttkChar:       (VChar: Char);
          ttkWString:    (VWideString: Pointer);
          ttkString:     (VString: PShortString);
          ttkPointer:    (VPointer: Pointer);
          //ttkObject:     (VMeObject: Pointer);
          ttkClass:      (VObject: TObject);
          ttkWChar:      (VWideChar: WideChar);
          ttkVariant:    (VVariant: TVarData);
          ttkInterface:  (VInterface: Pointer);
          ttkInt64:      (VInt64: Int64);
          ttkDynArray:   (VDynBound: Integer; VDynArray: Pointer);
          ttkMethod:     (VCode: Pointer; VData: Pointer);
          //ttkProcedure:  (VCode: Pointer);
             ttkSingle: (VSingle: Single);
             ttkDouble: (VDouble: Double);
             ttkExtended: (VExtended: Extended);
             ttkComp: (VComp: Comp);
             ttkCurr: (VCurr: Currency);
      );
      1: (VBytes: array [0..15] of byte);
      2: (VWords: array [0..7] of word);
      3: (VDWords: array [0..3] of LongWord);
      4: (VInt64s: array [0..1] of Int64);
      5: (VByte: byte);
      6: (VWord: word);
      7: (VLongword: Longword);
  end;

  TTurboSimpleConst = object
  public
    Name: ShortString;
    TypeKind: TTurboSimpleTypeKind;
    Value: TTurboValueRec;
    ValueStr: ShortString;
    Size: Integer;
  public
    procedure SetTypeKind(aValue: TTurboSimpleTypeKind);
    function AssignValueTo(const Source: Pointer): Boolean;
    //根据aValue 如果aTypeKind is ttkUnknown 那么会自动判断其类型
    function AssignValue(const aValue: string; const aTypeKind: TTurboSimpleTypeKind = ttkUnknown): Boolean;
    procedure SaveString(const aModule: TCustomTurboModule);
  end;

  TTurboSimpleVar = object(TTurboSimpleConst)
  public
    Visibility: TTurboVisibility;
    Addr: Integer;
  end;

  TTurboSimpleWord = object
    Options: TTurboWordOptions;
    //the Param Field Length
    //该函数主体的长度 
    ParamFieldLength: LongWord;
    CFA: tsInt;//the offset address of the memory.
    Name: ShortString; 
    ModuleName: ShortString;  //for external word
    ModuleType: TTurboModuleType;  //for external word
    ModuleIndex: Integer; //for external word
    Module: TCustomTurboModule; //for external forth word
    ExternalOptions: TTurboExteralWordCFA; //Exteral Word Options
  end;

  TTurboSimpleModule = object
    Entry: PTurboModuleEntry; //offset address
    ModuleType: TTurboModuleType;
    Name: ShortString;
    Module: TCustomTurboModule;
  end;

PRIVATE
  FTurboGlobalOptions: TTurboGlobalOptions;
  FInitProcCFA: Integer;
  //正在定义的Word,如果存在 
  FDefinedWordEntry: PTurboWordEntry;
  FLastWordCfa: Integer;
  FModule: TCustomTurboModule;

  FLabels: array of TTurboLabelDeclarationRec;
  FConsts: array of TTurboSimpleConst;
  FVars: array of TTurboSimpleVar;
  FWords: array of TTurboSimpleWord;
  FUsedModules: array of TTurboSimpleModule;
  procedure Init;
  procedure Final;
  procedure WriteStr(S : String);
  procedure WriteStrLn(S : String);
  function  DefineWordBegin(var aWord: TTurboSimpleWord): Boolean;
  procedure DefineWordEnd();
  procedure PushString();
  // Add Identifier CFA address into the memory. 
  function AddIdentifierCFA(const aName: String): Boolean;
  // AddWordCFA address into the memory. 
  function AddWordCFA(aName: String): Boolean;
  // Add Const address into the memory. 
  function AddConstCFA(const aName: String): Boolean;
  // Add Var address into the memory. 
  function AddVarCFA(const aName: String): Boolean;

  function DefineLabel(const aName: string; const aWordName: string =''): Integer;
  //if find retrun label index else -1
  function FindLabel(const aName: string; const aWordName: string =''): Integer;
  //if not find then add new label, return label index else raise error.
  function DefineLabelEx(const aName: string; const aWordName: string =''): Integer;
  function  DefineConst(const aValue: TTurboSimpleConst): Integer;
  //if not find then add new , return index else raise error.
  function  DefineConstEx(const aValue: TTurboSimpleConst): Integer;
  function FindConst(const aName: String): Integer;
  function GetConstValue(const aTypeKind: TTurboSimpleTypeKind; const aName: string): TTurboValueRec;

  //if not find then add new , return index else raise error.
  function DefineVar(const aValue: TTurboSimpleVar): Integer;
  function FindVar(const aName: String): Integer;

  //try find module if not then Generate.
  procedure GenerateModuleEntryForWord(var aWord: TTurboSimpleWord);
  function FindModule(const aName: String; aModuleType: TTurboModuleType): Integer;
  function  AddUsedModule(const aName: String; aModuleType: TTurboModuleType): Integer;
  function FindWord(const aName: String): Integer;
  
  //make sure the indentifier is unique else it will raise the error..
  function IsUniqueIdentifier(const aName: String): Boolean;
PROTECTED

PUBLIC
  FileName: string;

CREATE
  FModule := TCustomTurboModule.Create;
  FModule.GlobalOptions := @FTurboGlobalOptions;
DESTROY
  FreeAndNil(FModule);
ERRORS
    cLabelRedeclarationError : Result := rsLabelRedeclarationSyntaxError;
    cWordNameIsNilDeclarationError: Result := rsWordNameIsNilDeclarationError;
    cUnknownWordError: Result := rsUnknownWordError;
    cConstRedeclarationError : Result := rsConstRedeclarationSyntaxError;
    cVarRedeclarationError : Result := rsVarRedeclarationSyntaxError;
    cRedeclarationError : Result := rsRedeclarationSyntaxError;
    cDLLModuleMissError: Result := rsDLLModuleMissSyntaxError;
    cFileNotFoundError:  Result := rsFileNotFoundError;
    cWordNotFoundError:  Result := rsWordNotFoundError;

PUBLISHED

END_DELPHI

Const
  cMaxMemorySize = 64 * 1024;
  cLabelRedeclarationError = 300;
  cWordNameIsNilDeclarationError = 301;
  cUnknownWordError = 302;
  cVarRedeclarationError = 303;
  cConstRedeclarationError = 304;
  cRedeclarationError = 305;
  cDLLModuleMissError = 306;
  cFileNotFoundError  = 307;
  cWordNotFoundError  = 308;

Const
  cReqAlignMemTypes = [ttkUWord, ttkSWord, ttkULong, ttkSLong, ttkPointer, ttkString, ttkLString, ttkInt64, ttkQWord];

function GetSimpleTurboTypeSize(const aTypeKind: TTurboSimpleTypeKind): Integer;
begin
  case aTypeKind of
    ttkSByte, ttkUByte, ttkChar, ttkSet: Result := SizeOf(Byte);
    ttkSWord, ttkUWord: Result := SizeOf(Word);
    ttkSingle: Result := SizeOf(Single);
    ttkDouble: Result := SizeOf(Double);
    ttkComp:  Result := SizeOf(Comp);
    ttkExtended: Result := SizeOf(Extended);
    ttkCurr: Result := SizeOf(Currency);
    ttkEnumeration: Result := -1; //can not determine. <=256 elemnts is byte, <=$FFFF elemnts is word.
    ttkQWord, ttkInt64: Result := SizeOf(Int64);
    //ttkShortString, ttkAnsiString, ttkPointer: Result := SizeOf(Pointer); //Pointer = Integer
  else
    Result := SizeOf(Integer);
  end;
end;

function TTurboSimpleConst.AssignValue(const aValue: string; const aTypeKind: TTurboSimpleTypeKind): Boolean;
begin
  Result := True;
  //writeln('AssignValue:', Integer(aTypeKind));
  if aValue[1] = '''' then
  begin
    ValueStr := AnsiDequotedStr(aValue, '''');
    if aTypeKind = ttkUnknown then
    begin
       TypeKind := ttkString;
      {if Length(ValueStr) < 256 then
      begin
        TypeKind := ttkString;
      end
      else begin
        TypeKind := ttkLString;
      end;}
    end 
    else if aTypeKind = ttkChar then
      Value.VByte := Ord(ValueStr[1]);
  end
  else
    try
      ValueStr := aValue;
      Value.VInt64 := StrToInt64(aValue);
      //writeln(Name,'=',Value.VByte);
      if aTypeKind = ttkUnknown then
      begin
        if (Value.VInt64 >= Low(ShortInt)) and (Value.VInt64<=High(ShortInt)) then
          TypeKind := ttkSByte
        else if (Value.VInt64 >= Low(Byte)) and (Value.VInt64<=High(Byte)) then
          TypeKind := ttkUByte
        else if (Value.VInt64 >= Low(SmallInt)) and (Value.VInt64<=High(SmallInt)) then
          TypeKind := ttkSWord
        else if (Value.VInt64 >= Low(Word)) and (Value.VInt64<=High(Word)) then
          TypeKind := ttkUWord
        else if (Value.VInt64 >= Low(LongInt)) and (Value.VInt64<=High(LongInt)) then
          TypeKind := ttkSLong
        else if (Value.VInt64 >= Low(LongWord)) and (Value.VInt64<=High(LongWord)) then
          TypeKind := ttkULong
        else //if (Value.VInt64 >= Low(Int64)) and (Value.VInt64<=High(Int64)) then
          TypeKind := ttkInt64;
      end;
    except
      TypeKind := ttkUnknown;
      Result := False;
    end;
  if aTypeKind <> ttkUnknown then begin
    TypeKind := aTypeKind;
    Result := True;
  end;
  if Result then
    Size := GetSimpleTurboTypeSize(TypeKind);
end;

function TTurboSimpleConst.AssignValueTo(const Source: Pointer): Boolean;
begin
  Result := True;
  //writeln('AssignValueTo:', ValueStr);
  move(Value, Source^, Size);
  //writeln(InttoHex(Value.VInteger, 4));
  {case TypeKind of
    ttkSLong, ttkInterface, ttkProcedure, ttkPointer, ttkString, ttkLString: PInteger(Source)^ := Value.VInteger;
    ttkSByte: PShortInt(Source)^  := Value.VShortInt;
    ttkUByte, ttkChar, ttkSet: PByte(Source)^ := Value.VByte;
    ttkSWord:PSmallInt(Source)^ := Value.VSmallInt;
    ttkUWord: PWord(Source)^ := Value.VWord;
    ttkULong: PLongWord(Source)^ := Value.VLongword;
    ttkQWord, ttkInt64: PInt64(Source)^:= Value.VInt64;
    else 
      Result := False;
  end;//}
  //writeln('TypeKind=', Integer(TypeKind));
  //writeln('PSource=', PInteger(Source)^);
end;

procedure TTurboSimpleConst.SaveString(const aModule: TCustomTurboModule);
begin
    Case TypeKind of
      ttkString: begin
        //aModule.AlignMem;
        Value.VInteger := aModule.UsedMemory;
        aModule.AddByteToMem(Length(ValueStr));
        aModule.AddBufferToMem(ValueStr[1], Length(ValueStr));
      end;
      ttkLString: begin
        //aModule.AlignMem;
        aModule.AddIntToMem(-1);
        aModule.AddIntToMem(Length(ValueStr));
        Value.VInteger := aModule.UsedMemory;
        aModule.AddBufferToMem(ValueStr[1], Length(ValueStr));
        aModule.AddByteToMem(0);
      end;
    end;//case
end;

procedure TTurboSimpleConst.SetTypeKind(aValue: TTurboSimpleTypeKind);
begin
  TypeKind := aValue;
  Size := GetSimpleTurboTypeSize(TypeKind);
end;

{ T-->Grammar<-- }

function T-->Grammar<--.AddIdentifierCFA(const aName: string): Boolean;
begin
  Result := AddConstCFA(aName);
  if Result then exit;

  Result := AddVarCFA(aName);
  if Result then exit;

  Result := AddWordCFA(aName);
  if Result then exit;

  //writeln('cUnknownWordError:',aName);
  SynError(cUnknownWordError, aName);
end;

function T-->Grammar<--.AddConstCFA(const aName: String): Boolean;
var
  p: Pointer;
  i : Integer;
begin
  i := FindConst(aName);
  Result := i >= 0;
  if Result  then
    with FConsts[i] do
    begin
      if Size <= SizeOf(Integer) then
      begin
        //FModule.AddOpToMem(inPushInt);
        //Size := SizeOf(Integer);
        Case Size of
          SizeOf(Byte): FModule.AddOpToMem(inPushByte);
          SizeOf(Word): FModule.AddOpToMem(inPushWord);
          //SizeOf(tsInt): FModule.AddOpToMem(inPushInt);
          //SizeOf(Int64): FModule.AddOpToMem(inPushInt64);
          else 
          begin
            FModule.AddOpToMem(inPushInt);
            Size := SizeOf(Integer);
          end;
        end;//case
      end
      else
        FModule.AddOpToMem(inPushInt64);
      Integer(p) := Integer(FModule.Memory) + FModule.UsedMemory;
      FModule.AllocSpace(Size);
      AssignValueTo(p);
    end
end;

function T-->Grammar<--.AddVarCFA(const aName: String): Boolean;
var
  i: Integer;
begin
  i := FindVar(aName);
  Result := i >= 0;
  if Result then
    with FVars[i] do
    begin
      FModule.AddOpToMem(inPushInt);
      FModule.AddIntToMem(Addr);
    end
end;

function T-->Grammar<--.AddWordCFA(aName: string): Boolean;
var
  i: Integer;
begin
  Result := False;
  i := FindWord(aName);
  if i >= 0 then with FWords[i] do
  begin
    case Options.CodeFieldStyle of
      cfsFunction:
      begin
        if Options.Visibility < fvProtected then
        begin
          FModule.AddOpToMem(inEnter);
          FModule.AddIntToMem(CFA);
        end
        else
        begin
          FModule.AddOpToMem(inEnterFar);
          FModule.AddIntToMem(0);
          FModule.AddIntToMem(CFA);
        end;
        Result := True;
      end;
      cfsExternalFunction:
      begin
        case Options.CallStyle of
          csForth:
          begin
            if Assigned(Module) then
            begin
              if ExternalOptions.Name <> '' then aName := ExternalOptions.Name;
              i := Module.GetWordCFA(aName);
              if i <> 0 then
              begin
                FModule.AddOpToMem(inCallFar);
                //writeln(aName, '.ModEntry:',Integer(FUsedModules[ModuleIndex].Entry));
                FModule.AddIntToMem(Integer(FUsedModules[ModuleIndex].Entry));
                FModule.AddIntToMem(i);
                //writeln(aName, '.CFA:',i);
                Result := True;
              end
              else
                SynError(cWordNotFoundError, '"'+ aName + '" CFA not in ' + FUsedModules[ModuleIndex].Name);
            end
            else
              SynError(cWordNotFoundError, '"'+ aName + '" not in ' + FUsedModules[ModuleIndex].Name);
          end;
        end; //case
      end;
    end;//case
  end;
end;

function T-->Grammar<--.IsUniqueIdentifier(const aName: String): Boolean;
begin
  //writeln('IsUniqueIdentifier:', aName);
  Result := FindConst(aName) < 0;
  //writeln('C:',Result);
  if Result then
    Result := FindVar(aName)< 0;
  //writeln('V:',Result);
  if Result then
    Result := FindWord(aName) < 0;
  //writeln('W:',Result);
  if not Result then
  begin
    writeln('RedeclarationError:',aName);
    SynError(cRedeclarationError);
  end;
end;

function T-->Grammar<--.GetConstValue(const aTypeKind: TTurboSimpleTypeKind; const aName: String): TTurboValueRec;
var
  i: Integer;
begin
  for i := 0 to Length(FConsts) do 
    with FConsts[i] do
    if (aName = Name) and (aTypeKind = TypeKind) then
    begin
      Result := Value;
      exit;
    end;
  SynError(cUnknownWordError, aName);
end;

function T-->Grammar<--.DefineLabel(const aName: string; const aWordName: string): Integer;
begin
    Result := Length(FLabels);
    SetLength(FLabels, Result+1);
    with FLabels[Result] do
    begin
      Name := aName;
      WordName := aWordName;
      Addr := FModule.UsedMemory;
    end;
end;

function T-->Grammar<--.DefineLabelEx(const aName: string; const aWordName: string): Integer;
begin
  Result := FindLabel(aName, aWordName);
  if Result = -1 then
  begin
    Result := DefineLabel(aName, aWordName);
  end
  else 
    SynError(cLabelRedeclarationError);

end;

function T-->Grammar<--.DefineConstEx(const aValue: TTurboSimpleConst): Integer;
begin
  //WriteLn('ConstDefine:', aValue.Name);
  Result := FindConst(aValue.Name);
  if Result = -1 then
  begin
    Result := DefineConst(aValue);
  end
  else 
    SynError(cConstRedeclarationError);
end;

function T-->Grammar<--.DefineConst(const aValue: TTurboSimpleConst): Integer;
begin
  Result := Length(FConsts);
  SetLength(FConsts, Result+1);
  FConsts[Result] := aValue;
  with FConsts[Result] do
  begin
    //Name := aValue.Name;
    SaveString(FModule); //if this is string 
  end;
end;

function T-->Grammar<--.FindConst(const aName: String): Integer;
begin
  for Result := 0 to Length(FConsts)-1 do
  begin
    //WriteLn(aName,'=', FConsts[Result].Name);
    if aName = FConsts[Result].Name then exit;
  end;
  Result := -1;
end;

function T-->Grammar<--.FindVar(const aName: String): Integer;
begin
  for Result := 0 to Length(FVars)-1 do
  begin
    //if aName = 'Add' then 
    //WriteLn(Result, ':FV:',FVars[Result].Name);
    if aName = FVars[Result].Name then exit;
  end;
  Result := -1;
end;

function T-->Grammar<--.DefineVar(const aValue: TTurboSimpleVar): Integer;
var
  vVaraibleEntry: PTurboVariableEntry;
  vValue: Pointer;
  //vTypeSize: Integer;
begin
  //在前面已经判断了是不是名称重复：
  Result := Length(FVars);
  SetLength(FVars, Result+1);
  FVars[Result] := aValue;
  with FVars[Result] do
  begin
    //WriteLn(Result, ':DefineVar:',Name);
    //Name := aValue.Name; //保证让其ref增加
    //FModule.AlignMem;
    //vTypeSize := GetSimpleTurboTypeSize(aValue.TypeKind);
    //Size := vTypeSize;
    //WriteLn(Name,'.Visibility=', Integer(Visibility));
    //WriteLn(Name,'.Size=', Size);

    if Visibility >= fvProtected then
    begin
      Integer(vVaraibleEntry) := Integer(FModule.Memory) + FModule.UsedMemory;
      FModule.AddIntToMem(Integer(FModule.LastVariableEntry));
      FModule.AddIntToMem(Size);
      FModule.AddIntToMem(0); //preserved.for addr.
      FModule.AddIntToMem(0); //preserved.for TypeInfo.
      if Visibility >= fvPublished then
      begin
        //fill the variable name 
        FModule.AddByteToMem(Length(Name));
        FModule.AddBufferToMem(Name[1], Length(Name));
      end
      else 
      begin
        //no name
        FModule.AddByteToMem(0);
      end;
    end;
  
    if (TypeKind in cReqAlignMemTypes) then FModule.AlignMem;
    Addr := FModule.UsedMemory;
    if Visibility >= fvProtected then
    begin
      Integer(vVaraibleEntry.Addr) := Addr;
      FModule.LastVariableEntry := Pointer(Integer(vVaraibleEntry) - Integer(FModule.Memory));
    end;
    Integer(vValue) := Integer(FModule.Memory)  + Addr;
    FModule.AllocSpace(Size);
    if ValueStr <> '' then
    begin
      SaveString(FModule); //if this is string 
      AssignValueTo(vValue);
    end;
  end;
  //SetLength(FVars, Length(FVars) + 1);
  //FindVar('');
end;

function T-->Grammar<--.DefineWordBegin(var aWord: TTurboSimpleWord): Boolean;
var
  i: Integer;
begin
  //WriteLn('DefineWordBegin:',aName);
  //FindVar('');
  Result := IsUniqueIdentifier(aWord.Name);
  if Result then
  begin
    Integer(FDefinedWordEntry) := Integer(FModule.Memory) + FModule.UsedMemory;
    //p := FModule.LastWordEntry;
    FModule.AddIntToMem(tsInt(FModule.LastWordEntry));
    FModule.AllocSpace(SizeOf(TTurboWordOptions));
    //FModule.AlignMem;
    FModule.AllocSpace(SizeOf(LongWord)); //the ParamFieldLength
    FModule.AllocSpace(SizeOf(Integer)); //the CFA
    if aWord.Options.Visibility >= fvProtected then
    begin
      FModule.AddByteToMem(Length(aWord.Name));
      FModule.AddBufferToMem(aWord.Name[1], Length(aWord.Name));
    end
    else
      FModule.AddByteToMem(0);
    FLastWordCfa := FModule.UsedMemory;
    FDefinedWordEntry.CFA := FLastWordCfa;
    aWord.CFA := FLastWordCfa;
    FDefinedWordEntry.Options := aWord.Options;

    i := Length(FWords);
    SetLength(FWords, i+1);
    FWords[i] := aWord;
  end
  //else FLastWordCfa := 0;
end;

procedure T-->Grammar<--.DefineWordEnd();
var
  vPrior: PTurboWordEntry;
begin
  if FDefinedWordEntry.Options.Visibility >= fvProtected then
    FModule.AddOpToMem(inExitFar)
  else
    FModule.AddOpToMem(inExit);
  FDefinedWordEntry.ParamFieldLength := FModule.UsedMemory - FLastWordCfa + 1;
  FWords[Length(FWords)-1].ParamFieldLength := FDefinedWordEntry.ParamFieldLength;

  vPrior := FModule.LastWordEntry;
  FModule.LastWordEntry := Pointer(Integer(FDefinedWordEntry) - Integer(FModule.Memory));
  FDefinedWordEntry.Prior := vPrior;
end;

function T-->Grammar<--.FindWord(const aName: String): Integer;
begin
  for Result := 0 to Length(FWords)-1 do
  begin
    if AnsiSameText(aName, FWords[Result].Name) then exit;
  end;
  Result := -1;
end;

procedure T-->Grammar<--.GenerateModuleEntryForWord(var aWord: TTurboSimpleWord);
var
  i: Integer;
begin
  if aWord.ModuleName <> '' then
  begin
    i := FindModule(aWord.ModuleName, aWord.ModuleType);
    //WriteLn('GenerateModuleEntryForWord:', aWord.ModuleName);
    if i < 0 then i := AddUsedModule(aWord.ModuleName, aWord.ModuleType);
    if i >= 0 then
    begin
      aWord.ExternalOptions.ModuleEntry := FUsedModules[i].Entry;
      aWord.ModuleIndex := i;
      aWord.Module := FUsedModules[i].Module;
    end;
  end
  else with aWord.ExternalOptions do 
  begin
    ModuleEntry := FModule.LastModuleEntry;
    if ModuleEntry = nil then SynError(cDLLModuleMissError, aWord.Name);
  end;
end;

function  T-->Grammar<--.AddUsedModule(const aName: String; aModuleType: TTurboModuleType): Integer;
var
  vModule: TCustomTurboModule;
begin
  //WriteLn('AddUsedModule:', aName);
  Result := -1;
  if aModuleType = mtLib then
  begin
    vModule := FModule.RequireModule(aName);
    if vModule = nil then
    begin
      SynError(cFileNotFoundError, aName);
      exit;
    end;
  end;
  Result := Length(FUsedModules);
  SetLength(FUsedModules, Result+1);
  with FUsedModules[Result] do
  begin
    Name := aName;
    ModuleType := aModuleType;
    if aModuleType = mtLib then Module := vModule else Module := nil;
    with FModule do 
    begin
      Integer(Entry) := UsedMemory; //the offset address.
      AddIntToMem(tsInt(LastModuleEntry));
      AddByteToMem(Byte(aModuleType));
      AddIntToMem(0); //preserved for Module: Pointer
      AllocSpace(SizeOf(LongWord)); //Revision
      AllocSpace(SizeOf(TTimeStamp)); //BuildDate
      AddByteToMem(Length(aName));
      if Length(aName) > 0 then
        AddBufferToMem(aName[1], Length(aName));
      LastModuleEntry := Entry;
    end;
  end;
end;

function T-->Grammar<--.FindLabel(const aName: string; const aWordName: string): Integer;
begin
  for Result := 0 to length(FLabels) -1 do
  begin
    if (aName = FLabels[Result].Name) and (aWordName = FLabels[Result].WordName) then
    begin
      exit;
    end;
  end;
  Result := -1;
end;

function T-->Grammar<--.FindModule(const aName: String; aModuleType: TTurboModuleType): Integer;
begin
  for Result := 0 to Length(FUsedModules)-1 do
  begin
    if AnsiSameText(aName, FUsedModules[Result].Name) and (aModuleType = FUsedModules[Result].ModuleType) then exit;
  end;
  Result := -1;
end;

procedure T-->Grammar<--.Init;
begin
  with FModule do
  begin
    ClearMemory;
    MemorySize := cMaxMemorySize;
    Status := [psCompiling];
  end;
  SetLength(FLabels, 0);
  SetLength(FConsts, 0);
  SetLength(FVars, 0);
  SetLength(FWords, 0);
  SetLength(FUsedModules, 0);
  //writeln('SourceFileName=', SourceFileName);
  FileName := ExtractFileBaseName(SourceFileName) + cTurboCompiledProgramFileExt;
  //writeln('FileName=', FileName);
end;

procedure T-->Grammar<--.Final;
var
  vStream: TFileStream;
begin
  //writeln('Final');
  if ErrorList.Count = 0 then
  begin
   //writeln('No error');
    //WriteStrLn('The Result: '+FloatToStr(fResult));
    if FileName <> '' then
    begin
      FModule.IsLoaded := True;
      //writeln('InitProcCFA=', FInitProcCFA+SizeOf(TTurboModuleStreamHeader));
      with PPreservedCodeMemory(FModule.Memory)^ do
      begin
        Integer(InitializeProc) := FInitProcCFA;
      end;
      if LowerCase(ExtractFileExt(FileName)) <> cTurboCompiledProgramFileExt then
        FileName := ChangeFileExt(FileName, cTurboCompiledProgramFileExt);
      vStream := TFileStream.Create(FileName, fmCreate);
      try
        writeln('saving to ' + FileName);
        FModule.SaveToStream(vStream);
      finally
        vStream.Free;
      end;
    end;
  end;
  FModule.ClearMemory;
  SetLength(FLabels, 0);
  SetLength(FConsts, 0);
  SetLength(FVars, 0);
  SetLength(FWords, 0);
  SetLength(FUsedModules, 0);
end;

procedure T-->Grammar<--.PushString();
var
  s: string;
  i: Integer;
begin
  s := AnsiDequotedStr(LexString, '''');
  for i := length(s) downto 1 do
  begin
    FModule.AddOpToMem(inPushInt);
    FModule.AddIntToMem(Ord(s[i])); 
  end;
end;

procedure T-->Grammar<--.WriteStrLn(S : string);
begin
  WriteStr(s+#13#10); 
end;

procedure T-->Grammar<--.WriteStr(S : string);
begin
  ListStream.WriteBuffer(S[1],length(S));
end;



IGNORE CASE

CHARACTERS
 LETTER="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_".
 DIGIT =  "0123456789".
 CTRL=CHR(1)..CHR(31).
 SpecialChar = "*,()%:".
 TAB=CHR(9).
 EOL=CHR(13).
 LF=CHR(10).
 noQuote = ANY - "'" .
 noDblQuote = ANY - '"' .               
 HexDigit = "0123456789ABCDEF" .

TOKENS
 Identifier = LETTER {LETTER|DIGIT}.
 IntegerToken = DIGIT {DIGIT} | DIGIT {DIGIT} CONTEXT ( ".." ).
 HexNumberToken = "$" HexDigit {HexDigit}.
 FloatToken = DIGIT {DIGIT} "." DIGIT {DIGIT} ["E" ["+" |"-"] DIGIT {DIGIT}].
 StringToken   = "'" { noQuote | "'" "'" } "'" .

NAMES


IGNORE TAB+EOL+LF
PRAGMAS

COMMENTS FROM "(" TO ")"
COMMENTS FROM "//" TO EOL
//COMMENTS FROM "{" TO "}"



PRODUCTIONS

  (* TurboForthCompiler = Statement {Statement}  . *)  
  TurboForthCompiler 
    =                                                  (. Init ; .)  
    ( "PROGRAM"                                        (. FModule.ModuleType := mtProgram; .)
      |"UNIT"                                          (. FModule.ModuleType := mtLib; .) 
    )
    Identifier                                         (. FModule.Name := LexString; .)
    [DeclarationBlock]  
    "BEGIN"                                            (. FInitProcCFA := FModule.UsedMemory;  .)
    ASMStatementBlock
    "END."                                             (. FModule.AddOpToMem(inHalt); .)
    (. Final ; .) .

   DeclarationBlock 
    = 
    Declaration {Declaration}.

  Declaration = DefineConstPart| DefineVarPart | DefineWord .

  DefineConstPart
    =
    "CONST" DefineConstant {DefineConstant} 
  .

  DefineConstant
    (.Var vValue: TTurboSimpleConst; .) 
    = 
    Identifier (. vValue.Name := LexString; vValue.TypeKind := ttkUnknown; .) 
    [":" TypeKind<vValue.TypeKind> ]
    "=" Value<vValue> 
    ";" (. if IsUniqueIdentifier(vValue.Name) then DefineConstEx(vValue); .) .

  DefineVarPart
    = 
    "VAR" DefineVariable {DefineVariable}
  .

  DefineVariable
    (.Var vValue: TTurboSimpleVar; .)
    =  (. vValue.Visibility := fvPrivate;vValue.ValueStr := ''; .)
    [WordVsibility<vValue.Visibility>] Identifier (. vValue.Name := LexString; .)
    ":" TypeKind<vValue.TypeKind> (.vValue.SetTypeKind(vValue.TypeKind); .)
    ["=" Value<vValue>]
    ";" (. if IsUniqueIdentifier(vValue.Name) then DefineVar(vValue); .)
  .

  TypeKind<var aType: TTurboSimpleTypeKind> 
    =
    IntegerType <aType>
    |StringType <aType>
  .

  IntegerType<var aSubType: TTurboSimpleTypeKind>
    =
    "BYTE"                                            (. aSubType := ttkUByte; .)
    |"WORD"                                           (. aSubType := ttkUWord; .)
    |"DWORD"                                          (. aSubType := ttkULong; .)
    |"INTEGER"                                        (. aSubType := ttkSLong; .)
    |"QWORD"                                          (. aSubType := ttkQWord; .)
    |"INT64"                                          (. aSubType := ttkInt64; .)
  .
  StringType<var aSubType: TTurboSimpleTypeKind>
    =
    "STRING"                                          (. aSubType := ttkLString; .)
    |"SHORTSTRING"                                    (. aSubType := ttkString; .)
  .

  Value< var aValue: TTurboSimpleConst >
    = 
    (StringToken|IntegerToken|HexNumberToken)           (. aValue.AssignValue(LexString, aValue.TypeKind); .)
//    |Identifier                                       (. aValue.Value := GetConstValue(aValue.TypeKind, LexString); .)
  .

  DefineWord (. Var vSucc: Boolean; vWord: TTurboSimpleWord; .)
    = 
                                                                 (. vWord.Options.Visibility := fvPrivate; 
                                                                    vWord.Options.CallStyle := csForth;
                                                                    vWord.Options.CodeFieldStyle := cfsFunction;
                                                                 .)
    ":" [WordVsibility<vWord.Options.Visibility>] Identifier     (. vWord.Name := LexString; .)
    
    [
    ExternalWordOption<vWord>                                    (. GenerateModuleEntryForWord(vWord); .)
    ]
                                                                 (.vSucc := DefineWordBegin(vWord);  .)
    [ASMStatementBlock]
    ";"                                                          (. if vSucc and (vWord.Options.CodeFieldStyle = cfsFunction) then DefineWordEnd(); .)
  .
  ExternalWordOption< var aWord: TTurboSimpleWord >
    = 
    //the default is the lastModuleEntry if no the module name.
                                                            (. aWord.ModuleName := ''; 
                                                               aWord.ExternalOptions.Name := '';
                                                            .)
    "EXTERNAL"                                              (. aWord.Options.CodeFieldStyle := cfsExternalFunction; .)
    [
      StringToken                                           (.aWord.ModuleName := AnsiDequotedStr(LexString, '''');
                                                              aWord.ModuleType := mtLib; .)  //the default module Type is mtLib
      [ModuleType<aWord.ModuleType>]
    ]
    [
      "STDCALL"                (. aWord.Options.CallStyle := csStdCall; .)
       |"REGISTER"             (. aWord.Options.CallStyle := csRegister; .)
       |"PASCAL"               (. aWord.Options.CallStyle := csPascal; .)
       |"FORTH"                (. aWord.Options.CallStyle := csForth; .)
       ExternalWordOptionPart<aWord.ExternalOptions>
    ]
  .
  ModuleType< var aType: TTurboModuleType >
    =
    "LIB"                                                  (. aType := mtLib;  .)
    |"DLL"                                                 (. aType := mtDLL;  .)
    |"HOST"                                                (. aType := mtHost; .)
  .
  ExternalWordOptionPart < var aOptions: TTurboExteralWordCFA >
    =
   ["Name" StringToken (. aOptions.Name := AnsiDequotedStr(LexString, ''''); .) ]
   ["Index" IntegerToken (. aOptions.Index := StrToInt(LexString); .)]
  .
  WordVsibility< var aVisibility: TTurboVisibility > 
    = 
    "HIDDEN"                                           (. aVisibility := fvHide; .)
    |"PRIVATE"                                         (. aVisibility := fvPrivate; .)
    |"PROTECTED"                                       (. aVisibility := fvProtected; .)
    |"PUBLIC"                                          (. aVisibility := fvPublic; .)
    |"PUBLISHED"                                       (. aVisibility := fvPublished; .)
  .

  ASMStatementBlock 
    = 
    ASMStatement {ASMStatement}
    .

  ASMStatement 
    = 
    [LabelDeclaration]
     PushIntAsmStatement
    | PushStringAsmStatement 
    | AddIntAsmStatement
    | "i8+" (.FModule.AddOpToMem(inAddInt64); .)
    | SubIntAsmStatement
    | "i8-" (.FModule.AddOpToMem(inSubInt64); .)
    | MulIntAsmStatement
    | "!" (. FModule.AddOpToMem(inStoreInt); .)
    | "!i8" (. FModule.AddOpToMem(inStoreInt64); .)
    | "!i2" (. FModule.AddOpToMem(inStoreWord); .)
    | "!i1" (. FModule.AddOpToMem(inStoreByte); .)
    | "@" (. FModule.AddOpToMem(inFetchInt); .)
    | "@i8" (. FModule.AddOpToMem(inFetchInt64); .)
    | "@i2" (. FModule.AddOpToMem(inFetchWord); .)
    | "@i1" (. FModule.AddOpToMem(inFetchByte); .)
    | "DROP" (. FModule.AddOpToMem(inPopInt); .)
    | EmitAsmStatement
    | "@TICK" (. FModule.AddOpToMem(inGetTickCount); .)
    | "!TICK" (. FModule.AddOpToMem(inStoreTickCount); .)
    | WordAsmStatement
  .

  LabelDeclaration =
    "Label" Identifier   (. DefineLabelEx(LexString); .)  .

  PushIntAsmStatement = 
    ( IntegerToken|HexNumberToken ) (. FModule.AddOpToMem(inPushInt); FModule.AddIntToMem(StrToInt(LexString));.) .
  AddIntAsmStatement  = "+" (. FModule.AddOpToMem(inAddInt); .) .
  SubIntAsmStatement  = "-" (. FModule.AddOpToMem(inSubInt); .) .
  MulIntAsmStatement  = "*" (. FModule.AddopToMem(inMulInt); .) .
  EmitAsmStatement 
    = 
    "EMIT" (. FModule.AddOpToMem(inEmit); .) 
    | ".S" (. FModule.AddOpToMem(inEmitString); .) 
    | ".LS" (. FModule.AddOpToMem(inEmitLString); .) 
  .

  PushStringAsmStatement = "#" StringToken (. PushString(); .) .

  WordAsmStatement = Identifier (. AddIdentifierCFA(LexString); .).
END TurboForthCompiler.
