$C-  //Generate Delphi test project
$E-  //Generate a component registration unit
$Z+  //Generate console app

//{$IFDEF MSWINDOWS}Windows,{$ENDIF}
COMPILER TurboForthCompiler

DELPHI

USES (INTERFACE) uMeObject, uMeTypes, uStrUtils, uTurboConsts, uTurboMetaInfo, uTurboExecutor, uTurboAccessor, uTurboModuleFileAccessor, uTurboCompilerUtils//, uTurboSymbols

TYPE

PRIVATE
  procedure ProcessGrammarComment(Sender : TObject; CommentList : TCommentList);
  procedure SetCompilerOption(const aOptionName: string; aEnabled : TTurboCompilerOptionState; 
      ParamList : TStringList);


PROTECTED

PUBLIC

CREATE
  InternalGrammarComment := ProcessGrammarComment;
DESTROY
ERRORS
    cLabelRedeclarationError : Result := rsLabelRedeclarationSyntaxError;
    cWordNameIsNilDeclarationError: Result := rsWordNameIsNilDeclarationError;
    cUnknownWordError: Result := rsUnknownWordError;
    cConstRedeclarationError : Result := rsConstRedeclarationSyntaxError;
    cVarRedeclarationError : Result := rsVarRedeclarationSyntaxError;
    cRedeclarationError : Result := rsRedeclarationSyntaxError;
    cDLLModuleMissError: Result := rsDLLModuleMissSyntaxError;
    cFileNotFoundError:  Result := rsFileNotFoundError;
    cWordNotFoundError:  Result := rsWordNotFoundError;
    cInvalidOptionError: Result := '"' + Data + '" is an invalid option';
    cInvalidOptionParamError: Result := 'invalid modifiers for option "' + Data + '"';
    cStrToIntCovnertError: Result := 'Can not convert the strin to int!';
    cMessageCompilerOption: Result := Data;


PUBLISHED

END_DELPHI


type
  TCocoRScannerAccess = Class(TCocoRScanner);


{ T-->Grammar<-- }

procedure T-->Grammar<--.ProcessGrammarComment(Sender : TObject; CommentList : TCommentList);
var
  i, j: integer;
  vOptionName : string;
  vEnabled : TTurboCompilerOptionState;
  ParamList : TStringList;
begin
  with CommentList do 
  for i := 0 to Count - 1 do
  begin
    vOptionName := Comments[i];
    if (Length(vOptionName) >= 2) and (vOptionName[1]='{') and (vOptionName[2]='$') and (vOptionName[Length(vOptionName)]='}') then
    begin
      Delete(vOptionName, 1, 2);
      Delete(vOptionName, Length(vOptionName), 1);
      ParamList := TStringList.Create;
      try
        ParamList.QuoteChar := '''';
        ParamList.Delimiter := ',';
			
        j := Pos(' ', vOptionName);
        if j > 0 then
        begin
          inc(j);
          ParamList.DelimitedText := Trim(Copy(vOptionName, j, Length(vOptionName)-j));
          Dec(j);
          Delete(vOptionName, j, MaxInt);
        end;
          if (Length(vOptionName) > 0) then
          begin
            vEnabled := cosDefault;
            writeln('ApplyCompilerOption:',vOptionName, ', options:"', ParamList.Count, '"');
            if vOptionName[Length(vOptionName)] = '+' then 
            begin
              vEnabled := cosEnable;
              Delete(vOptionName, Length(vOptionName), 1);
            end
            else if vOptionName[Length(vOptionName)] = '-' then
            begin
              vEnabled := cosDisable;
              Delete(vOptionName, Length(vOptionName), 1);
            end
            else if ParamList.Count > 0 then
            begin
              if SameText(ParamList[0], 'ON') then
              begin
                vEnabled := cosEnable;
                ParamList.Delete(0);
              end
              else if SameText(ParamList[0], 'OFF') then
              begin
                vEnabled := cosDisable;
                ParamList.Delete(0);
              end;
            end;
            SetCompilerOption(UpperCase(vOptionName), vEnabled, ParamList);
          end;
      finally
        ParamList.Free;
      end;
    end;
  end;
end;

procedure T-->Grammar<--.SetCompilerOption(const aOptionName: string; aEnabled : TTurboCompilerOptionState;
    ParamList : TStringList);
var
  vMsgType: Integer;
  s: string;
begin
  if (aOptionName = 'C') or (aOptionName = 'ASSERTIONS') then
  begin
    if aEnabled = cosDisable then
      FModule.Options := FModule.Options - [soAssertSupport]
    else
      FModule.Options := FModule.Options + [soAssertSupport];
  end
  else if (aOptionName = 'L') or (aOptionName = 'LOADONDEMAND') then
  begin
    if aEnabled = cosDisable then
      FModule.Options := FModule.Options - [soLoadOnDemand]
    else
      FModule.Options := FModule.Options + [soLoadOnDemand];
  end
  else if (aOptionName = 'MAXCODESIZE') then
  begin
    if (ParamList.Count > 1) or (ParamList.Count = 0)  then
    begin
      SemError(cInvalidOptionParamError, aOptionName);
    end
    else 
    begin
      vMsgType := UnitStrToInt(ParamList[0]);
      if vMsgType > 0 then
        FModule.MemorySize := vMsgType
      else
        SemError(cInvalidOptionParamError, aOptionName);
    end;
  end
  else if (aOptionName = 'MAXDATASIZE') then
  begin
    if (ParamList.Count > 1) or (ParamList.Count = 0)  then
    begin
      SemError(cInvalidOptionParamError, aOptionName);
    end
    else 
    begin
      vMsgType := UnitStrToInt(ParamList[0]);
      if vMsgType > 0 then
        FModule.DataMemorySize := vMsgType
      else
        SemError(cInvalidOptionParamError, aOptionName);
    end;
  end
  else if (aOptionName = 'MESSAGE') then
  begin
    if (ParamList.Count > 2) or (ParamList.Count = 0)  then
    begin
      SemError(cInvalidOptionParamError, aOptionName);
    end
    else
    begin
      if ParamList.Count = 2 then
      begin
        s := ParamList[0];
        if s = 'HINT' then 
          vMsgType := etHint
        else if s = 'SYNTAX' then
          vMsgType := etSyntax
        else if s = 'SYMANTIC' then
          vMsgType := etSymantic
        else if s = 'WARN' then
          vMsgType := etWarn
        else begin
          SemError(cInvalidOptionParamError, aOptionName);
          vMsgType := -1;
        end
        ;
        s := ParamList[1];
      end
      else begin
        vMsgType := etHint;
        s := ParamList[0];
      end;
      //if vMsgType <> -1 then
      Case vMsgType of
        etHint: Writeln('Hint:', s);
        etWarn: Writeln('Warn:', s);
        Else
          ErrorMsg(cMessageCompilerOption, s, vMsgType);
      End;
    end;
  end
  else
    SemError(cInvalidOptionError, aOptionName);
end;

IGNORE CASE

CHARACTERS
 LETTER="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_".
 DIGIT =  "0123456789".
 CTRL=CHR(1)..CHR(31).
 SpecialChar = "*,()%:".
 TAB=CHR(9).
 EOL=CHR(13).
 LF=CHR(10).
 noQuote = ANY - "'" .
 noDblQuote = ANY - '"' .               
 noEOL = ANY - EOL .
 HexDigit = "0123456789ABCDEF" .

TOKENS
 Identifier = LETTER {LETTER|DIGIT}.
 IntegerToken = DIGIT {DIGIT} | DIGIT {DIGIT} CONTEXT ( ".." ).
 HexNumberToken = "$" HexDigit {HexDigit}.
 FloatToken = DIGIT {DIGIT} "." DIGIT {DIGIT} ["E" ["+" |"-"] DIGIT {DIGIT}].
 StringToken   = "'" { noQuote | "'" "'" } "'" .

NAMES


IGNORE TAB+EOL+LF

PRAGMAS
   //CompilerDirective DESCRIPTION "TurboScript Assembler Compiler Directive" 
     // = "[$" { noEOL } "]". (. Writeln('SDDSSDL:'+ LexString); .) //古怪得很，LexString 取得的值是上一个标识的，而不是这个CompilerDirective的！

//COMMENTS FROM "(" TO ")"
COMMENTS FROM "//" TO EOL
COMMENTS FROM "{" TO "}"



PRODUCTIONS

  (* TurboForthCompiler = Statement {Statement}  . *)  
  TurboForthCompiler DESCRIPTION "TurboScript Assembler Compiler"
    =                                                  (. Init ; .)  


    ( "PROGRAM"                                        (. FModule.ModuleType := mtProgram; .)
      |"UNIT"                                          (. FModule.ModuleType := mtLib; .) 
    )
    Identifier                                         (. SaveModuleName(LexString); .)
    [UseModulesBlock]
    [DeclarationBlock]  
    "BEGIN"                                            (. FInitProcCFA := FModule.UsedMemory;  .)
    ASMStatementBlock
    "END."                                             (. FModule.AddOpToMem(opPushInt); FModule.AddIntToMem(0); FModule.AddOpToMem(opHalt); .)
    (. Final ; .) .

   UseModulesBlock
    =
    UseModule {UseModule}.

   UseModule = "USES" Identifier (. DefineModule(LexString); .) ";" .

   DeclarationBlock 
    = 
    Declaration {Declaration}.

  Declaration = DefineConstPart| DefineVarPart | DefineWord .

  DefineConstPart
    =
    "CONST" DefineConstant {DefineConstant} 
  .

  DefineConstant
    (.Var vValue: PTurboConstSymbol; vType: PMeType; .) 
    =                      (. New(vValue, Create); 
                            try 
                           .)
    Identifier              (. vValue.Name := LexString; vValue.TurboType := nil; .) 
    [":" TypeKind<vType>    (. vValue.TurboType := vType; .) ]
    "=" Value<vValue> 
    ";"                     (. if IsUniqueIdentifier(vValue.Name) then DefineConstEx(vValue); 
                             finally
                               MeFreeAndNil(vValue);
                             end;
                              .) 
    .

  DefineVarPart
    = 
    "VAR" DefineVariable {DefineVariable}
  .

  DefineVariable
    (.Var vValue: PTurboVarSymbol; vType: PMeType; .)
    =  (.   New(vValue, Create); 
            try 
              vValue.Visibility := fvPrivate; vValue.ValueStr := ''; .)
    [WordVsibility<vValue.Visibility>] Identifier (. vValue.Name := LexString; .)
    ":" TypeKind<vType> (. vValue.TurboType := vType; .)
    ["=" Value<vValue>]
    ";" (.   if IsUniqueIdentifier(vValue.Name) then DefineVar(vValue); 
           finally
             MeFreeAndNil(vValue);
           end;
        .)
  .

  TypeKind<var aType: PMeType> 
    =
    IntegerType <aType>
    |StringType <aType>
  .

  IntegerType<var aSubType: PMeType>
    =
    "BYTE"                                            (. aSubType := GetRegisteredTypeByTypeInfo(TypeInfo(Byte)); .)
    |"WORD"                                           (. aSubType := GetRegisteredTypeByTypeInfo(TypeInfo(Word)); .)
    |"DWORD"                                          (. aSubType := GetRegisteredTypeByTypeInfo(TypeInfo(LongWord)); .)
    |"INTEGER"                                        (. aSubType := GetRegisteredTypeByTypeInfo(TypeInfo(Integer)); .)
//    |"QWORD"                                          (. aSubType := ttkQWord; .)
    |"INT64"                                          (. aSubType := GetRegisteredTypeByTypeInfo(TypeInfo(Int64)); .)
  .
  StringType<var aSubType: PMeType>
    =
    "STRING"                                          (. aSubType := GetRegisteredTypeByTypeInfo(TypeInfo(String)); .)
    |"SHORTSTRING"                                    (. aSubType := GetRegisteredTypeByTypeInfo(TypeInfo(ShortString)); .)
  .

  Value< const aValue: PTurboConstSymbol >
    = 
    (StringToken|IntegerToken|HexNumberToken)           (. aValue.AssignValue(LexString, aValue.TurboType); .)
//    |Identifier                                       (. aValue.Value := GetConstValueRec(aValue.TurboType, LexString); .)
  .

  DefineWord (. Var vSucc: Boolean; vWord: PTurboMethodSymbol; .)
    = 
                                                                 (. New(vWord, Create);
                                                                 try
                                                                    vWord.Visibility := fvPrivate; 
                                                                    vWord.CallStyle := csForth;
                                                                    vWord.CodeFieldStyle := cfsFunction;
                                                                 .)
    ":" [WordVsibility<vWord.Visibility>] Identifier     (. vWord.Name := LexString; .)
    
    [
    ExternalWordOption<vWord>                                    (. GenerateModuleEntryForWord(vWord); .)
    ]
                                                                 (.vSucc := DefineWordBegin(vWord);  .)
    [ASMStatementBlock]
    ";"                                                          (. if vSucc and (vWord.CodeFieldStyle = cfsFunction) then DefineWordEnd(); 
                                                                 finally
                                                                   MeFreeAndNil(vWord);
                                                                 end;
                                                                 .)
  .
  ExternalWordOption< const aWord: PTurboMethodSymbol >
    =
    //the default is the LastModuleRefEntry if no the module name.
                                                            (. aWord.ModuleName := ''; 
                                                               aWord.ExternalOptions.Name := '';
                                                            .)
    "EXTERNAL"                                              (. aWord.CodeFieldStyle := cfsExternalFunction; .)
    [
      StringToken                                           (.aWord.ModuleName := AnsiDequotedStr(LexString, '''');
                                                              aWord.ModuleType := mtLib; .)  //the default module Type is mtLib
      [ModuleType<aWord.ModuleType>]
    ]
    [
      "STDCALL"                (. aWord.CallStyle := csStdCall; .)
       |"REGISTER"             (. aWord.CallStyle := csRegister; .)
       |"PASCAL"               (. aWord.CallStyle := csPascal; .)
       |"FORTH"                (. aWord.CallStyle := csForth; .)
       ExternalWordOptionPart<aWord.ExternalOptions>
    ]
  .
  ModuleType< var aType: TTurboModuleType >
    =
    "LIB"                                                  (. aType := mtLib;  .)
    |"DLL"                                                 (. aType := mtDLL;  .)
    |"HOST"                                                (. aType := mtHost; .)
  .
  ExternalWordOptionPart < var aOptions: TTurboExteralMethodOptions >
    =
   ["Name" StringToken (. aOptions.Name := AnsiDequotedStr(LexString, ''''); .) ]
   ["Index" IntegerToken (. aOptions.Index := StrToInt(LexString); .)]
  .
  WordVsibility< var aVisibility: TTurboVisibility > 
    = 
    "HIDDEN"                                           (. aVisibility := fvHidden; .)
    |"PRIVATE"                                         (. aVisibility := fvPrivate; .)
    |"PROTECTED"                                       (. aVisibility := fvProtected; .)
    |"PUBLIC"                                          (. aVisibility := fvPublic; .)
    |"PUBLISHED"                                       (. aVisibility := fvPublished; .)
  .

  ASMStatementBlock 
    = 
    ASMStatement {ASMStatement}
    .

  ASMStatement 
    = 
    [LabelDeclaration]
     PushIntAsmStatement
    | PushStringAsmStatement 
    | AddIntAsmStatement
    | "i8+" (.FModule.AddOpToMem(opAddInt64); .)
    | SubIntAsmStatement
    | "i8-" (.FModule.AddOpToMem(opSubInt64); .)
    | MulIntAsmStatement
    | "!" (. FModule.AddOpToMem(opStoreInt); .)
    | "!i8" (. FModule.AddOpToMem(opStoreInt64); .)
    | "!i2" (. FModule.AddOpToMem(opStoreWord); .)
    | "!i1" (. FModule.AddOpToMem(opStoreByte); .)
    | "@" (. FModule.AddOpToMem(opFetchInt); .)
    | "@i8" (. FModule.AddOpToMem(opFetchInt64); .)
    | "@i2" (. FModule.AddOpToMem(opFetchWord); .)
    | "@i1" (. FModule.AddOpToMem(opFetchByte); .)
    | "DROP" (. FModule.AddOpToMem(opPopInt); .)
    | EmitAsmStatement
    | "@TICK" (. FModule.AddOpToMem(opGetTickCount); .)
    | "!TICK" (. FModule.AddOpToMem(opStoreTickCount); .)
    | "NOOP"  (. FModule.AddOpToMem(opNoop); .)
    | AssertStatement
    | WordAsmStatement
  .

  LabelDeclaration =
    "Label" Identifier   (. DefineLabelEx(LexString); .)  .

  PushIntAsmStatement = 
    ( IntegerToken|HexNumberToken ) (. PushInt32(LexString); .) .
  AddIntAsmStatement  = "+" (. FModule.AddOpToMem(opAddInt); .) .
  SubIntAsmStatement  = "-" (. FModule.AddOpToMem(opSubInt); .) .
  MulIntAsmStatement  = "*" (. FModule.AddOpToMem(opMulInt); .) .
  EmitAsmStatement 
    = 
    "EMIT" (. FModule.AddOpToMem(opEmit); .) 
    | ".S" (. FModule.AddOpToMem(opEmitString); .) 
    | ".LS" (. FModule.AddOpToMem(opEmitLString); .) 
  .

  PushStringAsmStatement = "#" StringToken (. PushStringSeqToStack(LexString); .) .

  WordAsmStatement 
    (.Var vName: string; vParams: TStringList; .)
    =
    (.vParams := nil; .)
      Identifier 
      (. vName := LexString;  //Writeln('pARSER word param::');
    try .)
      [(. vParams := TStringList.Create; .) WordParams<vParams>  ]
      (. 
      //writeln('EndParams');
      AddIdentifierCFA(vName, vParams);
      //if Assigned(vParams) then writeln(vName, ' WordParams:', vParams.CommaText) else writeln(vName, ' Not Assigned Params');
      //writeln('sym:',LexString);
    finally
      FreeAndNil(vParams);
    end; .)
  .
  WordParams< const aParams: TStringList >
    (. var vParam: string; .)
    =
    "("
    [ WordParam< vParam > (. aParams.Add(vParam); .)
    {"," WordParam< vParam > (. aParams.Add(vParam); .) } ]
    ")"
  .
  WordParam< var aParam: string >
    =
    ( IntegerToken|HexNumberToken|Identifier|StringToken ) (. aParam := LexString; .)
  .
  AssertStatement
    (. var vExpr: string; vMsg: string; .)
    =
    "ASSERT(" WordParam< vExpr > "," WordParam< vMsg > ")"
    (. if soAssertSupport in FModule.Options then
       begin
         //the current line No. 由于暂时没实现IntToStr以及StrConcat,所以 现在只压入2个参数
         //WriteLn('AddAssert at ', TCocoRScannerAccess(Scanner).CurrLine);
         vMsg := '''Assert failed at line:'+IntToStr(TCocoRScannerAccess(Scanner).CurrentSymbol.line)+'. '''+ vMsg+ '''''';
         //PushInt32(TCocoRScannerAccess(Scanner).CurrLine);
         PushString(vMsg);
         PushWordParam(vExpr);
         FModule.AddOpToMem(opAssert);
       end;
    .)
  .
    


END TurboForthCompiler.
