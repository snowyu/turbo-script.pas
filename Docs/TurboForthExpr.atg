$C-  //Generate Delphi test project
$E-  //Generate a component registration unit
$Z+  //Generate console app

COMPILER TurboForthCompiler

DELPHI

USES (INTERFACE) uStrUtils, uTurboConsts, uTurboExecutor 

TYPE
  TTurboLabelDeclarationRec = packed record
    Name: String;
    Addr: Integer;
  end;
  
  TTurboConstDeclarationRec = packed record
    Name: String;
    //TypeKind: TTurboTypeKind;
    Value: String;
  end;

PRIVATE
  FInitProcCFA: Integer;
  FLastWordEntry: PTurboWordEntry;
  FLastWordCfa: Integer;
  FModule: TCustomTurboModule;
  FLabels: array of TTurboLabelDeclarationRec;
  FConsts: array of TTurboConstDeclarationRec;
  procedure Init;
  procedure Final;
  procedure WriteStr(S : String);
  procedure WriteStrLn(S : String);
  procedure DefineWordBegin(const aName: ShortString);
  procedure DefineWordEnd;
  procedure AddWord(const aName: string);
  procedure PushString();
  function AddLabel(const aName: string): Integer;
  //if find retrun label index else -1
  function FindLabel(const aName: string): Integer;
  //if not find then add new label, return label index else raise error.
  function AddLabelEx(const aName: string): Integer;
  function  AddConst(const aName, aValue: String): Integer;
  //if not find then add new , return index else raise error.
  function  AddConstEx(const aName, aValue: String): Integer;
  function FindConst(const aName: String): Integer;
  function GetConstValue(aName: string): String;

  //if not find then add new , return index else raise error.
  procedure AddVar(const aName: string; aType: TTurboTypeKind; const aValue: String = ''; aVisibility: TTurboVisibility = fvPublished);
PROTECTED

PUBLIC
  FileName: string;

CREATE
  FModule := TCustomTurboModule.Create;
DESTROY
  FreeAndNil(FModule);
ERRORS
    cLabelRedeclarationError : Result := rsLabelRedeclarationSyntaxError;
    cWordNameIsNilDeclarationError: Result := rsWordNameIsNilDeclarationError;
    cUnknownWordError: Result := rsUnknownWordError;
    cConstRedeclarationError : Result := rsConstRedeclarationSyntaxError;
    cVarRedeclarationError : Result := rsVarRedeclarationSyntaxError;

PUBLISHED

END_DELPHI

Const
  cMaxMemorySize = 64 * 1024;
  cLabelRedeclarationError = 300;
  cWordNameIsNilDeclarationError = 301;
  cUnknownWordError = 302;
  cVarRedeclarationError = 303;
  cConstRedeclarationError = 304;

function T-->Grammar<--.GetConstValue(aName: String): String;
var
  i: Integer;
begin
  for i := 0 to Length(FConsts) do
    if aName = FConsts[i].Name then
    begin
      Result := FConsts[i].Value;
    end;
  SynError(cUnknownWordError);
end;

function T-->Grammar<--.AddLabel(const aName: string): Integer;
begin
    Result := Length(FLabels);
    SetLength(FLabels, Result+1);
    with FLabels[Result] do
    begin
      Name := aName;
      Addr := FModule.UsedMemory;
    end;
end;

function T-->Grammar<--.AddLabelEx(const aName: string): Integer;
begin
  Result := FindLabel(aName);
  if Result = -1 then
  begin
    Result := AddLabel(aName);
  end
  else 
    SynError(cLabelRedeclarationError);

end;

procedure T-->Grammar<--.AddWord(const aName: string);
var
  vCFA: Integer;
begin
  vCFA := FModule.GetWordCFA(aName);
  if vCFA <> 0 then
  begin
    FModule.AddIntToMem(vCFA);
  end
  else 
    SynError(cUnknownWordError);
end;

function T-->Grammar<--.AddConstEx(const aName, aValue: String): Integer;
begin
  Result := FindConst(aName);
  if Result = -1 then
  begin
    Result := AddConst(aName, aValue);
  end
  else 
    SynError(cConstRedeclarationError);
end;

function T-->Grammar<--.AddConst(const aName, aValue: String): Integer;
begin
  Result := Length(FConsts);
  SetLength(FConsts, Result+1);
  with FConsts[Result] do
  begin
    Name := aName;
    Value := aValue;
  end;
end;

function T-->Grammar<--.FindConst(const aName: String): Integer;
begin
  for Result := 0 to Length(FConsts)-1 do
  begin
    if aName = FConsts[Result].Name then exit;
  end;
  Result := -1;
end;

procedure T-->Grammar<--.AddVar(const aName: string; aType: TTurboTypeKind; const aValue: String; aVisibility: TTurboVisibility);
var
  vVaraibleEntry: PTurboVariableEntry;
  vValue: Pointer;
  vTypeSize: Integer;
begin
  Integer(vVaraibleEntry) := Integer(FModule.Memory) + FModule.UsedMemory;
  vTypeSize := GetTurboTypeSize(aType);
  FModule.AddIntToMem(Integer(FModule.LastVariableEntry));
  FModule.AddIntToMem(vTypeSize);
  FModule.AddIntToMem(0); //preserved.for addr.
  if aVisibility >= fvPublished then
  begin
    FModule.AddByteToMem(Length(aName));
    //Integer(P) := (FModule.Memory) + FModule.UsedMemory;
    //FModule.AllocSpace(Length(aName));
    FModule.AddBufferToMem(aName[1], Length(aName));
    
  end
  else 
  begin
    FModule.AddByteToMem(0);
  end;

  Integer(vVaraibleEntry.Addr) := FModule.UsedMemory;
  Integer(vValue) := Integer(FModule.Memory)  + FModule.UsedMemory;
  FModule.AllocSpace(vTypeSize);
  //CopyTurboTypeVar(aValue, vValue^, aType);
  case aType of
    ttSByte: PShortInt(vValue)^  := StrToInt(aValue);
    ttUByte, ttChar, ttSet: PByte(vValue)^ := StrToInt(aValue);
    ttSWord:PSmallInt(vValue)^ := StrToInt(aValue);
    ttUWord: PWord(vValue)^ := StrToInt(aValue);
    ttSLong: PInteger(vValue)^ := StrToInt(aValue);
    ttULong: PLongWord(vValue)^ := StrToInt(aValue);
    ttQWord, ttInt64: PInt64(vValue)^:= StrToInt(aValue);
  end;
end;

procedure T-->Grammar<--.DefineWordBegin(const aName: ShortString);
var
  p: pointer;
begin
  if aName = '' then 
    SynError(cWordNameIsNilDeclarationError)
  else begin
    Integer(FLastWordEntry) := Integer(FModule.Memory) + FModule.UsedMemory;
    p := FModule.LastWordEntry;
    FModule.AddIntToMem(Integer(p));
    FModule.AllocSpace(SizeOf(TTurboWordOptions));
    FModule.AllocSpace(SizeOf(LongWord)); //the ParamFieldLength
    FModule.AddByteToMem(Length(aName));
    FModule.AddBufferToMem(aName[1], Length(aName));
    FLastWordCfa := FModule.UsedMemory;
  end;
end;

procedure T-->Grammar<--.DefineWordEnd;
var
  vPrior: PTurboWordEntry;
begin
  FModule.AddIntToMem(Integer(inExit));
  FLastWordEntry.ParamFieldLength := FModule.UsedMemory - FLastWordCfa + 1;

  vPrior := FModule.LastWordEntry;
  FModule.LastWordEntry := FLastWordEntry;
  FLastWordEntry.Prior := vPrior;
end;

function T-->Grammar<--.FindLabel(const aName: string): Integer;
begin
  for Result := 0 to length(FLabels) -1 do
  begin
    if SameText(aName, FLabels[Result].Name) then
    begin
      exit;
    end;
  end;
  Result := -1;
end;


procedure T-->Grammar<--.Init;
begin
  with FModule do
  begin
    ClearMemory;
    MemorySize := cMaxMemorySize;
  end;
  SetLength(FLabels, 0);
  SetLength(FConsts, 0);
  //writeln('SourceFileName=', SourceFileName);
  FileName := ExtractFileBaseName(SourceFileName) + cTurboCompiledProgramFileExt;
  //writeln('FileName=', FileName);
end;

procedure T-->Grammar<--.Final;
var
  vStream: TFileStream;
begin
  //writeln('Final');
  if ErrorList.Count = 0 then
  begin
   //writeln('No error');
    //WriteStrLn('The Result: '+FloatToStr(fResult));
    if FileName <> '' then
    begin
      FModule.IsLoaded := True;
      //writeln('InitProcCFA=', FInitProcCFA+SizeOf(TTurboModuleStreamHeader));
      with PPreservedCodeMemory(FModule.Memory)^ do
      begin
        Integer(InitializeProc) := FInitProcCFA;
      end;
      if LowerCase(ExtractFileExt(FileName)) <> cTurboCompiledProgramFileExt then
        FileName := ChangeFileExt(FileName, cTurboCompiledProgramFileExt);
      vStream := TFileStream.Create(FileName, fmCreate);
      try
        writeln('saving to ' + FileName);
        FModule.SaveToStream(vStream);
      finally
        vStream.Free;
      end;
    end;
  end;
  FModule.ClearMemory;
  SetLength(FLabels, 0);
end;

procedure T-->Grammar<--.PushString();
var
  s: string;
  i: Integer;
begin
  s := AnsiDequotedStr(LexString, '''');
  for i := length(s) downto 1 do
  begin
    FModule.AddIntToMem(Integer(inPushInt));
    FModule.AddIntToMem(Ord(s[i])); 
  end;
end;

procedure T-->Grammar<--.WriteStrLn(S : string);
begin
  WriteStr(s+#13#10); 
end;

procedure T-->Grammar<--.WriteStr(S : string);
begin
  ListStream.WriteBuffer(S[1],length(S));
end;



IGNORE CASE

CHARACTERS
 LETTER="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_".
 DIGIT =  "0123456789".
 CTRL=CHR(1)..CHR(31).
 SpecialChar = "*,()%:".
 TAB=CHR(9).
 EOL=CHR(13).
 LF=CHR(10).
 noQuote = ANY - "'" .
 noDblQuote = ANY - '"' .               
 HexDigit = "0123456789ABCDEF" .

TOKENS
 Identifier = LETTER {LETTER|DIGIT}.
 IntegerToken = DIGIT {DIGIT} | DIGIT {DIGIT} CONTEXT ( ".." ).
 HexNumberToken = "$" HexDigit {HexDigit}.
 FloatToken = DIGIT {DIGIT} "." DIGIT {DIGIT} ["E" ["+" |"-"] DIGIT {DIGIT}].
 StringToken   = "'" { noQuote | "'" "'" } "'" .

NAMES


IGNORE TAB+EOL+LF
PRAGMAS

COMMENTS FROM "(" TO ")"
COMMENTS FROM "//" TO EOL
//COMMENTS FROM "{" TO "}"



PRODUCTIONS

  (* TurboForthCompiler = Statement {Statement}  . *)  
  TurboForthCompiler 
    =                                                  (. Init ; .)  
    "PROGRAM" Identifier                               (. FModule.Name := LexString; .)
    [DeclarationBlock]
    "BEGIN"                                            (. FInitProcCFA := FModule.UsedMemory;  .)
    StatementBlock
    "END."                                             (. FModule.AddIntToMem(Integer(inHalt)); .)
    (. Final ; .) .

  DeclarationBlock 
    = 
    Declaration {Declaration}.

  Declaration = DefineConstPart| DefineVarPart | DefineWord .

  DefineConstPart
    =
    "CONST" DefineConstant {DefineConstant} 
  .

  DefineConstant
    (.Var vName, vValue: string; .) 
    = 
    Identifier (. vName := LexString; .) "=" Value<vValue> ";" 
    (. AddConstEx(vName, vValue); .) .

  DefineVarPart
    = 
    "VAR" DefineVariable {DefineVariable}
  .

  DefineVariable
    (.Var vName: string; vType: TTurboTypeKind; vValue: string; .)
    = 
    Identifier (. vName := LexString; if FModule.FindVariableEntry(vName) <> nil then SynError(cVarRedeclarationError); .)
    ":" TypeKind<vType> 
    ["=" Value<vValue>]
    ";" (. AddVar(vName, vType, vValue) .)
  .

  TypeKind<out aType: TTurboTypeKind> 
    =
    IntegerType <aType>
  .
  IntegerType<var aSubType: TTurboTypeKind>
    =
    "BYTE"                                            (. aSubType := ttUByte; .)
    |"WORD"                                           (. aSubType := ttUWord; .)
    |"DWORD"                                          (. aSubType := ttULong; .)
    |"INTEGER"                                        (. aSubType := ttSLong; .)
    |"QWORD"                                          (. aSubType := ttQWord; .)
    |"INT64"                                          (. aSubType := ttInt64; .)
  .

  Value< out aValue: string >
    =
    StringToken                                       (. aValue := AnsiDequotedStr(LexString, ''''); .)
    |IntegerToken                                     (. aValue := LexString; .)
    |HexNumberToken                                   (. aValue := LexString; .)
    |Identifier                                       (. aValue := GetConstValue(LexString); .)
  .

  DefineWord
    =
    ":" Identifier                                     (. DefineWordBegin(LexString); .)
    StatementBlock
    ";"                                                (. DefineWordEnd; .)
  .

  StatementBlock 
    = 
    Statement {Statement}
    .

  Statement 
    = 
    [LabelDeclaration]
     PushIntStatement
    | PushStringStatement 
    | AddIntStatement
    | SubIntStatement
    | EmitStatement
    | WordStatement
  .

  LabelDeclaration =
    "Label" Identifier(. AddLabelEx(LexString); .)  .

  PushIntStatement = IntegerToken (. FModule.AddIntToMem(Integer(inPushInt)); FModule.AddIntToMem(StrToInt(LexString));.) .
  AddIntStatement  = "+" (. FModule.AddIntToMem(Integer(inAddInt)); .) .
  SubIntStatement  = "-" (. FModule.AddIntToMem(Integer(inSubInt)); .) .
  EmitStatement = "EMIT" (. FModule.AddIntToMem(Integer(inEmit)); .) .
  PushStringStatement = "#" StringToken (. PushString(); .) .

  WordStatement = Identifier (. AddWord(LexString); .).
END TurboForthCompiler.
