$C-  //Generate Delphi test project
$E-  //Generate a component registration unit
$Z+  //Generate console app

//{$IFDEF MSWINDOWS}Windows,{$ENDIF}
COMPILER TurboForthCompiler

DELPHI

USES (INTERFACE) uStrUtils, uTurboConsts, uTurboMetaInfo, uTurboExecutor, uTurboAccessor, uTurboModuleFileAccessor//, uTurboSymbols

TYPE
  TTurboCompilerOptionState = (cosDefault, cosEnable, cosDisable);

  TTurboValueRec = packed record
    case Integer of
      0: (
        case TTurboSimpleTypeKind of
          //ttkUByte: (VByte: Byte);
          ttkSByte: (VShortInt: ShortInt);
          //ttkUWord: (VWord: Word);
          ttkSWord: (VSmallInt: SmallInt);
          ttkULong: (VLong: LongWord);
          ttkSLong: (VInteger: Integer);
          ttkSet:        (VSet: Byte);
          ttkLString:    (VAnsiString: Pointer);
          ttkChar:       (VChar: Char);
          ttkWString:    (VWideString: Pointer);
          ttkString:     (VString: PShortString);
          ttkPointer:    (VPointer: Pointer);
          //ttkObject:     (VMeObject: Pointer);
          ttkClass:      (VObject: TObject);
          ttkWChar:      (VWideChar: WideChar);
          ttkVariant:    (VVariant: TVarData);
          ttkInterface:  (VInterface: Pointer);
          ttkInt64:      (VInt64: Int64);
          ttkDynArray:   (VDynBound: Integer; VDynArray: Pointer);
          ttkMethod:     (VCode: Pointer; VData: Pointer);
          //ttkProcedure:  (VCode: Pointer);
             ttkSingle: (VSingle: Single);
             ttkDouble: (VDouble: Double);
             ttkExtended: (VExtended: Extended);
             ttkComp: (VComp: Comp);
             ttkCurr: (VCurr: Currency);
      );
      1: (VBytes: array [0..15] of byte);
      2: (VWords: array [0..7] of word);
      3: (VDWords: array [0..3] of LongWord);
      4: (VInt64s: array [0..1] of Int64);
      5: (VByte: byte);
      6: (VWord: word);
      7: (VLongword: Longword);
  end;

  TTurboLabelDeclarationRec = packed record
    Name: String;
    WordName: String;
    Addr: Integer;
  end;
  
  TTurboSimpleConst = object
  public
    Name: ShortString;
    TypeKind: TTurboSimpleTypeKind;
    Value: TTurboValueRec;
    ValueStr: ShortString;
    Size: Integer;
  public
    procedure SetTypeKind(aValue: TTurboSimpleTypeKind);
    function AssignValueTo(const Source: Pointer): Boolean;
    //根据aValue 如果aTypeKind is ttkUnknown 那么会自动判断其类型
    function AssignValue(const aValue: string; aTypeKind: TTurboSimpleTypeKind = ttkUnknown): Boolean;
    procedure SaveString(const aModule: TCustomTurboModule);
  end;

  TTurboSimpleVar = object(TTurboSimpleConst)
  public
    Visibility: TTurboVisibility;
    Addr: Integer;
  end;

  TTurboSimpleWord = object
    Options: TTurboWordOptions;
    //the Param Field Length
    //该函数主体的长度 
    ParamFieldLength: LongWord;
    CFA: tsInt;//the offset address of the memory.
    Name: ShortString; 
    ModuleName: ShortString;  //for external word
    ModuleType: TTurboModuleType;  //for external word
    ModuleIndex: Integer; //for external word
    Module: TCustomTurboModule; //for external forth word
    ExternalOptions: TTurboExteralMethodOptions; //Exteral Word Options
  end;

  TTurboSimpleModule = object
    Entry: PTurboModuleRefEntry;
    ModuleType: TTurboModuleType;
    Name: ShortString;
    Module: TCustomTurboModule;
  end;

PRIVATE
  FTurboGlobalOptions: TTurboGlobalOptions;
  FInitProcCFA: Integer;
  //正在定义的Word,如果存在 
  FDefinedWordEntry: PTurboMethodEntry;
  FLastWordCfa: Integer;
  FModule: TCustomTurboModule;

  FLabels: array of TTurboLabelDeclarationRec;
  FConsts: array of TTurboSimpleConst;
  FVars: array of TTurboSimpleVar;
  FWords: array of TTurboSimpleWord;
  FUsedModules: array of TTurboSimpleModule;
  procedure Init;
  procedure Final;
  procedure WriteStr(S : String);
  procedure WriteStrLn(S : String);
  function  DefineWordBegin(var aWord: TTurboSimpleWord): Boolean;
  procedure DefineWordEnd();
  procedure PushString(const aStr: string);
  procedure PushStringSeqToStack(const aStr: string);
  procedure PushInt32(const aStr: string);overload;
  procedure PushInt32(const aInt: tsInt);overload;

  procedure ProcessGrammarComment(Sender : TObject; CommentList : TCommentList);
  procedure SetCompilerOption(const aOptionName: string; aEnabled : TTurboCompilerOptionState; 
      ParamList : TStringList);
  //case the aValue type push the aValue to CodeMem
  procedure PushWordParam(const aValue: string);
  // Add Identifier CFA address into the memory. 
  function AddIdentifierCFA(const aName: String; const aParams: TStringList): Boolean;
  // AddWordCFA address into the memory. 
  function AddWordCFA(aName: String; const aParams: TStringList): Boolean;
  // Add Const address into the memory. 
  function AddConstCFA(const aName: String): Boolean;
  // Add Var address into the memory. 
  function AddVarCFA(const aName: String): Boolean;

  function DefineLabel(const aName: string; const aWordName: string =''): Integer;
  //if find retrun label index else -1
  function FindLabel(const aName: string; const aWordName: string =''): Integer;
  //if not find then add new label, return label index else raise error.
  function DefineLabelEx(const aName: string; const aWordName: string =''): Integer;
  function  DefineConst(const aValue: TTurboSimpleConst): Integer;
  //if not find then add new , return index else raise error.
  function  DefineConstEx(const aValue: TTurboSimpleConst): Integer;
  function FindConst(const aName: String): Integer;
  function GetConstValueRec(const aTypeKind: TTurboSimpleTypeKind; const aName: string): TTurboValueRec;

  //if not find then add new , return index else raise error.
  function DefineVar(const aValue: TTurboSimpleVar): Integer;
  function FindVar(const aName: String): Integer;

  //try find module if not then Generate.
  procedure GenerateModuleEntryForWord(var aWord: TTurboSimpleWord);
  function FindModule(const aName: String; aModuleType: TTurboModuleType): Integer;
  function  AddUsedModule(const aName: String; aModuleType: TTurboModuleType): Integer;
  function FindWord(const aName: String): Integer;
  
  //make sure the indentifier is unique else it will raise the error..
  function IsUniqueIdentifier(const aName: String): Boolean;
PROTECTED

PUBLIC
  FileName: string;

CREATE
  FModule := TCustomTurboModule.Create;
  FModule.GlobalOptions := @FTurboGlobalOptions;
  InternalGrammarComment := ProcessGrammarComment;
DESTROY
  FreeAndNil(FModule);
ERRORS
    cLabelRedeclarationError : Result := rsLabelRedeclarationSyntaxError;
    cWordNameIsNilDeclarationError: Result := rsWordNameIsNilDeclarationError;
    cUnknownWordError: Result := rsUnknownWordError;
    cConstRedeclarationError : Result := rsConstRedeclarationSyntaxError;
    cVarRedeclarationError : Result := rsVarRedeclarationSyntaxError;
    cRedeclarationError : Result := rsRedeclarationSyntaxError;
    cDLLModuleMissError: Result := rsDLLModuleMissSyntaxError;
    cFileNotFoundError:  Result := rsFileNotFoundError;
    cWordNotFoundError:  Result := rsWordNotFoundError;
    cInvalidOptionError: Result := '"' + Data + '" is an invalid option';
    cInvalidOptionParamError: Result := 'invalid modifiers for option "' + Data + '"';
    cStrToIntCovnertError: Result := 'Can not convert the strin to int!';
    cMessageCompilerOption: Result := Data;


PUBLISHED

END_DELPHI

Const
  cMaxMemorySize = 64 * 1024;
  cLabelRedeclarationError = 300;
  cWordNameIsNilDeclarationError = 301;
  cUnknownWordError = 302;
  cVarRedeclarationError = 303;
  cConstRedeclarationError = 304;
  cRedeclarationError = 305;
  cDLLModuleMissError = 306;
  cFileNotFoundError  = 307;
  cWordNotFoundError  = 308;
  cStrToIntCovnertError = 309;
  cInvalidOptionError = 400;
  cInvalidOptionParamError = 401;
  cMessageCompilerOption = 500;

Const
  cReqAlignMemTypes = [ttkUWord, ttkSWord, ttkULong, ttkSLong, ttkPointer, ttkString, ttkLString, ttkInt64, ttkQWord];

type
  TCocoRScannerAccess = Class(TCocoRScanner);

function UnitStrToInt(s: string): integer;
var
  vUnit: integer;
begin
  vUnit := 1;
  if Length(s) >= 3 then
  begin
    if UpCase(s[Length(s)]) = 'B' then
    begin
      if UpCase(s[Length(s)-1]) = 'K' then
      begin
        vUnit := 1024;
        Delete(s, Length(s)-2, 2);
      end
      else if UpCase(s[Length(s)-1]) = 'M' then
      begin
        vUnit := 1024 * 1024;
        Delete(s, Length(s)-2, 2);
      end;
    end;
  end;
    Result := StrToIntDef(s, -1);
    if Result > 0 then 
    begin 
      Result := Result * vUnit;
    end;
end;

function GetSimpleTurboTypeSize(const aTypeKind: TTurboSimpleTypeKind): Integer;
begin
  case aTypeKind of
    ttkSByte, ttkUByte, ttkChar, ttkSet: Result := SizeOf(Byte);
    ttkSWord, ttkUWord: Result := SizeOf(Word);
    ttkSingle: Result := SizeOf(Single);
    ttkDouble: Result := SizeOf(Double);
    ttkComp:  Result := SizeOf(Comp);
    ttkExtended: Result := SizeOf(Extended);
    ttkCurr: Result := SizeOf(Currency);
    ttkEnumeration: Result := -1; //can not determine. <=256 elemnts is byte, <=$FFFF elemnts is word.
    ttkQWord, ttkInt64: Result := SizeOf(Int64);
    //ttkShortString, ttkAnsiString, ttkPointer: Result := SizeOf(Pointer); //Pointer = Integer
  else
    Result := SizeOf(Integer);
  end;
end;

function TTurboSimpleConst.AssignValue(const aValue: string; aTypeKind: TTurboSimpleTypeKind): Boolean;
begin
  Result := True;
  //writeln('AssignValue:', Integer(aTypeKind));
  if (aTypeKind = ttkUnknown) and (aValue[1] = '''') then
  begin
       aTypeKind := ttkString;
      {
      if Length(ValueStr) = 1 then
        aTypeKind := ttkChar
      else if Length(ValueStr) < 256 then
      begin
        aTypeKind := ttkString;
      end
      else begin
        aTypeKind := ttkLString;
      end;}
  end;
  Case aTypeKind of
    ttkString, ttkLString: 
    begin
      ValueStr := AnsiDequotedStr(aValue, '''');
    end;
    ttkChar:
    begin
      ValueStr := AnsiDequotedStr(aValue, '''');
      Value.VByte := Ord(ValueStr[1]);
    end;
    ttkSByte, ttkUByte, ttkSWord, ttkUWord, ttkSLong, ttkULong, ttkInt64:
    try
      ValueStr := aValue;
      Value.VInt64 := StrToInt64(aValue);
    except
      aTypeKind := ttkUnknown;
      Result := False;
    end
    else //Case-Else aTypeKind
    begin
      ValueStr := aValue;
      try //is Integer?
        Value.VInt64 := StrToInt64(aValue);
        if (Value.VInt64 >= Low(ShortInt)) and (Value.VInt64<=High(ShortInt)) then
          aTypeKind := ttkSByte
        else if (Value.VInt64 >= Low(Byte)) and (Value.VInt64<=High(Byte)) then
          aTypeKind := ttkUByte
        else if (Value.VInt64 >= Low(SmallInt)) and (Value.VInt64<=High(SmallInt)) then
          aTypeKind := ttkSWord
        else if (Value.VInt64 >= Low(Word)) and (Value.VInt64<=High(Word)) then
          aTypeKind := ttkUWord
        else if (Value.VInt64 >= Low(LongInt)) and (Value.VInt64<=High(LongInt)) then
          aTypeKind := ttkSLong
        else if (Value.VInt64 >= Low(LongWord)) and (Value.VInt64<=High(LongWord)) then
          aTypeKind := ttkULong
        else //if (Value.VInt64 >= Low(Int64)) and (Value.VInt64<=High(Int64)) then
          aTypeKind := ttkInt64;
      except
        aTypeKind := ttkUnknown;
        Result := False;
      end;

      if aTypeKind = ttkUnknown then
      try //is Float?
        Value.VDouble := StrToFloat(aValue);
        {if (Value.VDouble >= Low(Single)) and (Value.VDouble<=High(Single)) then //can not get low..High
          aTypeKind := ttkSingle
        else}
          aTypeKind := ttkDouble;
      except
        aTypeKind := ttkUnknown;
        Result := False;
      end
    end;
  End; //Case

  TypeKind := aTypeKind;
  if aTypeKind <> ttkUnknown then begin
    Result := True;
  end;
  if Result then
    Size := GetSimpleTurboTypeSize(TypeKind);
end;

function TTurboSimpleConst.AssignValueTo(const Source: Pointer): Boolean;
begin
  Result := True;
  //writeln('AssignValueTo:', ValueStr);
  move(Value, Source^, Size);
  //writeln(InttoHex(Value.VInteger, 4));
  {case TypeKind of
    ttkSLong, ttkInterface, ttkProcedure, ttkPointer, ttkString, ttkLString: PInteger(Source)^ := Value.VInteger;
    ttkSByte: PShortInt(Source)^  := Value.VShortInt;
    ttkUByte, ttkChar, ttkSet: PByte(Source)^ := Value.VByte;
    ttkSWord:PSmallInt(Source)^ := Value.VSmallInt;
    ttkUWord: PWord(Source)^ := Value.VWord;
    ttkULong: PLongWord(Source)^ := Value.VLongword;
    ttkQWord, ttkInt64: PInt64(Source)^:= Value.VInt64;
    else 
      Result := False;
  end;//}
  //writeln('TypeKind=', Integer(TypeKind));
  //writeln('PSource=', PInteger(Source)^);
end;

procedure TTurboSimpleConst.SaveString(const aModule: TCustomTurboModule);
begin
    Case TypeKind of
      ttkString: begin
        Value.VInteger := aModule.UsedDataSize;
        aModule.AddByteToData(Length(ValueStr));
        aModule.AddBufferToData(ValueStr[1], Length(ValueStr));
      end;
      ttkLString: begin
        aModule.AddIntToData(-1);
        aModule.AddIntToData(Length(ValueStr));
        Value.VInteger := aModule.UsedDataSize;
        aModule.AddBufferToData(ValueStr[1], Length(ValueStr));
        aModule.AddByteToData(0);
      end;
    end;//case
end;

procedure TTurboSimpleConst.SetTypeKind(aValue: TTurboSimpleTypeKind);
begin
  TypeKind := aValue;
  Size := GetSimpleTurboTypeSize(TypeKind);
end;

{ T-->Grammar<-- }

procedure T-->Grammar<--.ProcessGrammarComment(Sender : TObject; CommentList : TCommentList);
var
  i, j: integer;
  vOptionName : string;
  vEnabled : TTurboCompilerOptionState;
  ParamList : TStringList;
begin
  with CommentList do 
  for i := 0 to Count - 1 do
  begin
    vOptionName := Comments[i];
    if (Length(vOptionName) >= 2) and (vOptionName[1]='{') and (vOptionName[2]='$') and (vOptionName[Length(vOptionName)]='}') then
    begin
      Delete(vOptionName, 1, 2);
      Delete(vOptionName, Length(vOptionName), 1);
      ParamList := TStringList.Create;
      try
        ParamList.QuoteChar := '''';
        ParamList.Delimiter := ',';
			
        j := Pos(' ', vOptionName);
        if j > 0 then
        begin
          inc(j);
          ParamList.DelimitedText := Copy(vOptionName, j, Length(vOptionName)-j);
          Dec(j);
          Delete(vOptionName, j, MaxInt);
        end;
          if (Length(vOptionName) > 0) then
          begin
            vEnabled := cosDefault;
            writeln('ApplyCompilerOption:',vOptionName);
            if vOptionName[Length(vOptionName)] = '+' then 
            begin
              vEnabled := cosEnable;
              Delete(vOptionName, Length(vOptionName), 1);
            end
            else if vOptionName[Length(vOptionName)] = '-' then
            begin
              vEnabled := cosDisable;
              Delete(vOptionName, Length(vOptionName), 1);
            end
            else if ParamList.Count > 0 then
            begin
              if SameText(ParamList[0], 'ON') then
              begin
                vEnabled := cosEnable;
                ParamList.Delete(0);
              end
              else if SameText(ParamList[0], 'OFF') then
              begin
                vEnabled := cosDisable;
                ParamList.Delete(0);
              end;
            end;
            SetCompilerOption(UpperCase(vOptionName), vEnabled, ParamList);
          end;
      finally
        ParamList.Free;
      end;
    end;
  end;
end;

procedure T-->Grammar<--.SetCompilerOption(const aOptionName: string; aEnabled : TTurboCompilerOptionState;
    ParamList : TStringList);
var
  vMsgType: Integer;
  s: string;
begin
  if (aOptionName = 'C') or (aOptionName = 'ASSERTIONS') then
  begin
    if aEnabled = cosDisable then
      FModule.Options := FModule.Options - [soAssertSupport]
    else
      FModule.Options := FModule.Options + [soAssertSupport];
  end
  else if (aOptionName = 'L') or (aOptionName = 'LOADONDEMAND') then
  begin
    if aEnabled = cosDisable then
      FModule.Options := FModule.Options - [soLoadOnDemand]
    else
      FModule.Options := FModule.Options + [soLoadOnDemand];
  end
  else if (aOptionName = 'MAXCODESIZE') then
  begin
    if (ParamList.Count > 1) or (ParamList.Count = 0)  then
    begin
      SemError(cInvalidOptionParamError, aOptionName);
    end
    else 
    begin
      vMsgType := UnitStrToInt(ParamList[0]);
      if vMsgType > 0 then
        FModule.MemorySize := vMsgType
      else
        SemError(cInvalidOptionParamError, aOptionName);
    end;
  end
  else if (aOptionName = 'MAXDATASIZE') then
  begin
    if (ParamList.Count > 1) or (ParamList.Count = 0)  then
    begin
      SemError(cInvalidOptionParamError, aOptionName);
    end
    else 
    begin
      vMsgType := UnitStrToInt(ParamList[0]);
      if vMsgType > 0 then
        FModule.DataMemorySize := vMsgType
      else
        SemError(cInvalidOptionParamError, aOptionName);
    end;
  end
  else if (aOptionName = 'MESSAGE') then
  begin
    if (ParamList.Count > 2) or (ParamList.Count = 0)  then
    begin
      SemError(cInvalidOptionParamError, aOptionName);
    end
    else
    begin
      if ParamList.Count = 2 then
      begin
        s := ParamList[0];
        if s = 'HINT' then 
          vMsgType := etHint
        else if s = 'SYNTAX' then
          vMsgType := etSyntax
        else if s = 'SYMANTIC' then
          vMsgType := etSymantic
        else if s = 'WARN' then
          vMsgType := etWarn
        else begin
          SemError(cInvalidOptionParamError, aOptionName);
          vMsgType := -1;
        end
        ;
        s := ParamList[1];
      end
      else begin
        vMsgType := etHint;
        s := ParamList[0];
      end;
      //if vMsgType <> -1 then
      Case vMsgType of
        etHint: Writeln('Hint:', s);
        etWarn: Writeln('Warn:', s);
        Else
          ErrorMsg(cMessageCompilerOption, s, vMsgType);
      End;
    end;
  end
  else
    SemError(cInvalidOptionError, aOptionName);
end;

function T-->Grammar<--.AddIdentifierCFA(const aName: string; const aParams: TStringList): Boolean;
begin
  if not Assigned(aParams) then
  begin
    Result := AddConstCFA(aName);
    if Result then exit;

    Result := AddVarCFA(aName);
    if Result then exit;
  end;

  Result := AddWordCFA(aName, aParams);
  if Result then exit;

  //writeln('cUnknownWordError:',aName);
  SynError(cUnknownWordError, aName);
end;

function T-->Grammar<--.AddConstCFA(const aName: String): Boolean;
var
  p: Pointer;
  i : Integer;
begin
  i := FindConst(aName);
  Result := i >= 0;
  if Result  then
    with FConsts[i] do
    begin
      if Size <= SizeOf(Integer) then
      begin
        //FModule.AddOpToMem(opPushInt);
        //Size := SizeOf(Integer);
        Case Size of
          SizeOf(Byte): FModule.AddOpToMem(opPushByte);
          SizeOf(Word): FModule.AddOpToMem(opPushWord);
          //SizeOf(tsInt): FModule.AddOpToMem(opPushInt);
          //SizeOf(Int64): FModule.AddOpToMem(opPushInt64);
          else 
          begin
            FModule.AddOpToMem(opPushInt);
            Size := SizeOf(tsInt);
          end;
        end;//case
      end
      else
        FModule.AddOpToMem(opPushInt64);
      Integer(p) := Integer(FModule.Memory) + FModule.UsedMemory;
      FModule.AllocSpace(Size);
      AssignValueTo(p);
    end
end;

function T-->Grammar<--.AddVarCFA(const aName: String): Boolean;
var
  i: Integer;
begin
  i := FindVar(aName);
  Result := i >= 0;
  if Result then
    with FVars[i] do
    begin
      FModule.AddOpToMem(opPushInt);
      FModule.AddIntToMem(Addr);
    end
end;

procedure T-->Grammar<--.PushWordParam(const aValue: string);
begin
  if aValue = '' then exit;
  if (Length(aValue) >= 2) and (aValue[1] = '''') then
  begin
    // it's a string
    PushString(aValue);
  end
  else if StrIsInteger(aValue) then
  begin
    PushInt32(aValue);
  end
  else //暂时不支持内嵌参数的word
    AddIdentifierCFA(aValue, nil);
end;

function T-->Grammar<--.AddWordCFA(aName: string; const aParams: TStringList): Boolean;
var
  i: Integer;
begin
  Result := False;
  i := FindWord(aName);
  if i >= 0 then with FWords[i] do
  begin
    if Assigned(aParams) then
    begin
      //push the parameters
      for i := aParams.Count - 1 downto 0 do
      begin
        PushWordParam(aParams[i]);
      end;
    end;
    case Options.CodeFieldStyle of
      cfsFunction:
      begin
        if Options.Visibility < fvProtected then
        begin
          FModule.AddOpToMem(opEnter);
          FModule.AddIntToMem(CFA);
        end
        else
        begin
          FModule.AddOpToMem(opEnterFar);
          FModule.AddIntToMem(0);
          FModule.AddIntToMem(CFA);
        end;
        Result := True;
      end;
      cfsExternalFunction:
      begin
        case Options.CallStyle of
          csForth:
          begin
            if Assigned(Module) then
            begin
              if ExternalOptions.Name <> '' then aName := ExternalOptions.Name;
              i := Module.GetWordCFA(aName);
              if i <> -1 then
              begin
                FModule.AddOpToMem(opCallFar);
                //writeln(aName, '.ModEntry:',Integer(FUsedModules[ModuleIndex].Entry));
                //point to the TurboModuleInfo
                FModule.AddIntToMem(Integer(FUsedModules[ModuleIndex].Entry)+SizeOf(Pointer)-Integer(FModule.DataMemory));
                FModule.AddIntToMem(i);
                //writeln(aName, '.CFA:',i);
                Result := True;
              end
              else
                SynError(cWordNotFoundError, '"'+ aName + '" CFA not in ' + FUsedModules[ModuleIndex].Name);
            end
            else
              SynError(cWordNotFoundError, '"'+ aName + '" not in ' + FUsedModules[ModuleIndex].Name);
          end;
        end; //case
      end;
    end;//case
  end;
end;

function T-->Grammar<--.IsUniqueIdentifier(const aName: String): Boolean;
begin
  //writeln('IsUniqueIdentifier:', aName);
  Result := FindConst(aName) < 0;
  //writeln('C:',Result);
  if Result then
    Result := FindVar(aName)< 0;
  //writeln('V:',Result);
  if Result then
    Result := FindWord(aName) < 0;
  //writeln('W:',Result);
  if not Result then
  begin
    writeln('RedeclarationError:',aName);
    SynError(cRedeclarationError);
  end;
end;

function T-->Grammar<--.GetConstValueRec(const aTypeKind: TTurboSimpleTypeKind; const aName: String): TTurboValueRec;
var
  i: Integer;
begin
  for i := 0 to Length(FConsts) do 
    with FConsts[i] do
    if (aName = Name) and (aTypeKind = TypeKind) then
    begin
      Result := Value;
      exit;
    end;
  SynError(cUnknownWordError, aName);
end;

function T-->Grammar<--.DefineLabel(const aName: string; const aWordName: string): Integer;
begin
    Result := Length(FLabels);
    SetLength(FLabels, Result+1);
    with FLabels[Result] do
    begin
      Name := aName;
      WordName := aWordName;
      Addr := FModule.UsedMemory;
    end;
end;

function T-->Grammar<--.DefineLabelEx(const aName: string; const aWordName: string): Integer;
begin
  Result := FindLabel(aName, aWordName);
  if Result = -1 then
  begin
    Result := DefineLabel(aName, aWordName);
  end
  else 
    SynError(cLabelRedeclarationError);

end;

function T-->Grammar<--.DefineConstEx(const aValue: TTurboSimpleConst): Integer;
begin
  //WriteLn('ConstDefine:', aValue.Name);
  Result := FindConst(aValue.Name);
  if Result = -1 then
  begin
    Result := DefineConst(aValue);
  end
  else 
    SynError(cConstRedeclarationError);
end;

function T-->Grammar<--.DefineConst(const aValue: TTurboSimpleConst): Integer;
begin
  Result := Length(FConsts);
  SetLength(FConsts, Result+1);
  FConsts[Result] := aValue;
  with FConsts[Result] do
  begin
    //Name := aValue.Name;
    SaveString(FModule); //if this is string 
  end;
end;

function T-->Grammar<--.FindConst(const aName: String): Integer;
begin
  for Result := 0 to Length(FConsts)-1 do
  begin
    //WriteLn(aName,'=', FConsts[Result].Name);
    if aName = FConsts[Result].Name then exit;
  end;
  Result := -1;
end;

function T-->Grammar<--.FindVar(const aName: String): Integer;
begin
  for Result := 0 to Length(FVars)-1 do
  begin
    //if aName = 'Add' then 
    //WriteLn(Result, ':FV:',FVars[Result].Name);
    if aName = FVars[Result].Name then exit;
  end;
  Result := -1;
end;

function T-->Grammar<--.DefineVar(const aValue: TTurboSimpleVar): Integer;
var
  vVaraibleEntry: PTurboVariableEntry;
  vValue: Pointer;
  //vTypeSize: Integer;
begin
  //在前面已经判断了是不是名称重复：
  Result := Length(FVars);
  SetLength(FVars, Result+1);
  FVars[Result] := aValue;
  with FVars[Result] do
  begin
    //WriteLn(Result, ':DefineVar:',Name);
    //Name := aValue.Name; //保证让其ref增加
    //FModule.AligData;
    //vTypeSize := GetSimpleTurboTypeSize(aValue.TypeKind);
    //Size := vTypeSize;
    //WriteLn(Name,'.Visibility=', Integer(Visibility));
    //WriteLn(Name,'.Size=', Size);

    if Visibility >= fvProtected then
    begin
      //FModule.AligData;
      Integer(vVaraibleEntry) := Integer(FModule.DataMemory) + FModule.UsedDataSize;
      FModule.AllocDataSpace(SizeOf(TTurboVariableEntry));
      vVaraibleEntry.Prior := FModule.LastVariableEntry;
      vVaraibleEntry.Variable.Size := Size;
      vVaraibleEntry.Variable.Addr := nil;
      vVaraibleEntry.Variable.TypeInfo := nil;
      //FModule.AddIntToData(Integer(FModule.LastVariableEntry));
      //FModule.AddIntToData(Size);
      //FModule.AddIntToData(0); //preserved.for addr.
      //FModule.AddIntToData(0); //preserved.for TypeInfo.
    end;
  
    if (TypeKind in cReqAlignMemTypes) then FModule.AlignData;
    Addr := FModule.UsedDataSize;
    if Visibility >= fvProtected then
    begin
      Integer(vVaraibleEntry.Variable.Addr) := Addr;
      FModule.LastVariableEntry := Pointer(Integer(vVaraibleEntry) - Integer(FModule.DataMemory));
    end;
    Integer(vValue) := Integer(FModule.DataMemory)  + Addr;
    FModule.AllocDataSpace(Size);
    if ValueStr <> '' then
    begin
      SaveString(FModule); //if this is string 
      AssignValueTo(vValue);
    end;

      if Visibility >= fvPublished then
      begin
        vVaraibleEntry.Variable.Name := Pointer(FModule.UsedDataSize);
        //fill the variable name 
        //FModule.AddByteToData(Length(Name));
        FModule.AddBufferToData(Name[1], Length(Name));
        FModule.AddByteToData(0);
      end
      else if Visibility >= fvProtected then
      begin
        //no name
        //FModule.AddByteToData(0);
        vVaraibleEntry.Variable.Name := nil;
      end;
  end;

  //SetLength(FVars, Length(FVars) + 1);
  //FindVar('');
end;

function T-->Grammar<--.DefineWordBegin(var aWord: TTurboSimpleWord): Boolean;
var
  i: Integer;
begin
  //WriteLn('DefineWordBegin:',aWord.Name);
  //FindVar('');
  Result := IsUniqueIdentifier(aWord.Name);
  if Result then
  begin
    //writeln('FModule.UsedDataSize=',InttoHex(FModule.UsedDataSize,4));
    FModule.AlignData;
    //writeln('FModule.UsedDataSize=',InttoHex(FModule.UsedDataSize,4));
    Integer(FDefinedWordEntry) := Integer(FModule.DataMemory) + FModule.UsedDataSize;
    FModule.AllocDataSpace(SizeOf(TTurboMethodEntry));
    FDefinedWordEntry.Prior := FModule.LastWordEntry;
    //FModule.AddIntToData(tsInt(FModule.LastWordEntry));
    //FModule.AllocDataSpace(SizeOf(TTurboWordOptions));
    //FModule.AllocDataSpace(SizeOf(LongWord)); //the ParamFieldLength
    //FModule.AllocDataSpace(SizeOf(Integer)); //the CFA
    if aWord.Options.Visibility >= fvProtected then
    begin
      FDefinedWordEntry.Word.Name := Pointer(FModule.UsedDataSize);
      //FModule.AddByteToData(Length(aWord.Name));
      FModule.AddBufferToData(aWord.Name[1], Length(aWord.Name));
      FModule.AddByteToData(0);
    end
    else
    begin
      //FModule.AddByteToData(0);
      FDefinedWordEntry.Word.Name := nil;
    end;
    FLastWordCfa := FModule.UsedMemory;
    FDefinedWordEntry.Word.CFA := FLastWordCfa;
    aWord.CFA := FLastWordCfa;
    FDefinedWordEntry.Word.Visibility := aWord.Options.Visibility;
    FDefinedWordEntry.Word.CallStyle := aWord.Options.CallStyle;
    FDefinedWordEntry.Word.CodeFieldStyle := aWord.Options.CodeFieldStyle;

    i := Length(FWords);
    SetLength(FWords, i+1);
    FWords[i] := aWord;
  end
  //else FLastWordCfa := 0;
end;

procedure T-->Grammar<--.DefineWordEnd();
var
  vPrior: PTurboMethodEntry;
begin
  if FDefinedWordEntry.Word.Visibility >= fvProtected then
    FModule.AddOpToMem(opExitFar)
  else
    FModule.AddOpToMem(opExit);
  FDefinedWordEntry.Word.ParamFieldLength := FModule.UsedMemory - FLastWordCfa + 1;
  FWords[Length(FWords)-1].ParamFieldLength := FDefinedWordEntry.Word.ParamFieldLength;

  //vPrior := FModule.LastWordEntry;
  FModule.LastWordEntry := Pointer(Integer(FDefinedWordEntry) - Integer(FModule.DataMemory));
  //writeln('dWerdE.Last:',tsInt(FModule.LastWordEntry));
  //FDefinedWordEntry.Prior := vPrior;
end;

function T-->Grammar<--.FindWord(const aName: String): Integer;
begin
  for Result := 0 to Length(FWords)-1 do
  begin
    if AnsiSameText(aName, FWords[Result].Name) then exit;
  end;
  Result := -1;
end;

procedure T-->Grammar<--.GenerateModuleEntryForWord(var aWord: TTurboSimpleWord);
var
  i: Integer;
begin
  if aWord.ModuleName <> '' then
  begin
    i := FindModule(aWord.ModuleName, aWord.ModuleType);
    //WriteLn('GenerateModuleEntryForWord:', aWord.ModuleName);
    if i < 0 then i := AddUsedModule(aWord.ModuleName, aWord.ModuleType);
    if i >= 0 then
    begin
      aWord.ExternalOptions.ModuleRef := Pointer(Integer(FUsedModules[i].Entry) + SizeOf(Pointer));
      aWord.ModuleIndex := i;
      aWord.Module := FUsedModules[i].Module;
    end;
  end
  else with aWord.ExternalOptions do 
  begin
    if FModule.LastModuleRefEntry <> nil then
    begin
      ModuleRef := Pointer(Integer(FModule.LastModuleRefEntry) + SizeOf(Pointer));
    end
    else 
      SynError(cDLLModuleMissError, aWord.Name);
  end;
end;

function  T-->Grammar<--.AddUsedModule(const aName: String; aModuleType: TTurboModuleType): Integer;
var
  vModule: TCustomTurboModule;
begin
  //WriteLn('AddUsedModule:', aName);
  Result := -1;
  if aModuleType = mtLib then
  begin
    vModule := FModule.RequireModule(PChar(aName));
    if vModule = nil then
    begin
      SynError(cFileNotFoundError, aName);
      exit;
    end;
  end;
  Result := Length(FUsedModules);
  SetLength(FUsedModules, Result+1);
  with FUsedModules[Result] do
  begin
    Name := aName;
    ModuleType := aModuleType;
    if aModuleType = mtLib then Module := vModule else Module := nil;
    with FModule do 
    begin
      Integer(Entry) := Integer(DataMemory) + UsedDataSize; //the offset address.
      AllocDataSpace(SizeOf(TTurboModuleRefEntry));
      Entry.Prior := LastModuleRefEntry;
      Entry.Module.ModuleType := aModuleType;
      Entry.Module.Revision := vModule.ModuleVersion;
      Entry.Module.BuildDate := vModule.ModuleDate;
      //AddIntToData(tsInt(LastModuleRefEntry));
      //AddByteToData(Byte(aModuleType));
      //AddIntToData(0); //preserved for Module: Pointer
      //AllocDataSpace(SizeOf(LongWord)); //Revision
      //AllocDataSpace(SizeOf(TTimeStamp)); //BuildDate
      Entry.Module.Name := Pointer(UsedDataSize);
      //AddByteToData(Length(aName));
      if Length(aName) > 0 then
        AddBufferToData(aName[1], Length(aName));
      AddByteToData(0);
      LastModuleRefEntry := Pointer(tsInt(Entry) - Integer(DataMemory));
    end;
  end;
end;

function T-->Grammar<--.FindLabel(const aName: string; const aWordName: string): Integer;
begin
  for Result := 0 to length(FLabels) -1 do
  begin
    if (aName = FLabels[Result].Name) and (aWordName = FLabels[Result].WordName) then
    begin
      exit;
    end;
  end;
  Result := -1;
end;

function T-->Grammar<--.FindModule(const aName: String; aModuleType: TTurboModuleType): Integer;
begin
  for Result := 0 to Length(FUsedModules)-1 do
  begin
    if AnsiSameText(aName, FUsedModules[Result].Name) and (aModuleType = FUsedModules[Result].ModuleType) then exit;
  end;
  Result := -1;
end;

procedure T-->Grammar<--.Init;
begin
  with FModule do
  begin
    ClearMemory;
    if MemorySize < cMaxMemorySize then
      MemorySize := cMaxMemorySize;
    Status := [psCompiling];
  end;
  SetLength(FLabels, 0);
  SetLength(FConsts, 0);
  SetLength(FVars, 0);
  SetLength(FWords, 0);
  SetLength(FUsedModules, 0);
  //writeln('SourceFileName=', SourceFileName);
  FileName := ExtractFileBaseName(SourceFileName) + cTurboCompiledProgramFileExt;
  //writeln('FileName=', FileName);
end;

procedure T-->Grammar<--.Final;
var
  vStream: TFileStream;
begin
  //writeln('Final');
  if ErrorList.Count = 0 then
  begin
   //writeln('No error');
    //WriteStrLn('The Result: '+FloatToStr(fResult));
    if FileName <> '' then
    begin
      FModule.IsLoaded := True;
      //writeln('InitProcCFA=', FInitProcCFA+SizeOf(TTurboModuleStreamHeader));
      with PTurboPreservedDataMemory(FModule.DataMemory)^ do
      begin
        Integer(InitializeProc) := FInitProcCFA;
      end;
      if LowerCase(ExtractFileExt(FileName)) <> cTurboCompiledProgramFileExt then
        FileName := ChangeFileExt(FileName, cTurboCompiledProgramFileExt);
      vStream := TFileStream.Create(FileName, fmCreate);
      try
        writeln('saving to ' + FileName);
        FModule.SaveToStream(vStream);
      finally
        vStream.Free;
      end;
    end;
  end;
  FModule.ClearMemory;
  SetLength(FLabels, 0);
  SetLength(FConsts, 0);
  SetLength(FVars, 0);
  SetLength(FWords, 0);
  SetLength(FUsedModules, 0);
end;

procedure T-->Grammar<--.PushInt32(const aInt: tsInt);
begin
  FModule.AddOpToMem(opPushInt);
  FModule.AddIntToMem(aInt);
end;

procedure T-->Grammar<--.PushInt32(const aStr: string);
begin
  try
    PushInt32(StrToInt(aStr));
  except
    SynError(cStrToIntCovnertError, aStr);
  end;
end;

procedure T-->Grammar<--.PushString(const aStr: string);
var
  vConst: TTurboSimpleConst;
  p: Pointer;
begin
  if vConst.AssignValue(aStr) then
  begin
    vConst.SaveString(FModule); //if this is string 
    FModule.AddOpToMem(opPushInt);
    Integer(p) := Integer(FModule.Memory) + FModule.UsedMemory;
    FModule.AllocSpace(SizeOf(Pointer));
    vConst.AssignValueTo(p);
  end
  else
    SynError(cConstRedeclarationError, 'Invalid String:'+ aStr);
end;

procedure T-->Grammar<--.PushStringSeqToStack(const aStr: string);
var
  s: string;
  i: Integer;
begin
  s := AnsiDequotedStr(aStr, '''');
  for i := length(s) downto 1 do
  begin
    FModule.AddOpToMem(opPushInt);
    FModule.AddIntToMem(Ord(s[i])); 
  end;
end;

procedure T-->Grammar<--.WriteStrLn(S : string);
begin
  WriteStr(s+#13#10); 
end;

procedure T-->Grammar<--.WriteStr(S : string);
begin
  ListStream.WriteBuffer(S[1],length(S));
end;



IGNORE CASE

CHARACTERS
 LETTER="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_".
 DIGIT =  "0123456789".
 CTRL=CHR(1)..CHR(31).
 SpecialChar = "*,()%:".
 TAB=CHR(9).
 EOL=CHR(13).
 LF=CHR(10).
 noQuote = ANY - "'" .
 noDblQuote = ANY - '"' .               
 noEOL = ANY - EOL .
 HexDigit = "0123456789ABCDEF" .

TOKENS
 Identifier = LETTER {LETTER|DIGIT}.
 IntegerToken = DIGIT {DIGIT} | DIGIT {DIGIT} CONTEXT ( ".." ).
 HexNumberToken = "$" HexDigit {HexDigit}.
 FloatToken = DIGIT {DIGIT} "." DIGIT {DIGIT} ["E" ["+" |"-"] DIGIT {DIGIT}].
 StringToken   = "'" { noQuote | "'" "'" } "'" .

NAMES


IGNORE TAB+EOL+LF

PRAGMAS
   //CompilerDirective DESCRIPTION "TurboScript Assembler Compiler Directive" 
     // = "[$" { noEOL } "]". (. Writeln('SDDSSDL:'+ LexString); .) //古怪得很，LexString 取得的值是上一个标识的，而不是这个CompilerDirective的！

//COMMENTS FROM "(" TO ")"
COMMENTS FROM "//" TO EOL
COMMENTS FROM "{" TO "}"



PRODUCTIONS

  (* TurboForthCompiler = Statement {Statement}  . *)  
  TurboForthCompiler DESCRIPTION "TurboScript Assembler Compiler"
    =                                                  (. Init ; .)  


    ( "PROGRAM"                                        (. FModule.ModuleType := mtProgram; .)
      |"UNIT"                                          (. FModule.ModuleType := mtLib; .) 
    )
    Identifier                                         (. FModule.Name := LexString; .)
    [DeclarationBlock]  
    "BEGIN"                                            (. FInitProcCFA := FModule.UsedMemory;  .)
    ASMStatementBlock
    "END."                                             (. FModule.AddOpToMem(opPushInt); FModule.AddIntToMem(0); FModule.AddOpToMem(opHalt); .)
    (. Final ; .) .

   DeclarationBlock 
    = 
    Declaration {Declaration}.

  Declaration = DefineConstPart| DefineVarPart | DefineWord .

  DefineConstPart
    =
    "CONST" DefineConstant {DefineConstant} 
  .

  DefineConstant
    (.Var vValue: TTurboSimpleConst; .) 
    = 
    Identifier (. vValue.Name := LexString; vValue.TypeKind := ttkUnknown; .) 
    [":" TypeKind<vValue.TypeKind> ]
    "=" Value<vValue> 
    ";" (. if IsUniqueIdentifier(vValue.Name) then DefineConstEx(vValue); .) .

  DefineVarPart
    = 
    "VAR" DefineVariable {DefineVariable}
  .

  DefineVariable
    (.Var vValue: TTurboSimpleVar; .)
    =  (. vValue.Visibility := fvPrivate;vValue.ValueStr := ''; .)
    [WordVsibility<vValue.Visibility>] Identifier (. vValue.Name := LexString; .)
    ":" TypeKind<vValue.TypeKind> (.vValue.SetTypeKind(vValue.TypeKind); .)
    ["=" Value<vValue>]
    ";" (. if IsUniqueIdentifier(vValue.Name) then DefineVar(vValue); .)
  .

  TypeKind<var aType: TTurboSimpleTypeKind> 
    =
    IntegerType <aType>
    |StringType <aType>
  .

  IntegerType<var aSubType: TTurboSimpleTypeKind>
    =
    "BYTE"                                            (. aSubType := ttkUByte; .)
    |"WORD"                                           (. aSubType := ttkUWord; .)
    |"DWORD"                                          (. aSubType := ttkULong; .)
    |"INTEGER"                                        (. aSubType := ttkSLong; .)
    |"QWORD"                                          (. aSubType := ttkQWord; .)
    |"INT64"                                          (. aSubType := ttkInt64; .)
  .
  StringType<var aSubType: TTurboSimpleTypeKind>
    =
    "STRING"                                          (. aSubType := ttkLString; .)
    |"SHORTSTRING"                                    (. aSubType := ttkString; .)
  .

  Value< var aValue: TTurboSimpleConst >
    = 
    (StringToken|IntegerToken|HexNumberToken)           (. aValue.AssignValue(LexString, aValue.TypeKind); .)
//    |Identifier                                       (. aValue.Value := GetConstValueRec(aValue.TypeKind, LexString); .)
  .

  DefineWord (. Var vSucc: Boolean; vWord: TTurboSimpleWord; .)
    = 
                                                                 (. vWord.Options.Visibility := fvPrivate; 
                                                                    vWord.Options.CallStyle := csForth;
                                                                    vWord.Options.CodeFieldStyle := cfsFunction;
                                                                 .)
    ":" [WordVsibility<vWord.Options.Visibility>] Identifier     (. vWord.Name := LexString; .)
    
    [
    ExternalWordOption<vWord>                                    (. GenerateModuleEntryForWord(vWord); .)
    ]
                                                                 (.vSucc := DefineWordBegin(vWord);  .)
    [ASMStatementBlock]
    ";"                                                          (. if vSucc and (vWord.Options.CodeFieldStyle = cfsFunction) then DefineWordEnd(); .)
  .
  ExternalWordOption< var aWord: TTurboSimpleWord >
    = 
    //the default is the LastModuleRefEntry if no the module name.
                                                            (. aWord.ModuleName := ''; 
                                                               aWord.ExternalOptions.Name := '';
                                                            .)
    "EXTERNAL"                                              (. aWord.Options.CodeFieldStyle := cfsExternalFunction; .)
    [
      StringToken                                           (.aWord.ModuleName := AnsiDequotedStr(LexString, '''');
                                                              aWord.ModuleType := mtLib; .)  //the default module Type is mtLib
      [ModuleType<aWord.ModuleType>]
    ]
    [
      "STDCALL"                (. aWord.Options.CallStyle := csStdCall; .)
       |"REGISTER"             (. aWord.Options.CallStyle := csRegister; .)
       |"PASCAL"               (. aWord.Options.CallStyle := csPascal; .)
       |"FORTH"                (. aWord.Options.CallStyle := csForth; .)
       ExternalWordOptionPart<aWord.ExternalOptions>
    ]
  .
  ModuleType< var aType: TTurboModuleType >
    =
    "LIB"                                                  (. aType := mtLib;  .)
    |"DLL"                                                 (. aType := mtDLL;  .)
    |"HOST"                                                (. aType := mtHost; .)
  .
  ExternalWordOptionPart < var aOptions: TTurboExteralMethodOptions >
    =
   ["Name" StringToken (. aOptions.Name := AnsiDequotedStr(LexString, ''''); .) ]
   ["Index" IntegerToken (. aOptions.Index := StrToInt(LexString); .)]
  .
  WordVsibility< var aVisibility: TTurboVisibility > 
    = 
    "HIDDEN"                                           (. aVisibility := fvHidden; .)
    |"PRIVATE"                                         (. aVisibility := fvPrivate; .)
    |"PROTECTED"                                       (. aVisibility := fvProtected; .)
    |"PUBLIC"                                          (. aVisibility := fvPublic; .)
    |"PUBLISHED"                                       (. aVisibility := fvPublished; .)
  .

  ASMStatementBlock 
    = 
    ASMStatement {ASMStatement}
    .

  ASMStatement 
    = 
    [LabelDeclaration]
     PushIntAsmStatement
    | PushStringAsmStatement 
    | AddIntAsmStatement
    | "i8+" (.FModule.AddOpToMem(opAddInt64); .)
    | SubIntAsmStatement
    | "i8-" (.FModule.AddOpToMem(opSubInt64); .)
    | MulIntAsmStatement
    | "!" (. FModule.AddOpToMem(opStoreInt); .)
    | "!i8" (. FModule.AddOpToMem(opStoreInt64); .)
    | "!i2" (. FModule.AddOpToMem(opStoreWord); .)
    | "!i1" (. FModule.AddOpToMem(opStoreByte); .)
    | "@" (. FModule.AddOpToMem(opFetchInt); .)
    | "@i8" (. FModule.AddOpToMem(opFetchInt64); .)
    | "@i2" (. FModule.AddOpToMem(opFetchWord); .)
    | "@i1" (. FModule.AddOpToMem(opFetchByte); .)
    | "DROP" (. FModule.AddOpToMem(opPopInt); .)
    | EmitAsmStatement
    | "@TICK" (. FModule.AddOpToMem(opGetTickCount); .)
    | "!TICK" (. FModule.AddOpToMem(opStoreTickCount); .)
    | "NOOP"  (. FModule.AddOpToMem(opNoop); .)
    | AssertStatement
    | WordAsmStatement
  .

  LabelDeclaration =
    "Label" Identifier   (. DefineLabelEx(LexString); .)  .

  PushIntAsmStatement = 
    ( IntegerToken|HexNumberToken ) (. PushInt32(LexString); .) .
  AddIntAsmStatement  = "+" (. FModule.AddOpToMem(opAddInt); .) .
  SubIntAsmStatement  = "-" (. FModule.AddOpToMem(opSubInt); .) .
  MulIntAsmStatement  = "*" (. FModule.AddOpToMem(opMulInt); .) .
  EmitAsmStatement 
    = 
    "EMIT" (. FModule.AddOpToMem(opEmit); .) 
    | ".S" (. FModule.AddOpToMem(opEmitString); .) 
    | ".LS" (. FModule.AddOpToMem(opEmitLString); .) 
  .

  PushStringAsmStatement = "#" StringToken (. PushStringSeqToStack(LexString); .) .

  WordAsmStatement 
    (.Var vName: string; vParams: TStringList; .)
    =
    (.vParams := nil; .)
      Identifier 
      (. vName := LexString;  //Writeln('pARSER word param::');
    try .)
      [(. vParams := TStringList.Create; .) WordParams<vParams>  ]
      (. 
      //writeln('EndParams');
      AddIdentifierCFA(vName, vParams);
      //if Assigned(vParams) then writeln(vName, ' WordParams:', vParams.CommaText) else writeln(vName, ' Not Assigned Params');
      //writeln('sym:',LexString);
    finally
      FreeAndNil(vParams);
    end; .)
  .
  WordParams< const aParams: TStringList >
    (. var vParam: string; .)
    =
    "("
    [ WordParam< vParam > (. aParams.Add(vParam); .)
    {"," WordParam< vParam > (. aParams.Add(vParam); .) } ]
    ")"
  .
  WordParam< var aParam: string >
    =
    ( IntegerToken|HexNumberToken|Identifier|StringToken ) (. aParam := LexString; .)
  .
  AssertStatement
    (. var vExpr: string; vMsg: string; .)
    =
    "ASSERT(" WordParam< vExpr > "," WordParam< vMsg > ")"
    (. if soAssertSupport in FModule.Options then
       begin
         //the current line No. 由于暂时没实现IntToStr以及StrConcat,所以 现在只压入2个参数
         //WriteLn('AddAssert at ', TCocoRScannerAccess(Scanner).CurrLine);
         vMsg := '''Assert failed at line:'+IntToStr(TCocoRScannerAccess(Scanner).CurrentSymbol.line)+'. '''+ vMsg+ '''''';
         //PushInt32(TCocoRScannerAccess(Scanner).CurrLine);
         PushString(vMsg);
         PushWordParam(vExpr);
         FModule.AddOpToMem(opAssert);
       end;
    .)
  .
    


END TurboForthCompiler.
