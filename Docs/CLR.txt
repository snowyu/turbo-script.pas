CIR(Common Intermediate Language (CIL))分析

数据栈：
它称之为 evaluation stack， 数据栈存放数据的最小单位是4字节的32位整数。

它的加法指令只有一种形式，这说明它的加法指令的数据类型是后期约束的，不过这样一来，构成加法的指令的数据必须要有数据类型了！
CLR 比我多了一个参数表用于传递过程的参数。

== 模块(Module) ==
模块(Module)类似于以前的单元，用于分割不同的类和类型，以及资源(resource, 资源记录就是字符串，图象以及其它数据，他们只在需要的时候才会被调入内存)。类型的Meta信息也是模块的一部分。
CLR 的程序集是由模块构成的，CLR 模块是一种流数据（字节流），通常是以文件的形式存在于本地文件系统或Web服务器上。

既然模块种包含类型的Meta信息，类型检查系统就可以联合静态和动态技术。当IL运行的时候，执行环境能得知
所有变量参数的类型Meta信息，自然就能执行运行时刻的类型检查――这被称之为 reflection(它的含义为解释自描述类型，类型的影子)。

== 程序集(Assembly) ==
程序集(Assembly)本身就是一个模块，程序集(Assembly)和模块(Module)间的区别，在于多了一个维护清单 manifest 【描述引用了哪些程序集，包含了那些模块文件，导出了哪些类型（其它模块中的），以及对自身的描述】。

多个模块文件可以被链接成一个程序集(assembly)。在程序集上多了一个清单（manifest），用来描述该程序集以及模块的列表，一个主入口，导出的类型定义列表（私有模块中公开的类型）。这份清单被放在一个模块上，
在该模块上的公开的类型不会出现在导出类型定义列表上！

程序集是CLI发布管理(deployment managed)的单位。程序集是可重用的软件组件。程序集甚至能动态绑定调用代码。
  * 程序集是独立的软件组件子集，无须重新编译。
  * 程序集是定制软件
  * 程序集能被独立发布
  * 程序集导出的API能和其它组件完美的交互。

程序集在文件系统中是用PE(portable executable)格式存放。

Jeffer的书中说，清单元数据表中有一份名叫ExportedTypesDef的表，其中定义了所有的导出类型条目。但是我在查看单文件程序集的时候却没有发现元数据当中有ExportedTypes的定义。后来又仔细看了一下书才明白，为了节省文件空间，所以在元数据定义元数据表中所定义的导出类型是不会在ExportedTypesDef表中重复出来的。这也就是说，只有当一个程序集是由多个模块块文件组成的时候，其它模块文件中导出的类型才会在程序集清单中被定义。使用了这种定义方式。相当于在程序集清单中提供一个查找程序中所定义类型的索引。当CLR查找程序集中类型时，它会根据程序集清单 ExportdTypesDef表的定义，在相应的模块文件当中查找到需要的类型定义。

一个.net程序集支持三种版本，它都是使用特性的方式在源代当中指定的，然后由编译器/链接器将它们嵌入到.net程序当中（程序文件）。这三种版本号对应的特性名称和其作用如下所示：
AssemblyFileVersion：这个特性所标识的版本号对应传统Win32程序的文件版本号。CLR本身并不使用此版本号。
AssemblyInformation：这个特性所标识的版本号对应传统Win32程序的产品版本号。CLR本身并不使用此版本号。
AssemblyVersion：这个特性标识的版本号为CLR本身所识别的版本号，CLR通过这个版本号来确定程序集的版本。
这里需要注意的是，AssemblyFileVersion的build位和fix位应该是一个第次重新编译后都有所不同的版本号，程序的用户暨以此版本号来区分一个主版本号(由Major和Minor组成的版本号）内程序集的不同。
而AssemblyVersion版本号则是应该在一个主版本号内固定不变的，因为CLR是使用此版本号来确定加载程序集的。

== AppDomain和地址空间 ==

一个程序集将被加载到一个Application Domain(AppDomain)中执行？ 外部引用的其它程序集将在同样同一AppDomain下运行。
换句话说，AppDomain 将程序集聚集在一起，实现最终功能。
每一个AppDomain定义了一个由CLI执行引擎管理的地址空间。所有的地址引用将确保实在同一个AppDomain中。
CLI地址空间是有层次的：AppDomain 能被加载入一个CLI地址空间。
CLI地址空间可以被概略的认为是OS中的进程地址空间（至少在Rotor CLI中是这样）。每一个地址空间都有明确的地址边界。

每一个CLI地址空间可以包含多个AppDomain： 其中一个AppDomain就是系统程序集，另一个AppDomain包含与其他与AppDomain共享的程序集。
只有CLI管理器(the supervision of the CLI)才能跨越AppDomain的地址空间访问进行交互。AppDomain之间的交互通讯是通过远程(Remoting)类型检查机制
完成。同样的机制被用于跨越地址空间，如接口和OS IPC.

模块，程序集，AppDomain和地址空间（address space）的关系是，模块是编译器建立的最小的单元文件，由一个或n个模块组成程序集，程序集是进行分发的
最小单元文件，程序集能组合在一个AppDomain下执行。多个AppDomain能在单个地址空间下执行。

【问】如果对其它程序集过程的调用，意味着需要开辟新的VirtualExecutionEngine?,堆栈这些全部都要新的？？

注：
Common Language Infrastructure (CLI) 通用语言基础组织

== Virtual Execution System(VES) ==
VES是CLI DVM(分布式虚拟机)的心脏。Execution Engine (EE) 则是其核心了，代码在 MSCOREE (Microsoft Common Object Runtime EE C a name that is left over from the commercial
CLR code) 中。
引用的程序集可以存在于任何地方，比如一台web服务器上，当EE被请求装载(Downloading)该程序集的时候，将会做一下的事情：
  检查调用者认证
  检查程序集是否有效
  一切搞定则将程序集装载到AppDomain
一旦程序集被加载到AppDomain,那么在AppDomain中的其它代码将能访问该程序集中的公开成员和字段，当然上在EE的监督下。
不过这时候，程序集中的类并没有被绑定到代码，只有当对该类的调用真的发生的时候，EE才会去查找在程序集中的目标类并将其
装载入AppDomain，然后校验访问许可，从该类的Meta信息中提取目标类的细节说明，然后Build an appropriate call table data structure.
当第一次引用类成员的时候，它的形式还是中间代码，CLI 总是使用JIT编译器(JITter)将中间代码翻译成本地机器码，然后当下次再次
引用的时候就会直接执行编译好的本地机器码。EE还包括了垃圾收集器和结构化异常处理器。

== Metadata ==
谈谈Metadata在PE中的组织结构。CLR的头信息里面专门有一个字段指向Metadata数据块，实际上这个数据块只是Metadata的一个头结构，
保存有Metadata的全局信息，而Metadata的实际数据，是通过若干不同的Heap或者说Stream保存的。这里我统一使用Stream流作为他
的名字，但很多文档中以Heap堆作为其称呼，我们可以理解他是一个二进制流，其中数据以堆的结构进行组织。在文件中是流，装入内存
后是堆。实际上就是俺的数据区。不过它分得更加细致。

Metadata里最常见的有五种流，#String, #Blob, #Guid,#US(User String)和#~流("#"是流名字的前缀)。每种类型流最多只能出现一次，
#US和#Blob流可省略。

#String流就是一个字符串堆，Metadata内部用到的所有字符串如类或方法的名字等等都以UTF8编码保存在此堆内。
而用户的字符串如字符串常量，则以Unicode编码保存在#US(User String)堆内。
值得注意的是，US流和String流在二进制结构组织上不同，我们后面将分析时会详细提及。

Guid流是保存程序中使用到的Guid的数组，如Assembly中Module的MVID。

Blob流是一个通用存储空间，除了Guid和字符串以外基本上所有剩下的东西都以二进制数据形式放在里面，如PublicKey，常量的值等等。
等效于我的数据区中分配的变量区。

最重要的是#~流，这是Metadata核心信息存放的地方。#~流物理上以若干张表(Table)的形式组织，每张表存储某一方面的Metadata信息，
如MethodDef表存储所有方法的信息。每张表又由若干的行(Row)组成每行有n个列(Column)，每列代表一种信息，如MethodDef表中每一行
都有一个方法的RVA,类型标志,名字,Signature等等信息。在其中通过各种索引来相互关联，整个组织结构和关系数据库很相似。

比较特殊的是，这里所有的表通过一个64bit的有效位图来表示表存在与否每种类型的表有一个编号，如MethodDef表的编号是6，则第(1<<(6-1))位置1
因而每个表的每一行，可以使用一个唯一的Token表示。此Token是一个32bit无符号整型数，最高一个字节表示表的序号，低三个字节表示表中的索引号。
如0x06000003表示0x06表（MethodDef）中第3行（如MyApp::Add）这个Token概念在CLR中频繁使用，如IL代码调用函数、使用变量都是使用Token。
与之类似的还有Coded Index，等会讲二进制实现时再说。


此篇笔记为现在的体会，我感觉比较浅薄，而且当中也应该会有一些错误。这些问题留待以对元数据有更深的理解后现进行修正。

1．  何为元数据

元数据是被嵌入到程序文件当中的一些描述信息，.Net PE文件中所定义到和所引用到的类型都会在元数据中有相应的描述。

2．  元数据有什么用途

以下这段话是Jeffery先生书里面的对元数据用途的精彩描述。

l         元数据省去了源代码编译时对头文件的依赖，这是因为在含有实现类型和成员的IL代码文件当中，已经包含了所有被引用的类型和成员的信息。编译器可以直接从托管模块中读取元数据来获得这些信息。

l         vs.net可以利用元数据来辅助我们编写代码。它的智能感知特性就是通过分析元数据来告诉我们某个类型提供了哪些方法，以及以这些方法有哪些参数。

l         CLR的代码验证过程可以利用元数据来确保代码仅执行“安全”的操作。

l         利用元数据，我们可以将一个对象的字段序列化到一个内存块中，然后远程传送给另一台机器，最后再在远程计算机上执行反序列化，从而重新创建对象和他的状态。

l         利用元数据，垃圾收集器要吧追踪对象的生存周期。对于任何对象，垃圾收集器都能够通过元数据来确定该对象的类型，并且可以获知该对象的哪些字段引用了其它的对象。

l          

3．  元数据种类

.Net中的元数据是由不同的数据表构成的。元数据表在.Net当中被分成为三类（每类有多个表），它们分别是，定义元数据表，引用元数据表还有清单元数据表。

定义元数据表是用来描述.Net Pe文件本身所定义的数据类型的。在我们程序当中的定义的类，结构等等一切的类型信息，最终都会出现在定义元数据表中。

引用数据表用来描述.Net Pe当中所引用到的外部类型。在我们程序当中引用的FCL类型、自定义类型（注1）以及第三方类型的定义都会出现在引用数据表内。

清单元数据表相对于定义元素元和引用元数据表来说，是一类比较特殊的元数据表，它的作用是用来描述程序集信息。程序集的理念很像是动态链接库，在程序集内部包含着很多的类型定义，在程序集的外部，一个程序员可以通过包含这个程序集的方式来使用这个程序所提供的资源。然而与动态链接库所不同的是，程序集中含有元数据（特别是清单数据），这也就使程序集成为了.Net平台实现解决版本冲突和简单部署中的重要基础。正是由于程序集的清单当中描述了程序集的版本，.Net平台才允许多个版本的程序集同时安装到同一台计算机上，并在执行程序时，根据程序所绑定的程序集版本来正确的装入程序集。

除了描述程序集的版本信息以后，程序集的清单元数据还会对程序集的其它一些定义信息进行描述。这些信息包括程序集中对模块或者其它文件的引用（一个程序集可以由多个模块或者其它的文件主成，但是在这个程序集中只有主文件才会包含清单）、程序集中包含的资源定义，还有程序集中导出类型的定义（我想这可能是为了方便CLR对程序集中导出类型的查找吧，毕竟一个程序集可以包含多个模块，如果没有一个汇总索引的话，在程序集当中查找到某一个特定类型的效率会受到较大的影响）。


以下是Jeffery先生对拖管代码优势的论述。

如果应用程序在一些新型的CPU（比如奔腾4）上运行，JIT编译器能够检测到这种情况，并产生利用这些新型CPU提供的特殊指令的本地代码。而非拖管应用程序通过被编译为面向具有最小通用功能集合的CPU平台，一般会避免使用新型CPU提供的特殊指令。而这些特殊指令往往会在较新的CPU上为应用程序带来很高的性能提升（前一段时间我还在程序员杂志上看到了intel吹捧使用它自己的C++编译器所编译出来的代码会在它自己生产的CPU上获得多么好的性能。其实Intel完全也可以为JIT来做这样的优化工作，不过这要看.Net平台本身是否留出了这种对JIT类似于插件式支持）。

JIT编译器能检测到正在运行的机器上某些总是返回错误的布尔测试。这样JIT就会将这类不会被执行的代码优化下去，以使代码量变的更小，执行速度变的更快（当我一开始读完这段的时候我对此并不相信，因为我感觉这是一种编译期的技术，一般的非拖管编译器也是可以实现它的，但是当我读完了下面一段后我的观念发生了转变）。

在应用程序运行时，CLR能够分析评估代码的执行情况，并有选择地重新将IL代码编译成为本地代码。根据观察到的执行模式，被编译的代码可以被重新组织以提高分支测试的成功率（这是一个多么令人兴份的技术啊，一种对代码在运行时智能化的分析与调整。这种技术类似于人工智能技术，因为它需要CLR根据运行时根据实际出现的情况来对代码进行调整，不过由于现在人工智能技术还在不断的发展过程中，而且其自身也并不完成熟，所以我想微软可能并不是使用一种智能性质的技术来完成这项工作的。一种可以想象的到，也可以理解的方式是微软将应用中的一些运行时调整方式归结成为“代码运行时调整模式库”，然后CLR再根据这个模式库在运行时对代码进行匹配和调整，在未来，微软可以不断的扩展和完状况这个模式库以使这种优化可以达到一种更好的效果）。

重读Jeffery先生的《.Net框架程序设计》这本书，发现他对.Net中某些关键元素的总结真的很值得读者回味。以下是Jeffer先生对元数据给.Net应用程序带来优势的总结。

元数据省去了源代码编译时对头文件的依赖，这是因为在含有实现类型和成员的IL代码文件当中，已经包含了所有被引用的类型和成员的信息。编译器可以直接从托管模块中读取元数据来获得这些信息。

vs.net可以利用元数据来辅助我们编写代码。它的智能感知特性就是通过分析元数据来告诉我们某个类型提供了哪些方法，以及以这些方法有哪些参数。

CLR的代码验证过程可以利用元数据来确保代码仅执行“安全”的操作。

利用元数据，我们可以将一个对象的字段序列化到一个内存块中，然后远程传送给另一台机器，最后再在远程计算机上执行反序列化，从而重新创建对象和他的状态（我想这里Jeffery先生可能指的是通过元数据可以获取到对象的布局，进而可以序列化它，而和远程不远程的没有什么关系）。

利用元数据，垃圾收集器要吧追踪对象的生存周期。对于任何对象，垃圾收集器都能够通过元数据来确定该对象的类型，并且可以获知该对象的哪些字段引用了其它的对象（美妙的元数据）。

CIL Instructions
_________________________________________________
Format                Assembly Format   Description
0x00                  nop
0x01                  break             断点设置，我这里用作halt.
0x02                  ldarg.0           load argument onto the stack
0x03                  ldarg.1
0x04                  ldarg.2
0x05                  ldarg.3
0x06                  ldloc.0           load local variable onto the stack
0x07                  ldloc.1
0x08                  ldloc.2
0x09                  ldloc.3
0x0A                  stloc.0
0x0B                  stloc.1
0x0C                  stloc.2
0x0D                  stloc.3
0x0E                  ldarg.s num       Load argument numbered num onto the stack, short form.
0x0F                  ldarga.s argNum   Fetch the address of argument argNum, short form.
0x10                  starg.s num       Store value to the argument numbered num, short form.
0x11<unsigned int8>   ldloc.s indx      Load local variable of index indx onto stack, short form.
0x12<unsigned int8>   ldloca.s indx     Load address of local variable with index indx, short form.
0x13<unsigned int8>   stloc.s indx      Pop a value from stack into local variable indx, short form.
0x14                  ldnull            Push a null reference on the stack.
                                        [It might be thought that ldnull is redundant: why not use ldc.i4.0 or ldc.i8.0 instead? The answer is
                                        that ldnull provides a size-agnostic null C analogous to an ldc.i instruction, which does not exist. However,
                                        even if CIL were to include an ldc.i instruction it would still benefit verification algorithms to retain the ldnull
                                        instruction because it makes type tracking easier. ]
                                          ldc.<type>: load numeric constant
0x15                  ldc.i4.m1           Push -1 onto the stack as int32.
0x15                  ldc.i4.M1           Push -1 of type int32 onto the stack as int32 (alias for ldc.i4.m1).
0x16                  ldc.i4.0            Push 0 onto the stack as int32.
0x17                  ldc.i4.1
0x18                  ldc.i4.2
0x19                  ldc.i4.3
0x1A                  ldc.i4.4
0x1B                  ldc.i4.5
0x1C                  ldc.i4.6
0x1D                  ldc.i4.7
0x1E                  ldc.i4.8
0x1F<int8>            ldc.i4.s num        Push num onto the stack as int32, short form.
0x20<int32>           ldc.i4 num          Push num of type int32 onto the stack as int32.
0x21<int64>           ldc.i8 num          Push num of type int64 onto the stack as int64.
0x22<float32>         ldc.r4 num          Push num of type float32 onto the stack as F.
0x23<float64>         ldc.r8 num          Push num of type float64 onto the stack as F.
0x25                  Dup                 Duplicate the value on the top of the stack.
0x26                  pop                 remove the top element of the stack
0x27<T>               jmp method          Exit current method and jump to the specified method.
0x28<T>               call method         Call method described by method.
0x29<T>               calli callsitedescr Call method indicated on the stack with arguments described by callsitedescr.
0x2A                  Ret                 Return from method, possibly with a value.
0x2B<int8>            br.s target         Branch to target, short form. <unconditional branch>
0x2C<int8>            brfalse.s target    Branch to target if value is zero (false), short form.
0x2D<int8>            brtrue.s target     Branch to target if value is non-zero (true), short form.
0x2E<int8>            beq.s target        Branch to target if equal, short form.
0x2F<int8>            bge.s target        Branch to target if greater than or equal to, short form.
0x30<int8>            bgt.s target        Branch to target if greater than, short form.
0x31<int8>            ble.s target        Branch to target if less than or equal to, short form.
0x32<int8>            blt.s target        Branch to target if less than, short form.
0x33<int8>            bne.un.s target     Branch to target if unequal or unordered, short form.
                                          The bne.un instruction transfers control to target if value1 is not equal to value2, when compared unsigned
                                          (for integer values) or unordered (for floating-point values).
                                          The effect is identical to performing a ceq instruction followed by a brfalse target.
0x34<int8> bge.un.s
0x35<int8> bgt.un.s
0x36<int8> ble.un.s
0x37<int8> blt.un.s
0x38<int32>           br target           Branch to target.<unconditional branch>
0x39 brfalse
0x3A brtrue
0x3B beq
0x3C bge
0x3D bgt
0x3E ble
0x3F blt
0x40 bne.un
0x41 bge.un
0x42 bgt.un
0x43 ble.un
0x44 blt.un
0x45<unsigned int32>  switch(t1, t2 … tN) table switch based on value. Jump to one of n values. Stack:(Value -- )
   <int32>… <int32>                       The switch instruction implements a jump table. The format of the instruction is 
                                           an unsigned int32 representing the number of targets N, followed by N int32 values 
                                           specifying jump targets: these targets are represented as offsets (positive or negative) 
                                           from the beginning of the instruction following this switch instruction.
0x46                  ldind.i1             Indirect load value of type int8 as int32 on the stack. Stack:(addr -- Value)
0x47                  ldind.u1
0x48                  ldind.i2
0x49                  ldind.u2
0x4A                  ldind.i4
0x4B                  ldind.u4
0x4C                  ldind.i8
0x4D                  ldind.i
0x4E                  ldind.r4
0x4F                  ldind.r8
0x50                  ldind.ref
0x51                  stind.ref
0x52                  stind.i1
0x53                  stind.i2
0x54                  stind.i4
0x55                  stind.i8
0x56                  stind.r4
0x57                  stind.r8
0x58                  add                 Add two values, returning a new value. (value1, value2 -- Result). <Only For Type-Safe value.>
0x59                  sub                 <Only For Type-Safe value.>
0x5A                  mul                 <Only For Type-Safe value.>
0x5B                  div                 <Only For Type-Safe value.>
0x5C                  div.un              <Only For Type-Safe value.>
0x5D                  rem                 <Only For Type-Safe value.>
0x5E                  rem.un              <Only For Type-Safe value.>
0x5F                  and                 <Only For Type-Safe value.>
0x60                  or                  <Only For Type-Safe value.>
0x61                  xor                 <Only For Type-Safe value.>
0x62                  shl                 <Only For Type-Safe value.>
0x63                  shr                 <Only For Type-Safe value.>
0x64                  shr.un              <Only For Type-Safe value.>
0x65                  neg                 <Only For Type-Safe value.>
0x66                  not                 <Only For Type-Safe value.>
0x67                 conv.i1               conv.<to type> C data conversion. Convert to int8, pushing int32 on stack. (Value -- Result)
0x68                 conv.i2
0x69                 conv.i4
0x6A                 conv.i8
0x6B                 conv.r4
0x6C                 conv.r8
0x6D                 conv.u4
0x6E                 conv.u8
0x6F                 callvirt
0x70                 cpobj
0x71                 ldobj
0x72                 ldstr
0x73                 newobj
0x74                 castclass
0x75                 isinst
0x76                 conv.r.un
0x79                 unbox
0x7A                 throw
0x7B                 ldfld
0x7C                 ldflda
0x7D                 stfld
0x7E                 ldsfld
0x7F                 ldsflda
0x80                 stsfld
0x81<T>              stobj typeTok           Store a value of type typeTok at an address. (dest, src --) 
                                             If typeTok is a value type, the stobj instruction copies the value src to the address dest. 
                                             If typeTok is a reference type, the stobj instruction has the same effect as stind.ref.
0x82                 conv.ovf.i1.un
0x83                 conv.ovf.i2.un
0x84                 conv.ovf.i4.un
0x85                 conv.ovf.i8.un
0x86                 conv.ovf.u1.un
0x87                 conv.ovf.u2.un
0x88                 conv.ovf.u4.un
0x89                 conv.ovf.u8.un
0x8A                 conv.ovf.i.un
0x8B                 conv.ovf.u.un
0x8C<T>              box typeTok             Convert a boxable value to its boxed form. (val -- obj)
                                             If typeTok is a value type, the box instruction converts val to its boxed form. 
                                             When typeTok is a non-nullable type (§1.8.2.4), this is done by creating a new 
                                             object and copying the data from val into the newly allocated object. If it is 
                                             a nullable type, this is done by inspecting val’s HasValue property; if it is 
                                             false, a null reference is pushed onto the stack; otherwise, the result of boxing 
                                             val’s Value property is pushed onto the stack. If typeTok is a reference type, 
                                             the box instruction does nothing.
0x8D                 newarr
0x8E                 ldlen
0x8F                 ldelema
0x90                 ldelem.i1
0x91                 ldelem.u1
0x92                 ldelem.i2
0x93                 ldelem.u2
0x94                 ldelem.i4
0x95                 ldelem.u4
0x96                 ldelem.i8
0x97                 ldelem.i
0x98                 ldelem.r4
0x99                 ldelem.r8
0x9A                 ldelem.ref
0x9B                 stelem.i
0x9C                 stelem.i1
0x9D                 stelem.i2
0x9E                 stelem.i4
0x9F                 stelem.i8
0xA0                 stelem.r4
0xA1                 stelem.r8
0xA2                 stelem.ref
0xA3                 ldelem
0xA4                 stelem
0xA5                 unbox.any
0xB3                 conv.ovf.i1
0xB4                 conv.ovf.u1
0xB5                 conv.ovf.i2
0xB6                 conv.ovf.u2
0xB7                 conv.ovf.i4
0xB8                 conv.ovf.u4
0xB9                 conv.ovf.i8
0xBA                 conv.ovf.u8
0xC2                 refanyval
0xC3                 ckfinite
0xC6                 mkrefany
0xD0                 ldtoken
0xD1                 conv.u2
0xD2                 conv.u1
0xD3                 conv.i
0xD4                 conv.ovf.i
0xD5                 conv.ovf.u
0xD6                 add.ovf
0xD7                 add.ovf.un
0xD8                 mul.ovf
0xD9                 mul.ovf.un
0xDA                 sub.ovf
0xDB                 sub.ovf.un
0xDC                 endfinally(endfault)    End finally(fault) clause of an exception block. 
                                             Return from the finally or fault clause of an exception block 
                                             (see the Exception Handling subclause of Partition I for details).
0xDD<int32>          leave target            Exit a protected region of code.
0xDE<int8>           leave.s target          Exit a protected region of code, short form.
                                             The leave instruction unconditionally transfers control to target. 
                                             target is represented as a signed offset (4 bytes for leave, 1 byte 
                                             for leave.s) from the beginning of the instruction following the current instruction.
                                             The leave instruction is similar to the br instruction, but the former can be used 
                                             to exit a try, filter, or catch block whereas the ordinary branch instructions can 
                                             only be used in such a block to transfer control within it. The leave instruction 
                                             empties the evaluation stack and ensures that the appropriate surrounding finally blocks 
                                             are executed.
0xDF                 stind.i
0xE0                 conv.u
0xFE 0x00            arglist
0xFE 0x01            ceq
0xFE 0x02            cgt
0xFE 0x03            cgt.un
0xFE 0x04            clt
0xFE 0x05            clt.un
0xFE 0x06            ldftn
0xFE 0x07            ldvirtftn
0xFE 0x09            ldarg
0xFE 0x0A            ldarga
0xFE 0x0B            starg
0xFE 0x0C            ldloc
0xFE 0x0D            ldloca
0xFE 0x0E            stloc
0xFE 0x0F            localloc
0xFE 0x11            endfilter                 End an exception handling filter clause. (value -- )
                                               Used to return from the filter clause of an exception 
                                               (see the Exception Handling subclause of Partition I for a
                                               discussion of exceptions). value (which shall be of type int32 
                                               and one of a specific set of values) is returned from the filter 
                                               clause. It should be one of:
                                                 * exception_continue_search (0) to continue searching for an exception handler
                                                 * exception_execute_handler (1) to start the second phase of exception handling where
                                                   finally blocks are run until the handler associated with this filter clause is located. Then the
                                                   handler is executed.
                                               The result of using any other integer value is unspecified.

0xFE 0x12            unaligned.
0xFE 0x13            volatile.
0xFE 0x14            tail.
0xFE 0x15            initobj
0xFE 0x17            cpblk
0xFE 0x18            initblk
0xFE 0x1A            rethrow
0xFE 0x1C            sizeof
0xFE 0x1D            refanytype

TurboScript Extented Instructions:
