CIR(Common Intermediate Language (CIL))·ÖÎö

Êı¾İÕ»£º
Ëü³ÆÖ®Îª evaluation stack£¬ Êı¾İÕ»´æ·ÅÊı¾İµÄ×îĞ¡µ¥Î»ÊÇ4×Ö½ÚµÄ32Î»ÕûÊı¡£

ËüµÄ¼Ó·¨Ö¸ÁîÖ»ÓĞÒ»ÖÖĞÎÊ½£¬ÕâËµÃ÷ËüµÄ¼Ó·¨Ö¸ÁîµÄÊı¾İÀàĞÍÊÇºóÆÚÔ¼ÊøµÄ£¬²»¹ıÕâÑùÒ»À´£¬¹¹³É¼Ó·¨µÄÖ¸ÁîµÄÊı¾İ±ØĞëÒªÓĞÊı¾İÀàĞÍÁË£¡
CLR ±ÈÎÒ¶àÁËÒ»¸ö²ÎÊı±íÓÃÓÚ´«µİ¹ı³ÌµÄ²ÎÊı¡£

CLR ÊµÏÖÁËÁ½¸önew: newarr(´´½¨Ò»¸ö1Î¬Êı×é), newobj.

= CLI Architecture =
The Common Language Infrastructure (CLI) provides a specification for executable code and the execution environment (the Virtual Execution System, or VES) in which it runs.

The general CLI architecture as it relates to supporting mobile code, specifically
including
 *  ĞéÄâ»úÉè¼Æ
    * Ïß³Ì
    * ¶¯Ì¬°ó¶¨ classes, assemblies, and application domains.
    * ·Ö²¼Ê½ÎÄ¼ş¼ÓÔØ
    * ±£»¤»úÖÆ
    * CTS(Common Type System) - Self-describing type system
    * Cross assembly method/member function invocation
    * Side-by-side execution (simultaneous support for separate versions of the same component)
    * Managed and unmanaged code interoperability(Ğ­Í¬¹¤×÷ÄÜÁ¦)
 *  Ô´ÓïÑÔ¶ÀÁ¢ Source language independence
 *  Èí¼ş×é¼ş°æ±¾¹ÜÀí Software component version management
 *  Èí¼ş·Ö·¢Ä£Ê½ The software deployment model
 *  °²È«»úÖÆ Security mechanisms that address the mechanism that allows such general distribution of mobile code
 *  CLI Í¨Ñ¶»úÖÆ CLI communication mechanisms


== Ä£¿é(Module) ==
Ä£¿é(Module)ÀàËÆÓÚÒÔÇ°µÄµ¥Ôª£¬ÓÃÓÚ·Ö¸î²»Í¬µÄÀàºÍÀàĞÍ£¬ÒÔ¼°×ÊÔ´(resource, ×ÊÔ´¼ÇÂ¼¾ÍÊÇ×Ö·û´®£¬Í¼ÏóÒÔ¼°ÆäËüÊı¾İ£¬ËûÃÇÖ»ÔÚĞèÒªµÄÊ±ºò²Å»á±»µ÷ÈëÄÚ´æ)¡£ÀàĞÍµÄMetaĞÅÏ¢Ò²ÊÇÄ£¿éµÄÒ»²¿·Ö¡£
CLR µÄ³ÌĞò¼¯ÊÇÓÉÄ£¿é¹¹³ÉµÄ£¬CLR Ä£¿éÊÇÒ»ÖÖÁ÷Êı¾İ£¨×Ö½ÚÁ÷£©£¬Í¨³£ÊÇÒÔÎÄ¼şµÄĞÎÊ½´æÔÚÓÚ±¾µØÎÄ¼şÏµÍ³»òWeb·şÎñÆ÷ÉÏ¡£

¼ÈÈ»Ä£¿éÖÖ°üº¬ÀàĞÍµÄMetaĞÅÏ¢£¬ÀàĞÍ¼ì²éÏµÍ³¾Í¿ÉÒÔÁªºÏ¾²Ì¬ºÍ¶¯Ì¬¼¼Êõ¡£µ±ILÔËĞĞµÄÊ±ºò£¬Ö´ĞĞ»·¾³ÄÜµÃÖª
ËùÓĞ±äÁ¿²ÎÊıµÄÀàĞÍMetaĞÅÏ¢£¬×ÔÈ»¾ÍÄÜÖ´ĞĞÔËĞĞÊ±¿ÌµÄÀàĞÍ¼ì²é¡ª¡ªÕâ±»³ÆÖ®Îª reflection(ËüµÄº¬ÒåÎª½âÊÍ×ÔÃèÊöÀàĞÍ£¬ÀàĞÍµÄÓ°×Ó)¡£

¡¾namespace ½âÒÉ¡¿
namespace Ö»ÊÇC#µÈ¸ß¼¶ÓïÑÔÎªÁËÒıÓÃºÍÊéĞ´¶ÔÏóÃû³Æ·½±ãÒıÈëµÄ¸ÅÄî£¬ÔÚCLRÖĞ²¢²»´æÔÚ¡£
ËùÒÔ£¬´ÓÊôÓÚÒ»¸önamespaceµÄÀàĞÍ¿ÉÄÜÔÚ²»Í¬µÄ³ÌĞò¼¯ÖĞ£¬¶øÔÚÍ¬Ò»¸ö³ÌĞò¼¯ÖĞÒ²¿ÉÄÜ°üÀ¨²»Í¬µÄnamespace¡£
ÔÚ C#ÖĞ namespace Ö¸ÁîÖ»ÊÇÖ¸Ê¾C#±àÒëÆ÷ÎªÔ´´úÂë³öÏÖµÄÃ¿¸öÀàĞÍÃû³ÆÇ°¸½¼ÓnamespaceÃû³ÆÇ°×º£¬ÕâÑù¿ÉÒÔ¼õÉÙ±à³ÌÈËÔ±µÄÂ¼ÈëÁ¿¡£

CLRÖĞ°üºÍÀàÃûµÄ×î´ó³¤¶È¶¼ÊÇ1024¡£
 
== ³ÌĞò¼¯(Assembly) ==
³ÌĞò¼¯(Assembly)±¾Éí¾ÍÊÇÒ»¸öÄ£¿é£¬³ÌĞò¼¯(Assembly)ºÍÄ£¿é(Module)¼äµÄÇø±ğ£¬ÔÚÓÚ¶àÁËÒ»¸öÎ¬»¤Çåµ¥ manifest ¡¾ÃèÊöÒıÓÃÁËÄÄĞ©³ÌĞò¼¯£¬°üº¬ÁËÄÇĞ©Ä£¿éÎÄ¼ş£¬µ¼³öÁËÄÄĞ©ÀàĞÍ£¨ÆäËüÄ£¿éÖĞµÄ£©£¬ÒÔ¼°¶Ô×ÔÉíµÄÃèÊö¡¿¡£

¶à¸öÄ£¿éÎÄ¼ş¿ÉÒÔ±»Á´½Ó³ÉÒ»¸ö³ÌĞò¼¯(assembly)¡£ÔÚ³ÌĞò¼¯ÉÏ¶àÁËÒ»¸öÇåµ¥£¨manifest£©£¬ÓÃÀ´ÃèÊö¸Ã³ÌĞò¼¯ÒÔ¼°Ä£¿éµÄÁĞ±í£¬Ò»¸öÖ÷Èë¿Ú£¬µ¼³öµÄÀàĞÍ¶¨ÒåÁĞ±í£¨Ë½ÓĞÄ£¿éÖĞ¹«¿ªµÄÀàĞÍ£©¡£Õâ·İÇåµ¥±»·ÅÔÚÒ»¸öÄ£¿éÉÏ£¬
ÔÚ¸ÃÄ£¿éÉÏµÄ¹«¿ªµÄÀàĞÍ²»»á³öÏÖÔÚµ¼³öÀàĞÍ¶¨ÒåÁĞ±íÉÏ£¡

³ÌĞò¼¯ÊÇCLI·¢²¼¹ÜÀí(deployment managed)µÄµ¥Î»¡£³ÌĞò¼¯ÊÇ¿ÉÖØÓÃµÄÈí¼ş×é¼ş¡£³ÌĞò¼¯ÉõÖÁÄÜ¶¯Ì¬°ó¶¨µ÷ÓÃ´úÂë¡£
  * ³ÌĞò¼¯ÊÇ¶ÀÁ¢µÄÈí¼ş×é¼ş×Ó¼¯£¬ÎŞĞëÖØĞÂ±àÒë¡£
  * ³ÌĞò¼¯ÊÇ¶¨ÖÆÈí¼ş
  * ³ÌĞò¼¯ÄÜ±»¶ÀÁ¢·¢²¼
  * ³ÌĞò¼¯µ¼³öµÄAPIÄÜºÍÆäËü×é¼şÍêÃÀµÄ½»»¥¡£

³ÌĞò¼¯ÔÚÎÄ¼şÏµÍ³ÖĞÊÇÓÃPE(portable executable)¸ñÊ½´æ·Å¡£ÒıÓÃµÄ³ÌĞò¼¯ÊÇ°´Ğè¼ÓÔØµÄ£¬»»¾ä»°Ëµ£¬Ö»ÓĞµ±µ÷ÓÃµ½¸Ã³ÌĞò¼¯µÄº¯Êı»òÀàĞÍÖ®ºó£¬¸Ã³ÌĞò¼¯²Å»á±»¼ÓÔØ£º
  ³ÌĞò¼¯¼ÓÔØÆ÷(assembly loader)½«µ÷ÓÃ CLI ÏÂÔØÆ÷(downloader)¼ÓÔØ¸Ã³ÌĞò¼¯
    CLI ÏÂÔØÆ÷ ¸ù¾İËÑË÷Ë³Ğò´ÓÓ¦ÓÃ³ÌĞòÄ¿Â¼£¬×ÓÄ¿Â¼£¬±¾µØÎÄ¼şCacheÄ¿Â¼£¬»òÍøÂçURLÖĞ×°ÔØ¡£

JefferµÄÊéÖĞËµ£¬Çåµ¥ÔªÊı¾İ±íÖĞÓĞÒ»·İÃû½ĞExportedTypesDefµÄ±í£¬ÆäÖĞ¶¨ÒåÁËËùÓĞµÄµ¼³öÀàĞÍÌõÄ¿¡£µ«ÊÇÎÒÔÚ²é¿´µ¥ÎÄ¼ş³ÌĞò¼¯µÄÊ±ºòÈ´Ã»ÓĞ·¢ÏÖÔªÊı¾İµ±ÖĞÓĞExportedTypesµÄ¶¨Òå¡£ºóÀ´ÓÖ×ĞÏ¸¿´ÁËÒ»ÏÂÊé²ÅÃ÷°×£¬ÎªÁË½ÚÊ¡ÎÄ¼ş¿Õ¼ä£¬ËùÒÔÔÚÔªÊı¾İ¶¨ÒåÔªÊı¾İ±íÖĞËù¶¨ÒåµÄµ¼³öÀàĞÍÊÇ²»»áÔÚExportedTypesDef±íÖĞÖØ¸´³öÀ´µÄ¡£ÕâÒ²¾ÍÊÇËµ£¬Ö»ÓĞµ±Ò»¸ö³ÌĞò¼¯ÊÇÓÉ¶à¸öÄ£¿é¿éÎÄ¼ş×é³ÉµÄÊ±ºò£¬ÆäËüÄ£¿éÎÄ¼şÖĞµ¼³öµÄÀàĞÍ²Å»áÔÚ³ÌĞò¼¯Çåµ¥ÖĞ±»¶¨Òå¡£Ê¹ÓÃÁËÕâÖÖ¶¨Òå·½Ê½¡£Ïàµ±ÓÚÔÚ³ÌĞò¼¯Çåµ¥ÖĞÌá¹©Ò»¸ö²éÕÒ³ÌĞòÖĞËù¶¨ÒåÀàĞÍµÄË÷Òı¡£µ±CLR²éÕÒ³ÌĞò¼¯ÖĞÀàĞÍÊ±£¬Ëü»á¸ù¾İ³ÌĞò¼¯Çåµ¥ ExportdTypesDef±íµÄ¶¨Òå£¬ÔÚÏàÓ¦µÄÄ£¿éÎÄ¼şµ±ÖĞ²éÕÒµ½ĞèÒªµÄÀàĞÍ¶¨Òå¡£

Ò»¸ö.net³ÌĞò¼¯Ö§³ÖÈıÖÖ°æ±¾£¬Ëü¶¼ÊÇÊ¹ÓÃÌØĞÔµÄ·½Ê½ÔÚÔ´´úµ±ÖĞÖ¸¶¨µÄ£¬È»ºóÓÉ±àÒëÆ÷/Á´½ÓÆ÷½«ËüÃÇÇ¶Èëµ½.net³ÌĞòµ±ÖĞ£¨³ÌĞòÎÄ¼ş£©¡£ÕâÈıÖÖ°æ±¾ºÅ¶ÔÓ¦µÄÌØĞÔÃû³ÆºÍÆä×÷ÓÃÈçÏÂËùÊ¾£º
AssemblyFileVersion£ºÕâ¸öÌØĞÔËù±êÊ¶µÄ°æ±¾ºÅ¶ÔÓ¦´«Í³Win32³ÌĞòµÄÎÄ¼ş°æ±¾ºÅ¡£CLR±¾Éí²¢²»Ê¹ÓÃ´Ë°æ±¾ºÅ¡£
AssemblyInformation£ºÕâ¸öÌØĞÔËù±êÊ¶µÄ°æ±¾ºÅ¶ÔÓ¦´«Í³Win32³ÌĞòµÄ²úÆ·°æ±¾ºÅ¡£CLR±¾Éí²¢²»Ê¹ÓÃ´Ë°æ±¾ºÅ¡£
AssemblyVersion£ºÕâ¸öÌØĞÔ±êÊ¶µÄ°æ±¾ºÅÎªCLR±¾ÉíËùÊ¶±ğµÄ°æ±¾ºÅ£¬CLRÍ¨¹ıÕâ¸ö°æ±¾ºÅÀ´È·¶¨³ÌĞò¼¯µÄ°æ±¾¡£
ÕâÀïĞèÒª×¢ÒâµÄÊÇ£¬AssemblyFileVersionµÄbuildÎ»ºÍfixÎ»Ó¦¸ÃÊÇÒ»¸öµÚ´ÎÖØĞÂ±àÒëºó¶¼ÓĞËù²»Í¬µÄ°æ±¾ºÅ£¬³ÌĞòµÄÓÃ»§ôßÒÔ´Ë°æ±¾ºÅÀ´Çø·ÖÒ»¸öÖ÷°æ±¾ºÅ(ÓÉMajorºÍMinor×é³ÉµÄ°æ±¾ºÅ£©ÄÚ³ÌĞò¼¯µÄ²»Í¬¡£
¶øAssemblyVersion°æ±¾ºÅÔòÊÇÓ¦¸ÃÔÚÒ»¸öÖ÷°æ±¾ºÅÄÚ¹Ì¶¨²»±äµÄ£¬ÒòÎªCLRÊÇÊ¹ÓÃ´Ë°æ±¾ºÅÀ´È·¶¨¼ÓÔØ³ÌĞò¼¯µÄ¡£

== AppDomainºÍµØÖ·¿Õ¼ä ==

Ò»¸ö³ÌĞò¼¯½«±»¼ÓÔØµ½Ò»¸öApplication Domain(AppDomain)ÖĞÖ´ĞĞ¡£ Íâ²¿ÒıÓÃµÄÆäËü³ÌĞò¼¯½«ÔÚÍ¬ÑùÍ¬Ò»AppDomainÏÂÔËĞĞ¡£
»»¾ä»°Ëµ£¬AppDomain ½«³ÌĞò¼¯¾Û¼¯ÔÚÒ»Æğ£¬ÊµÏÖ×îÖÕ¹¦ÄÜ¡£
Ã¿Ò»¸öAppDomain¶¨ÒåÁËÒ»¸öÓÉCLIÖ´ĞĞÒıÇæ¹ÜÀíµÄµØÖ·¿Õ¼ä¡£ËùÓĞµÄµØÖ·ÒıÓÃ½«È·±£ÊµÔÚÍ¬Ò»¸öAppDomainÖĞ¡£
CLIµØÖ·¿Õ¼äÊÇÓĞ²ã´ÎµÄ£ºAppDomain ÄÜ±»¼ÓÔØÈëÒ»¸öCLIµØÖ·¿Õ¼ä¡£
CLIµØÖ·¿Õ¼ä¿ÉÒÔ±»¸ÅÂÔµÄÈÏÎªÊÇOSÖĞµÄ½ø³ÌµØÖ·¿Õ¼ä£¨ÖÁÉÙÔÚRotor CLIÖĞÊÇÕâÑù£©¡£Ã¿Ò»¸öµØÖ·¿Õ¼ä¶¼ÓĞÃ÷È·µÄµØÖ·±ß½ç¡£

Ã¿Ò»¸öCLIµØÖ·¿Õ¼ä¿ÉÒÔ°üº¬¶à¸öAppDomain£º ÆäÖĞÒ»¸öAppDomain¾ÍÊÇÏµÍ³³ÌĞò¼¯£¬ÁíÒ»¸öAppDomain°üº¬ÓëÆäËûÓëAppDomain¹²ÏíµÄ³ÌĞò¼¯¡£
Ö»ÓĞCLI¹ÜÀíÆ÷(the supervision of the CLI)²ÅÄÜ¿çÔ½AppDomainµÄµØÖ·¿Õ¼ä·ÃÎÊ½øĞĞ½»»¥¡£AppDomainÖ®¼äµÄ½»»¥Í¨Ñ¶ÊÇÍ¨¹ıÔ¶³Ì(Remoting)ÀàĞÍ¼ì²é»úÖÆ
Íê³É¡£Í¬ÑùµÄ»úÖÆ±»ÓÃÓÚ¿çÔ½µØÖ·¿Õ¼ä£¬Èç½Ó¿ÚºÍOS IPC.

Ä£¿é£¬³ÌĞò¼¯£¬AppDomainºÍµØÖ·¿Õ¼ä£¨address space£©µÄ¹ØÏµÊÇ£¬Ä£¿éÊÇ±àÒëÆ÷½¨Á¢µÄ×îĞ¡µÄµ¥ÔªÎÄ¼ş£¬ÓÉÒ»¸ö»òn¸öÄ£¿é×é³É³ÌĞò¼¯£¬³ÌĞò¼¯ÊÇ½øĞĞ·Ö·¢µÄ
×îĞ¡µ¥ÔªÎÄ¼ş£¬³ÌĞò¼¯ÄÜ×éºÏÔÚÒ»¸öAppDomainÏÂÖ´ĞĞ¡£¶à¸öAppDomainÄÜÔÚµ¥¸öµØÖ·¿Õ¼äÏÂÖ´ĞĞ¡£

¡¾ÎÊ¡¿1. Èç¹û¶ÔÆäËü³ÌĞò¼¯¹ı³ÌµÄµ÷ÓÃ£¬ÒâÎ¶×ÅĞèÒª¿ª±ÙĞÂµÄVirtualExecutionEngine?,¶ÑÕ»ÕâĞ©È«²¿¶¼ÒªĞÂµÄ£¿£¿
  2. address space ÊÇÔõÃ´¹¹ÔìµÄ£¿×î¶àÄÜÈİÄÉ¼¸¸öAppDomain£¿Ê²Ã´Ê±ºòĞèÒªĞÂ½¨ÁíÍâÒ»¸öaddress space£¿
¡¾´ğ¡¿
2¡¢»ù±¾ÉÏ Ò»¸öCLR Host½ø³Ì¾ÍÊÇÒ»¸öaddress space£¬È»ºó½¨Á¢¶à¸ö AppDomain£¬ÖÁÓÚ¸öÊıÄÇÊÇÎŞËùÎ½µÄ¡£AppDomain Ê¹ÓÃÀ´¸ôÀë³ÌĞò¼¯µÄ¡£±ÈÈç£º ASP.Net »òÕß  Microsoft SQL Server¡£
Ã¿Ò»¸öAppDomainÖ®¼ä²»ÄÜ±Ë´ËÓ°Ïì£¬ÊÇÍêÈ«¶ÀÁ¢µÄ£¬ÕâÑù±£Ö¤ÁËAppDomainµÄ°²È«£¡±ØĞë×öµ½Ò»¸öAppDomainÖĞ³öÁË´íÎó£¬¶ø²»Ó°Ïìµ½ÁíÒ»¸öAppDomain.

×¢£º
Common Language Infrastructure (CLI) Í¨ÓÃÓïÑÔ»ù´¡×éÖ¯

== Virtual Execution System(VES) ==
VESÊÇCLI DVM(·Ö²¼Ê½ĞéÄâ»ú)µÄĞÄÔà¡£Execution Engine (EE) ÔòÊÇÆäºËĞÄÁË£¬´úÂëÔÚ MSCOREE (Microsoft Common Object Runtime EE ¨C a name that is left over from the commercial
CLR code) ÖĞ¡£
ÒıÓÃµÄ³ÌĞò¼¯¿ÉÒÔ´æÔÚÓÚÈÎºÎµØ·½£¬±ÈÈçÒ»Ì¨web·şÎñÆ÷ÉÏ£¬µ±EE±»ÇëÇó×°ÔØ(Downloading)¸Ã³ÌĞò¼¯µÄÊ±ºò£¬½«»á×öÒÔÏÂµÄÊÂÇé£º
  ¼ì²éµ÷ÓÃÕßÈÏÖ¤
  ¼ì²é³ÌĞò¼¯ÊÇ·ñÓĞĞ§
  Ò»ÇĞ¸ã¶¨Ôò½«³ÌĞò¼¯×°ÔØµ½AppDomain
Ò»µ©³ÌĞò¼¯±»¼ÓÔØµ½AppDomain,ÄÇÃ´ÔÚAppDomainÖĞµÄÆäËü´úÂë½«ÄÜ·ÃÎÊ¸Ã³ÌĞò¼¯ÖĞµÄ¹«¿ª³ÉÔ±ºÍ×Ö¶Î£¬µ±È»ÉÏÔÚEEµÄ¼à¶½ÏÂ¡£
²»¹ıÕâÊ±ºò£¬³ÌĞò¼¯ÖĞµÄÀà²¢Ã»ÓĞ±»°ó¶¨µ½´úÂë£¬Ö»ÓĞµ±¶Ô¸ÃÀàµÄµ÷ÓÃÕæµÄ·¢ÉúµÄÊ±ºò£¬EE²Å»áÈ¥²éÕÒÔÚ³ÌĞò¼¯ÖĞµÄÄ¿±êÀà²¢½«Æä
×°ÔØÈëAppDomain£¬È»ºóĞ£Ñé·ÃÎÊĞí¿É£¬´Ó¸ÃÀàµÄMetaĞÅÏ¢ÖĞÌáÈ¡Ä¿±êÀàµÄÏ¸½ÚËµÃ÷£¬È»ºóBuild an appropriate call table data structure.
µ±µÚÒ»´ÎÒıÓÃÀà³ÉÔ±µÄÊ±ºò£¬ËüµÄĞÎÊ½»¹ÊÇÖĞ¼ä´úÂë£¬CLI ×ÜÊÇÊ¹ÓÃJIT±àÒëÆ÷(JITter)½«ÖĞ¼ä´úÂë·­Òë³É±¾µØ»úÆ÷Âë£¬È»ºóµ±ÏÂ´ÎÔÙ´Î
ÒıÓÃµÄÊ±ºò¾Í»áÖ±½ÓÖ´ĞĞ±àÒëºÃµÄ±¾µØ»úÆ÷Âë¡£EE»¹°üÀ¨ÁËÀ¬»øÊÕ¼¯Æ÷ºÍ½á¹¹»¯Òì³£´¦ÀíÆ÷¡£

EE Ö´ĞĞÁ÷³Ì£¬Í¨¹ıÒ»¸ö×î¼òµ¥µÄÖ÷³ÌĞòËµÃ÷£º
static void Main() {
  Console.WriteLine("Hello");
}

ÔÚ Main ·½·¨±»Ö´ĞĞÇ°£¬CLR½«¼ì²âËùÓĞ±»MainÖĞµÄ´úÂëÒıÓÃµÄÀàĞÍ£¬CLR½«»áÎªËùÓĞµÄÒıÓÃÀàĞÍ·ÖÅäÒ»¿éÄÚ²¿Êı¾İ£¬ÄÚ²¿Êı¾İÖĞ°üº¬ÁË¶¨ÒåµÄÀàĞÍÖĞµÄÃ¿Ò»¸ö·½·¨µÄÈë¿Ú¡£
Ã¿Ò»¸ö·½·¨Èë¿Ú°üº¬ÁË¸Ã·½·¨µÄÖ´ĞĞµØÖ·£¬µ±¸ÃÄÚ²¿Êı¾İ³õÊ¼»¯µÄÊ±ºò£¬CLR½«Ã¿Ò»¸öÈë¿ÚÖ¸ÏòÒ»¸öÄÚ²¿º¯Êı£ºJITCompiler.
ok, µÚÒ»´Îµ÷ÓÃWriteLine·½·¨µÄÊ±ºò£¬Êµ¼ÊÉÏÊÇ JITCompiler º¯Êı±»µ÷ÓÃ£¬JITCompiler º¯ÊıÖªµÀ±»µ÷ÓÃ·½·¨ÊÇÄÄÒ»¸ö£¨¸ù¾İ´«ÈëµÄSelf¶ÔÏóÖ¸Õë£©£¬È»ºó JITCompiler
º¯Êı²éÕÒ³ÌĞò¼¯µÄMetaDataÈ¡µÃ¸Ã·½·¨µÄIL£¬È»ºóĞ£Ñé²¢±àÒëIL³ÉÎª±¾µØCPUÖ¸Áî£¬±àÒëµÄ±¾µØCPUÖ¸Áî±»·ÅÔÚ¶¯Ì¬·ÖÅäµÄÄÚ´æ¿éÖĞ£¬½Ó×Å JITCompiler º¯Êı½«WriteLineµÄ
ÄÚ²¿Êı¾İµÄ·½·¨Èë¿ÚÌæ»»³É±àÒëºÃµÄ±¾µØCPUÖ¸ÁîÖ´ĞĞÈë¿Ú¡£×îºó£¬ JITCompiler º¯ÊıÌø×ªµ½¸ÃÈë¿Ú´¦Ö´ĞĞ¡£

JITCompiler ´æ·ÅµÄ±¾µØCPUÖ¸ÁîËæ×ÅÓ¦ÓÃµÄÖÕÖ¹¶ø×Ô¶¯±»ÊÍ·Å£¨³ı·ÇÊ¹ÓÃ NGen.exe£©£¬µ±ÔÙ´ÎÔËĞĞµÄÊ±ºò£¬ÄÇÃ´JITCompiler½«ÔÙ´Î±àÒë£¬Èç¹ûÄãÍ¬Ê±ÔËĞĞÁ½¸öÓ¦ÓÃÊµÀı
ÄÇÃ´JITCompilerÒ²½«»áÔÙ±àÒëÒ»´Î¡£ºÙºÙ£¬Èç¹ûÄãµÄÓ¦ÓÃ³ÌĞò´ó²¿·ÖµÄ·½·¨´úÂë¶¼Ö»±»µ÷ÓÃÒ»´Î£¬ÄÇÃ´ÕâËÙ¶ÈĞÔÄÜ½«±äµÃºÜÔã¸â£¬ÓÈÆäÊÇ´ò¿ªÁËJITCompilerÓÅ»¯µÄÇé¿öÏÂ
¸üÂı£¬µ±È»´ó¶àÊıÓ¦ÓÃ³ÌĞò¾ö²»¿ÉÄÜĞ´³öµÄ·½·¨´úÂëÖ»±»µ÷ÓÃÒ»´ÎµÄ£¬ÕâÖ»ÄÜÊÓ×÷¼«¶ËÇé¿ö¡£

ÁíÍâ£¬ÎÒºÜÏëÖªµÀµÄ£¬IL(MetaData)¼ÓÔØµ½ÄÚ´æÊÇÊ²Ã´Ê±ºò£¿Êµ¼ÊÉÏILÖ»ÓĞµ±JITCompiler±àÒëµÄÊ±ºò²ÅĞèÒª£¬Èç¹ûÒ»Ö±¶¼·ÅÔÚÄÚ´æÄÇ¾ÍÌ«ÀË·ÑÁË¡£

=== Òì³£±£»¤»úÖÆ ===


== Remoting »úÖÆ ==
Remoting »úÖÆ×÷ÎªÔÚAppDomainÖ®¼ä¹µÍ¨µÄÇÅÁº£¬µ±ÄãÒıÓÃÄãÒ»¸öAppDomainµÄ¶ÔÏó»ò³ÉÔ±µÄÊ±ºò£¬Remoting¾ÍÒª¸ºÔğ´¦ÀíÁË¡£Remoting Ò²±»ÓÃÓÚ
ÔÚµØÖ·¿Õ¼äÖ®¼ä¹µÍ¨¡£Remoting ÊÇÔÚ MarshalByRefObject ÀàÖĞÊµÏÖµÄ¡£
ËüµÄÊµÏÖ»úÖÆÈçÏÂ£º
·şÎñÆ÷¶Ë£ºÔ¶³Ì·ÃÎÊµÄ¶ÔÏóÊÇ MarshalByRefObject ×ÓÀàµÄÊµÀı£¬Í¨¹ıÊ¹ÓÃ¸Ã»ùÀà£¬CLI¾ÍÓĞÄÜÁ¦ÎªÔ¶³Ì¶ÔÏó½¨Á¢Real Proxy server Stub£¬
Õâ¸ö´úÀí·şÎñÆ÷½«±»×¢²áµ½È«¾ÖÃû³Æ¿Õ¼ä£¬È»ºó×¼±¸ºÃÔËĞĞÊ±¼äÁ´½Ó£¨µ±¿Í»§¶ÔÏóµ÷ÓÃÔ¶³Ì¶ÔÏóµÄÊ±ºòÓÃÒÔÖ§³ÖRMI£©¡£
Í¨µÀ£¨Channel£©¶ÔÏó±»MarshalByRefObject×ÓÀàÊµÀı»¯²¢×¢²á¡£

¿Í»§¶Ë£ºÍ¨µÀÔÚÊ¹ÓÃÇ°±ØĞëÏÈ×¢²á¡£µ±¿Í»§ÒıÓÃÔ¶³Ì¶ÔÏó£¬Î»ÓÚ¿Í»§¶ËµÄÍ¸Ã÷´úÀí(Transparent Proxy)±»½¨Á¢¡£½«µ÷ÓÃÊı¾İĞòÁĞ»¯£¨serializes£©ºó
Í¨¹ı´úÁ·±»´«ËÍµ½·şÎñÆ÷¡£

¿´Ñù×Ó£¬¾ÍËãÊÇÍ¬Ò»½ø³ÌÏÂµÄ²»Í¬AppDomainÖ®¼äµÄµ÷ÓÃÍ¨Ñ¶£¬Ò²ÊÇÂıµÃ²»µÃÁË°¡¡£Õâ¸ö²»Íâºõ¾ÍÊÇÒÔÇ°µÄAOÊµÏÖµÄÔ¶³Ìµ÷ÓÃ£¬Ö»²»¹ı±»°ü¹üÔÚÄÚºË
ÆÕÍ¨¿ª·¢Õß¿´²»µ½£¬Õâ¸öÔİ»ºÑĞ¾¿¡£

== ³ÌĞò¼¯µÄ¼ÓÔØºÍÖ´ĞĞ ==

³ÌĞò¼¯¼ÓÔØÆ÷£º²éÕÒ³ÌĞò¼¯£¬ÕÒµ½½«³ÌĞò¼¯×°ÔØµ½µ÷ÓÃÕßµÄAppDomainÖĞ£¬ÔÚ×°ÔØÇ°¼ÓÔØÆ÷½«Ê¹ÓÃPolicy ManagerĞ£ÑéÏàÓ¦µÄ°²È«È¨ÏŞ£¬È·±£µ÷ÓÃÕß±»ÔÊĞíÊ¹ÓÃ¸Ã³ÌĞò¼¯¡£
³ÌĞò¼¯ÏÂÔØÕß(downloader)ÊÇ³ÌĞò¼¯¼ÓÔØÆ÷µÄÒ»²¿·Ö£¬ÓÃÓÚ²éÕÒ³ÌĞò¼¯£¬²¢½«ÆäÏÂÔØµ½±¾µØ£¨Èç¹û³ÌĞò¼¯²»ÔÚ±¾µØ£©£¬ÒÔ±ã×°ÔØ£¬¿ª·¢Õß¿ÉÒÔÔÚÅäÖÃÎÄ¼şÖĞÖ¸¶¨¸½¼ÓµÄ
ÏÂÔØÎ»ÖÃ£¬ÅäÖÃÎÄ¼ş±ØĞëºÍÓ¦ÓÃ³ÌĞòÔÚÍ¬Ò»Ä¿Â¼£¬²¢×ñÑ­ÈçÏÂµÄÃüÃû£¬ÔÚ³ÌĞò¼¯ÎÄ¼şÃûºó¸½¼ÓÀ©Õ¹Ãû¡°.config¡±£¬Èç£º xxx.exe.config¡£Ô´³ÌĞòµÄÎ»ÖÃÔÚ£º/clr/src/fusion¡£
Ä¿Â¼µÄ²éÕÒË³Ğò¡¾Ò²ĞíÓĞÎó¡¿£º
  GACÄ¿Â¼
  Ó¦ÓÃÄ¿Â¼
  Ó¦ÓÃ×ÓÄ¿Â¼
  ÅäÖÃÎÄ¼şÖĞµÄ¸½¼ÓÎ»ÖÃ

³ÌĞò¼¯ÕÒµ½ºó£¬ÏÂÔØÆ÷½«³ÌĞò¼¯Á÷£¨ÎÄ¼şÃû£©´«µİ¸ø¼ÓÔØÆ÷£¬¼ÓÔØÆ÷Ê¹ÓÃPolicy ManagerĞ£ÑéÏàÓ¦µÄ°²È«È¨ÏŞ£¬È·±£³ÌĞò¼¯ÄÜÔÚ¸Ã»·¾³ÏÂÔËĞĞÒÔ¼°ÓÃ»§ÓĞÖ´ĞĞ¸Ã³ÌĞò¼¯µÄĞí¿É¡£
È»ºó£¬¼ÌĞøfusion£¬½«³ÌĞò¼¯¼ÓÔØµ½AppDomain£¬²¢µ÷ÓÃÀà¼ÓÔØÆ÷£¨class loader£©¡£

  nExitCode = _CorExeMain2(NULL, 0, pFileName, NULL, pCmdLine);                       //clr\src\tools\clix\clix.cpp:
    result = CoInitializeEE(COINITEE_DEFAULT | COINITEE_MAIN);  //³õÊ¼»¯ĞéÄâÖ´ĞĞÒıÇæ  //clr\src\vm\ceemain.cpp:
    bRetVal = ExecuteEXE(pImageNameIn);
          SystemDomain::ExecuteMainMethod(hMod);    //clr\src\vm\assembly.cpp
          hr = ClassLoader::RunMain(pMeth, 1, &iRetVal, stringArgs); //clr\src\vm\clsload.cpp
          È»ºóÅªÁËÒ»¸öÏß³Ì£¬ÔÚÏß³ÌÀïÔËĞĞ
             ARG_SLOT stackVar = ObjToArgSlot(StrArgArray); //ÔÚÕâÀï²Å×°Èë£¿
  ·ÖÎöclix¸Ğ¾õ²»¶Ô£¬Policy ManagerÒÔ¼°downloader¶¼Ã»ÓĞ¿´µ½£¡

=== Àà¼ÓÔØÆ÷ ===
µ±Àà×¼±¸Ö´ĞĞµÄÊ±ºòÀà¼ÓÔØÆ÷¾Í»á±»µ÷ÓÃ¡£Õâ·¢ÉúÔÚ£º
  1¡¢³ÌĞò¼¯µÄÖ÷Èë¿Úµã±»¼ÓÔØ
  2¡¢ÕıÔÚÖ´ĞĞµÄ¶ÔÏóÒıÓÃÁËÒ»¸ö´ÓÎ´¼ÓÔØµÄ¶ÔÏó¡£
Àà¼ÓÔØÆ÷½«´Ó³ÌĞò¼¯ÖĞ¼ÓÔØ¸ÃÀàµÄÈ«²¿¶¨Òå£¬È»ºó×¼±¸ÏàÓ¦µÄ¶ÔÏóÊµÀı»¯£º
  ¸´ÖÆILÒÔ¼°¸ÃÀàµÄMetaData
  ×¼±¸ÀàµÄÊı¾İ½á¹¹(EEClass)
  ´´½¨³õÊ¼»¯ÀàµÄµÄ·½·¨±í(MethodTable and Vtable)

== CLI±àÒëµÄÖ´ĞĞÎÄ¼ş½á¹¹ ==
ÆäÊµ¾ÍÊÇPEÎÄ¼ş½á¹¹£¬²»¹ıÀûÓÃPE½á¹¹ÖĞµÄIMAGE_OPTIONAL_HEADER.DataDirectory[IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR]±£´æ
ÁËCLRµÄIMAGE_COR20_HEADERÍ·¡£È»ºó½«_CorExeMain ×®ÒÔ¼°IL£¬metaData£¬µ¼ÈëµØÖ·±íÈ«²¿·ÅÔÚ.text½ÚÖĞ¡£

RVA: Ïà¶ÔĞéÄâµØÖ·£¨Relative Virtual Addresses£©

=== MS-DOS Stub ===
Ê×ÏÈÊÇ MS-DOS Stub: ÓÃÓÚÔÚDos»·¾³ÏÂÏÔÊ¾¸Ã³ÌĞò²»ÄÜÔËĞĞÔÚDOSÏÂµÄÌáÊ¾¡£
ÔÚÎÄ¼şÆ«ÒÆÁ¿0x3CµÄÎ»ÖÃÊÇÖ¸ÏòPE Ç©Ãû(signature) µÄÖ¸Õë: 80 00 00 00,¾ÍÊÇ 0x80.

00000000h: 4D 5A 90 00 03 00 00 00 04 00 00 00 FF FF 00 00 ; MZ?........ÿÿ..
00000010h: B8 00 00 00 00 00 00 00 40 00 00 00 00 00 00 00 ; ?......@.......
00000020h: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ; ................
00000030h: 00 00 00 00 00 00 00 00 00 00 00 00 80 00 00 00 ; ............€...
...
00000080h: 50 45 00 00 4C 01 03 00 92 38 84 45 00 00 00 00 ; PE..L...?„E....
00000090h: 00 00 00 00 E0 00 0E 01 0B 01 06 00 00 04 00 00 ; ....?..........

  _IMAGE_DOS_HEADER = record //¿ÉÒÔÊÓ×÷¹Ì¶¨µÄ,ÕÕ°á¡£
    e_magic: Word;     // Magic number: "MZ"
    e_cblp: Word;      // Bytes on last page of file
    e_cp: Word;        // Pages in file
    e_crlc: Word;      // Relocations
    e_cparhdr: Word;   // Size of header in paragraphs
    e_minalloc: Word;  // Minimum extra paragraphs needed
    e_maxalloc: Word;  // Maximum extra paragraphs needed
    e_ss: Word;        // Initial (relative) SS value
    e_sp: Word;        // Initial SP value
    e_csum: Word;      // Checksum
    e_ip: Word;        // Initial IP value
    e_cs: Word;        // Initial (relative) CS value
    e_lfarlc: Word;    // File address of relocation table
    e_ovno: Word;      // Overlay number
    e_res: array [0..3] of Word;    // Reserved words
    e_oemid: Word;     // OEM identifier (for e_oeminfo)
    e_oeminfo: Word;   // OEM information; e_oemid specific
    e_res2: array [0..9] of Word;  // Reserved words
    e_lfanew: Longint; // File address of new exe header ÎÄ¼şÆ«ÒÆÁ¿£º0x3C
  end;

PE Ç©Ãû(signature) ½ô½Ó×ÅMS-DOS Stub,ÊÇ4¸ö×Ö½Ú£¬ÄÚÈİÎª ¡°PE¡±È»ºóÊÇÁ½¸ö×Ö½Ú0: 0x00004550
  _IMAGE_NT_HEADERS = record
    Signature: DWORD;                      //PE signature: 0x00004550
    FileHeader: IMAGE_FILE_HEADER;         //The COFF header
    OptionalHeader: IMAGE_OPTIONAL_HEADER; //The PE header. 32Î»Í·ºÍ64Î»Í·ÂÔÓĞ²îÒì£¬CLRÄ¿Ç°°æ±¾Í³Ò»Ê¹ÓÃ32Î»½á¹¹¡£
  end;

=== COFF Í· ===
ÔÚ PE Ç©Ãû(signature) Ö®ºóÊÇ COFF Í·£¬ÄÚÈİÈçÏÂ£º
  _IMAGE_FILE_HEADER = record //JwaWinNT.pas
    Machine: WORD;               //Ä¿±ê»úÆ÷ÀàĞÍ×Ö¶Î£¬ÍĞ¹ÜµÄIL´úÂëÉèÖÃ¸Ã×Ö¶ÎÎª IMAGE_FILE_MACHINE_I386 (0x014C)
    NumberOfSections: WORD;      //Section½ÚµÄ¸öÊı£¬Section½Ú½ô½Ó×ÅPEÍ·
    TimeDateStamp: DWORD;        //ÎÄ¼şµÄ´´½¨Ê±¼ä
    PointerToSymbolTable: DWORD; //·ûºÅ±íµÄÎÄ¼şÎ»ÖÃÖ¸Õë£¬ÔÚÍĞ¹ÜµÄILÖĞÎ´ÓÃ£¬×ÜÊÇ0¡£
    NumberOfSymbols: DWORD;      //·ûºÅ±íµÄµÄ¸öÊı£¬ÔÚÍĞ¹ÜµÄILÖĞÎ´ÓÃ£¬×ÜÊÇ0¡£ £¨ÕâÀïµÄÎ»ÖÃÔÚ£º0x90£©
    SizeOfOptionalHeader: WORD;  //PEÍ·µÄ´óĞ¡¡£
    Characteristics: WORD;       //ÎÄ¼şÊôĞÔ±êÊ¾¡£¶ÔÓÚÒ»°ãµÄÍĞ¹Ü´úÂë¿ÉÖ´ĞĞÎÄ¼şµÄÊôĞÔÎª0x010E, DLLÊÇ0x210E.
  end;

Ä¿±ê»úÆ÷ÀàĞÍ×Ö¶ÎµÄ¿ÉÄÜµÄÖµÒÔ¼°º¬ÒåÈçÏÂ£º
  IMAGE_FILE_MACHINE_UNKNOWN   = 0;
  IMAGE_FILE_MACHINE_I386      = $014c; // Intel 386. For managed PE files, contents are applicable to any machine type.
  IMAGE_FILE_MACHINE_R3000     = $0162; // MIPS little-endian, 0x160 big-endian
  IMAGE_FILE_MACHINE_R4000     = $0166; // MIPS little-endian
  IMAGE_FILE_MACHINE_R10000    = $0168; // MIPS little-endian
  IMAGE_FILE_MACHINE_WCEMIPSV2 = $0169; // MIPS little-endian WinCE v2
  IMAGE_FILE_MACHINE_ALPHA     = $0184; // Alpha_AXP
  IMAGE_FILE_MACHINE_SH3       = $01a2; // SH3 little-endian
  IMAGE_FILE_MACHINE_SH3DSP    = $01a3;
  IMAGE_FILE_MACHINE_SH3E      = $01a4; // SH3E little-endian
  IMAGE_FILE_MACHINE_SH4       = $01a6; // SH4 little-endian
  IMAGE_FILE_MACHINE_SH5       = $01a8; // SH5
  IMAGE_FILE_MACHINE_ARM       = $01c0; // ARM Little-Endian
  IMAGE_FILE_MACHINE_THUMB     = $01c2; // ARM processor with Thumb decompressor
  IMAGE_FILE_MACHINE_AM33      = $01d3;
  IMAGE_FILE_MACHINE_POWERPC   = $01F0; // IBM PowerPC Little-Endian
  IMAGE_FILE_MACHINE_POWERPCFP = $01f1;
  IMAGE_FILE_MACHINE_IA64      = $0200; // Intel IA64
  IMAGE_FILE_MACHINE_MIPS16    = $0266; // MIPS
  IMAGE_FILE_MACHINE_ALPHA64   = $0284; // ALPHA64
  IMAGE_FILE_MACHINE_MIPSFPU   = $0366; // MIPS
  IMAGE_FILE_MACHINE_MIPSFPU16 = $0466; // MIPS
  IMAGE_FILE_MACHINE_AXP64     = IMAGE_FILE_MACHINE_ALPHA64;
  IMAGE_FILE_MACHINE_TRICORE   = $0520; // Infineon
  IMAGE_FILE_MACHINE_CEF       = $0CEF;
  IMAGE_FILE_MACHINE_EBC       = $0EBC; // EFI Byte Code
  IMAGE_FILE_MACHINE_AMD64     = $8664; // AMD64 (K8)
  IMAGE_FILE_MACHINE_M32R      = $9041; // M32R little-endian
  IMAGE_FILE_MACHINE_CEE       = $C0EE;

ÎÄ¼şÊôĞÔ±êÊ¶µÄÖµÒÔ¼°º¬Òå£º
  IMAGE_FILE_RELOCS_STRIPPED         = $0001; // Relocation info stripped from file. ÍĞ¹Ü´úÂë²»ÄÜÉèÖÃ¸Ã±êÖ¾ÎªÕæ¡£
  IMAGE_FILE_EXECUTABLE_IMAGE        = $0002; // File is executable  (i.e. no unresolved externel references). ÍĞ¹Ü´úÂë±ØĞëÉèÖÃ¸Ã±êÖ¾ÎªÕæ¡£
  IMAGE_FILE_LINE_NUMS_STRIPPED      = $0004; // Line nunbers stripped from file. ÍĞ¹Ü´úÂë±ØĞëÉèÖÃ¸Ã±êÖ¾ÎªÕæ¡£ÒòÎª²»ÄÜÇ¶Èëµ÷ÊÔĞÅÏ¢¡£
  IMAGE_FILE_LOCAL_SYMS_STRIPPED     = $0008; // Local symbols stripped from file. ÍĞ¹Ü´úÂë±ØĞëÉèÖÃ¸Ã±êÖ¾ÎªÕæ¡£
  IMAGE_FILE_AGGRESIVE_WS_TRIM       = $0010; // Agressively trim working set ÍĞ¹Ü´úÂë²»ÄÜÉèÖÃ¸Ã±êÖ¾ÎªÕæ¡£
  IMAGE_FILE_LARGE_ADDRESS_AWARE     = $0020; // App can handle >2gb addresses ÍĞ¹Ü´úÂë²»ÄÜÉèÖÃ¸Ã±êÖ¾ÎªÕæ¡£
  IMAGE_FILE_BYTES_REVERSED_LO       = $0080; // Little endian. Bytes of machine word are reversed. ÍĞ¹Ü´úÂë²»ÄÜÉèÖÃ¸Ã±êÖ¾ÎªÕæ¡£
  IMAGE_FILE_32BIT_MACHINE           = $0100; // 32 bit word machine.  µ±Ç°°æ±¾µÄÍĞ¹Ü´úÂëÉèÖÃ¸Ã±êÖ¾ÎªÕæ¡£
  IMAGE_FILE_DEBUG_STRIPPED          = $0200; // Debugging info stripped from file in .DBG file
  IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP = $0400; // If Image is on removable media, copy and run from the swap file.  ÍĞ¹Ü´úÂë²»ÄÜÉèÖÃ¸Ã±êÖ¾ÎªÕæ¡£
  IMAGE_FILE_NET_RUN_FROM_SWAP       = $0800; // If Image is on Net, copy and run from the swap file.   ÍĞ¹Ü´úÂë²»ÄÜÉèÖÃ¸Ã±êÖ¾ÎªÕæ¡£
  IMAGE_FILE_SYSTEM                  = $1000; // System File.   ÍĞ¹Ü´úÂë²»ÄÜÉèÖÃ¸Ã±êÖ¾ÎªÕæ¡£
  IMAGE_FILE_DLL                     = $2000; // File is a DLL.
  IMAGE_FILE_UP_SYSTEM_ONLY          = $4000; // File should only be run on a UP machine   ÍĞ¹Ü´úÂë²»ÄÜÉèÖÃ¸Ã±êÖ¾ÎªÕæ¡£
  IMAGE_FILE_BYTES_REVERSED_HI       = $8000; // Big endian. Bytes of machine word are reversed.  ÍĞ¹Ü´úÂë²»ÄÜÉèÖÃ¸Ã±êÖ¾ÎªÕæ¡£
 
EXE ÍĞ¹ÜÎÄ¼şµÄÎÄ¼şÊôĞÔÊÇ 0x010E (IMAGE_FILE_EXECUTABLE_IMAGE ©¦ IMAGE_FILE_LINE_NUMS_ STRIPPED ©¦ IMAGE_FILE_LOCAL_SYMS_STRIPPED ©¦ IMAGE_FILE_32BIT_ MACHINE). 
DLL ÍĞ¹ÜÎÄ¼şµÄÎÄ¼şÊôĞÔÊÇ 0x210E (IMAGE_FILE_ EXECUTABLE_IMAGE ©¦ IMAGE_FILE_LINE_NUMS_STRIPPED ©¦ IMAGE_FILE_ LOCAL_SYMS_STRIPPED ©¦ IMAGE_FILE_32BIT_MACHINE ©¦ IMAGE_FILE_DLL).

=== PE Í· ===
½ô½Ó×ÅCOFFÍ·µÄ¾ÍÊÇPEÍ·ÁË£¬¾¡¹ÜËü±»³Æ×÷¿ÉÑ¡Í·£¬µ«ÊÇÊµ¼ÊÉÏ¶ÔÓÚExeºÍDLLÎÄ¼şÀ´Ëµ£¬È´×ÜÊÇ´æÔÚµÄ¡£PEÍ·µÄ´óĞ¡²»ÊÇ¹Ì¶¨µÄ£¬ËüÓÉÊı¾İÄ¿Â¼µÄ´óĞ¡¾ö¶¨¡£
Ëü»á¸æËßÎÒÃÇ¸Ã¶ş½øÖÆÎÄ¼şÔõÑù±»ÔØÈëµÄ¸ü¶àĞÅÏ¢£º¿ªÊ¼µÄµØÖ·¡¢±£ÁôµÄ¶ÑÕ»Êı¡¢Êı¾İ¶ÎµÄ´óĞ¡µÈµÈ¡£

00000098h: 0B 01 06 00 00 04 00 00 00 04 00 00 00 00 00 00 ; ................
000000a8h: FE 22 00 00 00 20 00 00 00 40 00 00 00 00 40 00 ; ?... ...@....@.
000000b8h: 00 20 00 00 00 02 00 00 04 00 00 00 00 00 00 00 ; . ..............
000000c8h: 04 00 00 00 00 00 00 00 00 80 00 00 00 02 00 00 ; .........€......

  _IMAGE_OPTIONAL_HEADER = record
    //
    // Standard fields.
    //
    Magic: Word;               //Ä§Êı±êÊ¶¸ÃPE¾µÏñÎÄ¼şµÄ×´Ì¬£¬0x010B±íÊ¾32Î»PEÎÄ¼ş£¬ÍĞ¹Ü´úÂë×ÜÊÇ0x010B.
    MajorLinkerVersion: Byte;  //Á´½ÓÆ÷µÄÖ÷°æ±¾ºÅ£¬MC++ÉèÖÃ¸Ã×Ö¶ÎÎª7£¬ÆäËü¹«Ë¾µÄ´¿IL´úÂëÁ´½ÓÆ÷ÉèÖÃÎª6¡£
    MinorLinkerVersion: Byte;  //Á´½ÓÆ÷µÄ´Î°æ±¾ºÅ
    SizeOfCode: DWORD;         //×Ü´úÂë½ÚÇøµÄ´óĞ¡(.text),ÍĞ¹Ü´úÂëÖ»ÓĞÒ»¸ö´úÂëÇø¡£
    SizeOfInitializedData: DWORD; //×Ü³õÊ¼»¯Êı¾İ½ÚÇøµÄ´óĞ¡(Í³¼ÆËùÓĞµÄÊı¾İ½ÚÇøµÄSizeOfRawData×Ö¶Î)£¬ĞèÒª³õÊ¼»¯µÄÊı¾İ¡£
    SizeOfUninitializedData: DWORD; //×Ü²»ĞèÒª³õÊ¼»¯µÄÊı¾İ½ÚÇø´óĞ¡(.bss),¸ÃÊı¾İÇø²»Õ¼ÓÃ´ÅÅÌ¿Õ¼ä£¬Ö»ÊÇ×°ÔØºóÓÉOS¼ÓÔØÆ÷·ÖÅäÄÚ´æ¿Õ¼ä¡£
    AddressOfEntryPoint: DWORD;     //´úÂëÈë¿ÚµØÖ·RVA £¬¶ÔÓÚÍĞ¹Ü´úÂë£¨DLL»òExe£©×ÜÊÇÖ¸ÏòCLRµ÷ÓÃ×®¡£(ÔÚÎÄ¼şÆ«ÒÆÁ¿£º0x0a8)
    BaseOfCode: DWORD;              //´úÂë»ùÖ·RVA 
    BaseOfData: DWORD;              //Êı¾İ»ùÖ·RVA 
    //
    // NT additional fields.
    //
    ImageBase: DWORD;              //Ó³ÏóÎÄ¼ş»ùÖ·,Ìá¹©Õû¸ö¶ş½øÖÆÎÄ¼şµÄÓÅÏÈ£¨ÏßĞÔ£©ÔØÈëµØÖ·£¬ÔÚILAsmÖĞ¿ÉÒÔÊ¹ÓÃ .imagebase <integer value> Ö¸ÁîÖ¸¶¨¡£
    SectionAlignment: DWORD;       //ÄÚ´æÖĞ½Ú¶ÔÆëÖµ£¬¸ÃÖµ±ØĞë´óÓÚµÈÓÚFileAlignment£¬Ä¬ÈÏÊÇÄÚ´æÒ³´óĞ¡¡£ÀıÈç£¬Èç¹û¸ÃÖµÊÇ4096 ($1000)£¬ÄÇÃ´Ã¿½ÚµÄÆğÊ¼µØÖ·±ØĞëÊÇ4096µÄ±¶Êı
    FileAlignment: DWORD;          //ÎÄ¼şÖĞ½Ú¶ÔÆëÖµ£¬Èç¹ûSectionAlignmentµÄÖµĞ¡ÓÚÄÚ´æÒ³µÄ´óĞ¡£¬¸ÃÖµÔòÊÇ2µÄn´Î·½£¬´Ó512¡«64K¡£ FileAlignment ±ØĞëÆ¥Åä SectionAlignment!
                                   // .file alignment <integer value> ÀıÈç£¬Èç¹û¸ÃÖµÊÇ($200)£¬ÄÇÃ´Ã¿½ÚµÄÆğÊ¼µØÖ·±ØĞëÊÇ512µÄ±¶Êı
    MajorOperatingSystemVersion: Word;
    MinorOperatingSystemVersion: Word;
    MajorImageVersion: Word;
    MinorImageVersion: Word;
    MajorSubsystemVersion: Word;
    MinorSubsystemVersion: Word;
    Win32VersionValue: DWORD;
    SizeOfImage: DWORD;            //Ó³ÏóÎÄ¼ş½«ÒªÊ¹ÓÃµÄÄÚ´æÊıÁ¿
    SizeOfHeaders: DWORD;          //¸ø³öËùÓĞÍ·µÄ×Ü³¤¶È£¬°üÀ¨Êı¾İÄ¿Â¼ºÍ½ÚÍ·¡£Í¬Ê±£¬ËüÒ²ÊÇ´ÓÎÄ¼şµÄ¿ªÍ·µ½µÚÒ»½ÚµÄÔ­Ê¼Êı¾İµÄÆ«ÒÆÁ¿¡£
    CheckSum: DWORD;               //´ÅÅÌÎÄ¼şµÄĞ£ÑéºÍ
    Subsystem: Word;               //×ÓÏµÍ³: Çı¶¯³ÌĞò,¿ØÖÆÌ¨³ÌĞò(Console), GUI,etc
    DllCharacteristics: Word;      //·ÏÆú£¬×ÜÊÇ0
    SizeOfStackReserve: DWORD;     //±£ÁôµÄÕ»µÄ´óĞ¡,Ä¬ÈÏÊÇ1M£¬²¢Ã»ÓĞÕæÕı·ÖÅä¿Õ¼ä
    SizeOfStackCommit: DWORD;      //³õÊ¼Ê±Ö¸¶¨Õ»´óĞ¡,Ä¬ÈÏÊÇ1Ò³£¬Êµ¼Ê·ÖÅä¿Õ¼äµÄ´óĞ¡£¬Í¬Ê±Ò²ÊÇÖ¸¶¨µÄÔö¼ÓµÄÊıÁ¿¡£
    SizeOfHeapReserve: DWORD;      //±£ÁôµÄ¶ÑµÄ´óĞ¡£¬Ä¬ÈÏÊÇ1M£¬²¢Ã»ÓĞÕæÕı·ÖÅä¿Õ¼ä
    SizeOfHeapCommit: DWORD;       //³õÊ¼Ê±Ö¸¶¨¶Ñ´óĞ¡,Ä¬ÈÏÊÇ1Ò³£¬Êµ¼Ê·ÖÅä¿Õ¼äµÄ´óĞ¡£¬Í¬Ê±Ò²ÊÇÖ¸¶¨µÄÔö¼ÓµÄÊıÁ¿¡£
    LoaderFlags: DWORD;            //·ÏÆú£¬×ÜÊÇ0
    NumberOfRvaAndSize: DWORD;     //Number of entries in the DataDirectory array; at least 16. ¾¡¹Ü¿ÉÒÔÓĞ¶àÓÚ16¸öµÄÊı¾İÄ¿Â¼µ«ÊÇÒ»°ã±àÒëÆ÷×ÜÊÇÖ»²úÉú16¸ö¡£
    DataDirectory: array [0..IMAGE_NUMBEROF_DIRECTORY_ENTRIES - 1] of IMAGE_DATA_DIRECTORY;  //±£ÁôµÄ16¸öÊı¾İÄ¿Â¼¡£
  end;

Ä§Êı±êÊ¶¸ÃPE¾µÏñÎÄ¼şµÄ×´Ì¬£º
  IMAGE_NT_OPTIONAL_HDR32_MAGIC = $10b;
  IMAGE_NT_OPTIONAL_HDR64_MAGIC = $20b;
  IMAGE_ROM_OPTIONAL_HDR_MAGIC  = $107;

×ÓÏµÍ³:
  IMAGE_SUBSYSTEM_UNKNOWN                 = 0; // Unknown subsystem.
  IMAGE_SUBSYSTEM_NATIVE                  = 1; // Image doesn't require a subsystem.
  IMAGE_SUBSYSTEM_WINDOWS_GUI             = 2; // Image runs in the Windows GUI subsystem.
  IMAGE_SUBSYSTEM_WINDOWS_CUI             = 3; // Image runs in the Windows character subsystem.
  IMAGE_SUBSYSTEM_OS2_CUI                 = 5; // image runs in the OS/2 character subsystem.
  IMAGE_SUBSYSTEM_POSIX_CUI               = 7; // image runs in the Posix character subsystem.
  IMAGE_SUBSYSTEM_NATIVE_WINDOWS          = 8; // image is a native Win9x driver.
  IMAGE_SUBSYSTEM_WINDOWS_CE_GUI          = 9; // Image runs in the Windows CE subsystem.
  IMAGE_SUBSYSTEM_EFI_APPLICATION         = 10;
  IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER = 11;
  IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER      = 12;
  IMAGE_SUBSYSTEM_EFI_ROM                 = 13;
  IMAGE_SUBSYSTEM_XBOX                    = 14;

DataDirectory ÊÇIMAGE_NUMBEROF_DIRECTORY_ENTRIES ¸ö£¨Ò»°ã¶¼ÊÇ16¸ö£©Êı¾İÄ¿Â¼±íÊı×é£¬Ã¿Ò»¸öÊı¾İÄ¿Â¼ÏîµÄÄÚÈİÎª£º
  _IMAGE_DATA_DIRECTORY = record
    VirtualAddress: DWORD;  //½ÚµÄÎ»ÖÃ£¬ÊÇÒ»¸öÏà¶ÔµØÖ·(RVA)£¬Ïà¶ÔÓÚImageBase£¨Ó³ÏóÎÄ¼ş»ùÖ·£©¡£
    Size: DWORD;            //½ÚµÄ´óĞ¡
  end;

ÒÑ¶¨ÒåµÄÊı¾İÄ¿Â¼Ë÷ÒıÓĞ:
    IMAGE_DIRECTORY_ENTRY_EXPORT (0)          µ¼³ö·ûºÅÄ¿Â¼£»´ó¶àÓÃÓÚDLLÎÄ¼şµÄµ¼³öº¯Êı¡£´¿IL-codeÎ´ÓÃ¡£
    IMAGE_DIRECTORY_ENTRY_IMPORT (1)          µ¼Èë·ûºÅÄ¿Â¼£»µ¼ÈëµÄDLLº¯Êı£¬CLRÖ»ÓĞÒ»¸öÈë¿Ú£¬Ö¸ÏòÖ´ĞĞÒıÇæDLLµÄµ÷ÓÃº¯Êı.
    IMAGE_DIRECTORY_ENTRY_RESOURCE (2)        ×ÊÔ´Ä¿Â¼¡£´¿IL-codeÎ´ÓÃ¡£
    IMAGE_DIRECTORY_ENTRY_EXCEPTION (3)       Òì³£Ä¿Â¼¡£´¿IL-codeÎ´ÓÃ¡£
    IMAGE_DIRECTORY_ENTRY_SECURITY (4)        °²È«Ä¿Â¼£¬²»»á×°ÈëÄÚ´æ(IamgeFile)£¬µØÖ·ÊÇÎÄ¼şÖ¸Õë²»ÊÇRVA¡£
    IMAGE_DIRECTORY_ENTRY_BASERELOC (5)       »ùÖ·ÖØ¶¨Î»±í¡£
    IMAGE_DIRECTORY_ENTRY_DEBUG (6)           µ÷ÊÔÄ¿Â¼ - ÄÚÈİ±àÒëÆ÷Ïà¹Ø¡£´ËÍâ, Ğí¶à±àÒëÆ÷½«±àÒëĞÅÏ¢ÌîÈë´úÂë½Ú£¬²¢²»Îª´Ë´´½¨Ò»¸öµ¥¶ÀµÄ½Ú¡£CLRÎ´ÓÃ£¬È«²¿Öµ0¡£
    IMAGE_DIRECTORY_ENTRY_COPYRIGHT (7)       ÃèÊö×Ö·û´® - Ò»Ğ©ËæÒâµÄ°æÈ¨ĞÅÏ¢Ö®Àà¡£
    IMAGE_DIRECTORY_ENTRY_GLOBALPTR (8)       ¸ÃÖµÎª0£¬Global pointer  RVA of the value to be stored in the global pointer register.¡£
    IMAGE_DIRECTORY_ENTRY_TLS (9)             Ïß³Ì¼¶¾Ö²¿´æ´¢Ä¿Â¼ £»°üº¬ÉùÃ÷Îª¡°__declspec(thread)¡±µÄ±äÁ¿, Ò²¾ÍÊÇÃ¿Ïß³ÌµÄÈ«¾Ö±äÁ¿¡£
    IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG (10)    ÔØÈëÅäÖÃÄ¿Â¼ - ½á¹¹ºÍÓÃÍ¾²»Ïê¡£
    IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (11)   °ó¶¨ÊäÈëÄ¿Â¼ - ²Î¼ûÊäÈëÄ¿Â¼µÄÃèÊö¡£
    IMAGE_DIRECTORY_ENTRY_IAT (12)            ÊäÈëµØÖ·±í - ²Î¼ûÊäÈëÄ¿Â¼µÄÃèÊö¡£
    IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT (13);  Delay Load Import Descriptors
    IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR (14) Common Language Runtime header address and size
    Reserved(15)

=== ½ÚÍ·±í ===
½ÚÍ·±í½ô¸úPEÍ·ºó¡£ COFF Í·ÖĞµÄ NumberOfSections ×Ö¶Î¶¨ÒåÁË½ÚÍ·µÄÊıÄ¿¡£
  _IMAGE_SECTION_HEADER = record //¹²40¸ö×Ö½Ú
    Name: array [0..IMAGE_SIZEOF_SHORT_NAME - 1] of BYTE; //8¸ö×Ö½ÚµÄANSI string,½ÚÃûÒÔ¡°.¡±´òÍ·£¬Èç.text. ²»×ã8Î»ÒÔ0²¹×ã¡£
                                                          //Èç¹û½ÚÃû³¤ÓÚ8Î»£¬ÄÇÃ´Ãû³Æ½«±»·ÅÓÚ×Ö·û´®±í£¬ÕâÀï¾ÍÊÇÔÚ×Ö·û´®±íÖĞµÄÊ®½øÖÆ×Ö·û´®Æ«ÒÆÁ¿£¬ÒÔ"/"´òÍ·£¬
    Misc: TImgSecHdrMisc;  //ÕâÀïÊÇ½ÚµÄVirtualSize(unaligned size)£¬¡¾Ö»ÓĞ¶ÔÄ¿±êÎÄ¼ş(.obj)²ÅÊÇPhysicalAddress¡£ÕâÀï²»¹Ü¡¿
    VirtualAddress: DWORD; //½ÚÊ×µØÖ·RVA  (.tezt:ÊÇ$2000)
    SizeOfRawData: DWORD;  //RawDataµÄ´óĞ¡£¨RawDataÊÇÖ¸ĞèÒª³õÊ¼»¯µÄÊı¾İ£©£¬¸ÃÖµ±ØĞëÊÇFileAlignmentµÄÕûÊı±¶£¡Èç¹û¸ÃÖµĞ¡ÓÚVirtualSize,ÄÇÃ´Ê£ÏÂµÄ½«±»Ìî0¡£
    PointerToRawData: DWORD; //ÎÄ¼şÖ¸Õë£¬ËüÊÇ´ÓÎÄ¼şµÄ¿ªÍ·µ½½ÚÖĞÊı¾İµÚÒ»Ò³µÄÆ«ÒÆÁ¿£¬±ØĞëÊÇFileAlignmentµÄÕûÊı±¶¡£
    PointerToRelocations: DWORD; //ÎÄ¼şÖ¸Õë£¬Ö¸ÏòÖØ¶¨Î»Èë¿ÚµÄÆğµã£¬Èç¹ûÎª0£¬±íÃ÷¸Ã½Ú²»ĞèÒªÖØ¶¨Î»¡£Î´ÓÃÊ¼ÖÕÎª0¡£
    PointerToLinenumbers: DWORD; //Î´ÓÃÊ¼ÖÕÎª0¡£
    NumberOfRelocations: WORD; //Î´ÓÃÊ¼ÖÕÎª0¡£
    NumberOfLinenumbers: WORD; //Î´ÓÃÊ¼ÖÕÎª0¡£
    Characteristics: DWORD; //ÃèÊö½ÚµÄÌØĞÔ,bits
  end;
  TImgSecHdrMisc = record
    case Integer of
      0: (PhysicalAddress: DWORD);
      1: (VirtualSize: DWORD);
  end;

00000178h: 2E 74 65 78 74 00 00 00 04 03 00 00 00 20 00 00 ; .text........ ..
00000188h: 00 04 00 00 00 02 00 00 00 00 00 00 00 00 00 00 ; ................
00000198h: 00 00 00 00 20 00 00 60 2E 72 73 72 63 00 00 00 ; .... ..`.rsrc...
000001a8h: 98 01 00 00 00 40 00 00 00 02 00 00 00 06 00 00 ; ?...@..........
000001b8h: 00 00 00 00 00 00 00 00 00 00 00 00 40 00 00 40 ; ............@..@
000001c8h: 2E 72 65 6C 6F 63 00 00 0C 00 00 00 00 60 00 00 ; .reloc.......`..
000001d8h: 00 02 00 00 00 08 00 00 00 00 00 00 00 00 00 00 ; ................
000001e8h: 00 00 00 00 40 00 00 42 00 00 00 00 00 00 00 00 ; ....@..B........
000001f8h: 00 00 00 00 00 00 00 00 EC 22 00 00 00 00 00 00 ; ........?......

½ÚµÄÌØĞÔ£º
  IMAGE_SCN_SCALE_INDEX = $00000001; // Tls index is scaled (.tls section only).
  IMAGE_SCN_CNT_CODE               = $00000020; // Section contains code.
  IMAGE_SCN_CNT_INITIALIZED_DATA   = $00000040; // Section contains initialized data.
  IMAGE_SCN_CNT_UNINITIALIZED_DATA = $00000080; // Section contains uninitialized data.
  IMAGE_SCN_LNK_NRELOC_OVFL = $01000000; // Section contains extended relocations.
  IMAGE_SCN_MEM_DISCARDABLE = $02000000; // Section can be discarded.
  IMAGE_SCN_MEM_NOT_CACHED  = $04000000; // Section is not cachable.
  IMAGE_SCN_MEM_NOT_PAGED   = $08000000; // Section is not pageable.
  IMAGE_SCN_MEM_SHARED      = $10000000; // Section is shareable.
  IMAGE_SCN_MEM_EXECUTE     = $20000000; // Section is executable.
  IMAGE_SCN_MEM_READ        = $40000000; // Section is readable.
  IMAGE_SCN_MEM_WRITE       = DWORD($80000000); // Section is writeable.

The ILAsm compiler generates the following sections in a PE file:
.text  A read-only section containing the common language runtime header, the metadata, the IL code, managed structured exception handling information, and managed resources.
.sdata  A read/write section containing data.
.reloc  A read-only section containing relocations.
.rsrc  A read-only section containing unmanaged resources.
.tls  A read/write section containing thread local storage data.


== Metadata ==
Token µÄ¶¨Òå£º uint32, xxyyyyyy; xx´ú±íÊÇµÚ¼¸¸ö±í£¨0x70³ıÍâ£¬´ú±í#USÁ÷£©£» yyyyyy´ú±íÔÚ±íÖĞµÄĞòºÅ£¬¾ÍÊÇindex

CLRµÄÍ·ÒÔ¼°ÆäMetaData£¨IL, Resource£© È«²¿·ÅÔÚ.text ½Ú£¬ÕâÒâÎ¶×Å¼ÓÔØµÄÊ±ºòËùÓĞµÄMetadata½«È«²¿×°ÈëÄÚ´æ£¬ºÃ´¦¾ÍÊÇ¿ÉÒÔÈÃÏµÍ³ÖØ¶¨Î»ÄÚ´æ¡£
²»¹ıÓÉÓÚËüÊÇ²ÉÓÃÁ÷µÄĞÎÊ½´æ·Å£¬±ØĞë¶ÁÈë£¬ÕâÑù·´¶øÀË·ÑÄÚ´æ¡£ËùÓĞµÄ MetaData ĞÅÏ¢È«²¿ÔÚ IMAGE_COR20_HEADER.MetaData×Ö¶ÎÖ¸ÏòµÄµØÖ·ÖĞ£¬Æä
Èë¿ÚÄÚÈİÊÇ TClrMetadataHeader ¡£

  IMAGE_COR20_HEADER = record
    // Header versioning
    cb: DWORD;  //IMAGE_COR20_HEADER½á¹¹µÄ´óĞ¡¡£
    MajorRuntimeVersion: WORD; //Ö´ĞĞ´Ë³ÌĞòËùĞèµÄ×îµÍCLR°æ±¾ºÅ¡£
    MinorRuntimeVersion: WORD; //Ö´ĞĞ´Ë³ÌĞòËùĞèµÄ×îµÍCLR°æ±¾ºÅ¡£
    // Symbol table and startup information
    MetaData: IMAGE_DATA_DIRECTORY;
    Flags: DWORD; // ÃèÊö´ËCLRÓ³ÏñµÄÖ´ĞĞÊôĞÔ
    EntryPointToken: DWORD; //Ö÷³ÌĞòÈë¿Úµã£¬ÊÇÒ»¸öÖ¸ÏòMethodDef±íµÄ»òFile±íµÄÈë¿ÚToken
    // Binding information
    Resources: IMAGE_DATA_DIRECTORY;
    StrongNameSignature: IMAGE_DATA_DIRECTORY;
    // Regular fixup and binding information
    CodeManagerTable: IMAGE_DATA_DIRECTORY; //²»¹ØĞÄ
    VTableFixups: IMAGE_DATA_DIRECTORY;  //ÊÇÓÉÊ¹ÓÃVTableµÄÓïÑÔÈçC++Ê¹ÓÃµÄ£¬ÀàËÆÔ­À´PE½á¹¹ÖĞµÄÖØ¶¨Ïò±í
    ExportAddressTableJumps: IMAGE_DATA_DIRECTORY; //²»¹ØĞÄ
    // Precompiled image info (internal use only - set to zero)
    ManagedNativeHeader: IMAGE_DATA_DIRECTORY; //²»¹ØĞÄ
  end;
  _IMAGE_DATA_DIRECTORY = record
    VirtualAddress: DWORD;  //Êı¾İÈë¿Ú
    Size: DWORD;            //Êı¾İ´óĞ¡
  end;

CLRÓ³ÏñµÄÖ´ĞĞÊôĞÔ:
  COMIMAGE_FLAGS_ILONLY               = $00000001; //´ËCLR³ÌĞòÓÉ´¿IL´úÂë×é³É
  COMIMAGE_FLAGS_32BITREQUIRED        = $00000002; //´ËCLRÓ³ÏñÖ»ÄÜÔÚ32Î»ÏµÍ³ÉÏÖ´ĞĞ
  COMIMAGE_FLAGS_IL_LIBRARY           = $00000004; //´ËCLRÓ³ÏñÊÇ×÷ÎªIL´úÂë¿â´æÔÚµÄ
  COMIMAGE_FLAGS_STRONGNAMESIGNED     = $00000008; //´ËCLRÓ³ÏñÊÇÓĞstrong name signatureµÄ
  COMIMAGE_FLAGS_TRACKDEBUGDATA       = $00010000; //´ËCLRÓ³ÏñÊÇÓĞtracked debug data


  //Ö¸ÏòMetaDataµÄÈë¿ÚÄÚÈİ£¬ÊÇMetaData Header£º
  TClrMetadataHeader = packed record
    Signature: DWORD;   // Magic signature for physical metadata : $424A5342.
    MajorVersion: Word; // Major version, 1  Metadata¸ñÊ½µÄ°æ±¾ºÅ
    MinorVersion: Word; // Minor version, 1
    Reserved: DWORD;    // Reserved, always 0
    Length: DWORD;      // Length of version string in bytes, say m.
    Version: array [0..0] of Char; //UTF8¸ñÊ½µÄ±àÒë»·¾³°æ±¾ºÅ
    // UTF8-encoded version string of length m
    // Padding to next 4 byte boundary, say x.
    {
    Version: array [0..((m+3) and (not $3))-1] of Char;
    Flags,              // Reserved, always 0
    Streams: Word;      // Number of streams, say n.
    // Array of n StreamHdr structures.
    StreamHeaders: array [0..n-1] of TClrStreamHeader;
    }
  end;
  TClrStreamHeader = packed record
    Offset: DWORD; // Memory offset to start of this stream from start of the metadata root, Ïà¶ÔÓÚMetadataÍ·(PClrMetadataHeader)µÄÆ«ÒÆÁ¿
    Size: DWORD;   // Size of this stream in bytes, shall be a multiple of 4.
    // Name of the stream as null terminated variable length
    // array of ASCII characters, padded with \0 characters
    Name: array [0..MaxWord] of Char; //Á÷µÄÃû×ÖÓĞ±ØÒª£¿
  end;


MetadataµÄÊµ¼ÊÊı¾İ£¬ÊÇÍ¨¹ıÈô¸É²»Í¬µÄStream±£´æµÄ¡£ÆäÖĞÊı¾İÒÔ¶ÑµÄ½á¹¹½øĞĞ×éÖ¯¡£ÔÚÎÄ¼şÖĞÊÇÁ÷£¬×°ÈëÄÚ´æ
ºóÊÇ¶Ñ¡£Êµ¼ÊÉÏ¾ÍÊÇ°³µÄÊı¾İÇø¡£²»¹ıËü·ÖµÃ¸ü¼ÓÏ¸ÖÂ¡£

MetadataÀï×î³£¼ûµÄÓĞÎåÖÖÁ÷£¬#String, #Blob, #Guid,#US(User String)ºÍ#~Á÷("#"ÊÇÁ÷Ãû×ÖµÄÇ°×º)¡£Ã¿ÖÖÀàĞÍÁ÷×î¶àÖ»ÄÜ³öÏÖÒ»´Î£¬
#USºÍ#BlobÁ÷¿ÉÊ¡ÂÔ¡£

#StringÁ÷¾ÍÊÇÒ»¸ö×Ö·û´®¶Ñ£¬MetadataÄÚ²¿ÓÃµ½µÄËùÓĞ×Ö·û´®ÈçÀà»ò·½·¨µÄÃû×ÖµÈµÈ¶¼ÒÔUTF8±àÂë±£´æÔÚ´Ë¶ÑÄÚ¡£
¶øÓÃ»§µÄ×Ö·û´®Èç×Ö·û´®³£Á¿£¬ÔòÒÔUnicode±àÂë±£´æÔÚ#US(User String)¶ÑÄÚ¡£
ÖµµÃ×¢ÒâµÄÊÇ£¬USÁ÷ºÍStringÁ÷ÔÚ¶ş½øÖÆ½á¹¹×éÖ¯ÉÏ²»Í¬£¬ÎÒÃÇºóÃæ½«·ÖÎöÊ±»áÏêÏ¸Ìá¼°¡£

#GuidÁ÷ÊÇ±£´æ³ÌĞòÖĞÊ¹ÓÃµ½µÄGuidµÄÊı×é£¬¶¨³¤¼ÇÂ¼¡£ÈçAssemblyÖĞModuleµÄMVID¡£

#BlobÁ÷ÊÇÒ»¸öÍ¨ÓÃ´æ´¢¿Õ¼ä£¬³ıÁËGuidºÍ×Ö·û´®ÒÔÍâ»ù±¾ÉÏËùÓĞÊ£ÏÂµÄ¶«Î÷¶¼ÒÔ¶ş½øÖÆÊı¾İĞÎÊ½·ÅÔÚÀïÃæ£¬ÈçPublicKey£¬³£Á¿µÄÖµµÈµÈ¡£
µÈĞ§ÓÚÎÒµÄÊı¾İÇøÖĞ·ÖÅäµÄ±äÁ¿Çø¡£

×îÖØÒªµÄÊÇ#~Á÷£¬´æ·Å¸÷ÖÖÀàĞÍĞÅÏ¢£¬ÕâÊÇMetadataºËĞÄĞÅÏ¢´æ·ÅµÄµØ·½¡£#~Á÷ÎïÀíÉÏÒÔÈô¸ÉÕÅ±í(Table)µÄĞÎÊ½×éÖ¯£¬Ã¿ÕÅ±í´æ´¢Ä³Ò»·½ÃæµÄMetadataĞÅÏ¢£¬
ÈçMethodDef±í´æ´¢ËùÓĞ·½·¨µÄĞÅÏ¢¡£Ã¿ÕÅ±íÓÖÓÉÈô¸ÉµÄĞĞ(Row)×é³ÉÃ¿ĞĞÓĞn¸öÁĞ(Column)£¬Ã¿ÁĞ´ú±íÒ»ÖÖĞÅÏ¢£¬ÈçMethodDef±íÖĞÃ¿Ò»ĞĞ
¶¼ÓĞÒ»¸ö·½·¨µÄRVA,ÀàĞÍ±êÖ¾,Ãû×Ö,SignatureµÈµÈĞÅÏ¢¡£ÔÚÆäÖĞÍ¨¹ı¸÷ÖÖË÷ÒıÀ´Ïà»¥¹ØÁª£¬Õû¸ö×éÖ¯½á¹¹ºÍ¹ØÏµÊı¾İ¿âºÜÏàËÆ¡£

  PClrTableStreamHeader = ^TClrTableStreamHeader;
  TClrTableStreamHeader = packed record
    Reserved: DWORD;    // Reserved, always 0
    MajorVersion: Byte; // Major version of table schemata, always 1
    MinorVersion: Byte; // Minor version of table schemata, always 0
    HeapSizes: Byte;    // Bit vector for heap sizes. 
    Reserved2: Byte;    // Reserved, always 1
    Valid: Int64;       // Bit vector of present tables, let n be the number of bits that are 1. 64bitµÄÓĞĞ§Î»Í¼ÁĞ±í£¬Ö¸³ö´æÔÚÁËÄÄĞ©ÀàĞÍµÄ±í£¬×Ü¹²¿ÉÒÔÓĞ64ÖÖÀàĞÍµÄÁĞ±í¡£
    Sorted: Int64;      // Bit vector of sorted tables. Ö¸Ê¾¶ÔÓ¦µÄÁĞ±íÊÇ·ñÅÅĞò¡£
    // Array of n four byte unsigned integers indicating the number of rows
    // for each present table.
    Rows: array [0..MaxWord] of DWORD; // ¶ÔValidÎ»Í¼½øĞĞ´ÓµÍµ½¸ßÎ»É¨Ãè£¬·¢ÏÖÒ»¸ö±í´æÔÚ£¬Ôò¿Éµ½RowsÖĞ»ñÈ¡´Ë±íÖĞ¼ÇÂ¼µÄĞĞÊı, Rows µÄÊıÄ¿nÊÇÊµ¼Ê´æÔÚµÄ±íµÄÊıÄ¿¡£´æ·ÅµÄÄÚÈİÊÇ¸Ã±íµÄ¼ÇÂ¼Êı¡£
    //Rows: array [0..n-1] of DWORD;
    //Tables: array // Êµ¼Ê±íÊı¾İµÄ¿ªÊ¼£¬´æ·ÅÊÇ°´ÕÕRowsËùÔÚµÄË³Ğò£¬ÒÀ´Î´æ·ÅµÄ¡£Ò»¸ö±í½Ó×ÅÒ»¸ö±í¡£
  end;

ÕâÀïËùÓĞµÄ±íÍ¨¹ıÒ»¸ö64bitµÄÓĞĞ§Î»Í¼À´±íÊ¾±í´æÔÚÓë·ñÃ¿ÖÖÀàĞÍµÄ±íÓĞÒ»¸ö±àºÅ£¬»»¾ä»°Ëµ£¬×î¶à¿ÉÒÔÓĞ64ÖÖ²»Í¬µÄ±íÀàĞÍ£¬ÈçMethodDef±íµÄ±àºÅ
ÊÇ6£¬ÔòµÚValid×Ö¶ÎµÄµÚ6Î»ÖÃ1¡£Òò¶øÃ¿¸ö±íµÄÃ¿Ò»ĞĞ£¬¿ÉÒÔÊ¹ÓÃÒ»¸öÎ¨Ò»µÄToken±íÊ¾¡£´ËTokenÊÇÒ»¸ö32bitÎŞ·ûºÅÕûĞÍÊı£¬×î¸ßÒ»¸ö×Ö½Ú±íÊ¾±íµÄ
ĞòºÅ£¬µÍÈı¸ö×Ö½Ú±íÊ¾±íÖĞµÄË÷ÒıºÅ¡£Èç0x06000003±íÊ¾0x06±í£¨MethodDef£©ÖĞµÚ3ĞĞ£¨ÈçMyApp::Add£©Õâ¸öToken¸ÅÄîÔÚCLRÖĞÆµ·±Ê¹ÓÃ£¬ÈçIL´úÂë
µ÷ÓÃº¯Êı¡¢Ê¹ÓÃ±äÁ¿¶¼ÊÇÊ¹ÓÃToken¡£ÓëÖ®ÀàËÆµÄ»¹ÓĞCoded Index£¬µÈ»á½²¶ş½øÖÆÊµÏÖÊ±ÔÙËµ¡£±ÈÈç³ÌĞò¼¯µÄ¶¨ÒåÒ²ÊÇÒ»¸ö±íÀàĞÍ£¬Ö»²»¹ıËüµÄ¼ÇÂ¼Ö»
ÓĞÒ»¸ö¡£


´ËÆª±Ê¼ÇÎªÏÖÔÚµÄÌå»á£¬ÎÒ¸Ğ¾õ±È½ÏÇ³±¡£¬¶øÇÒµ±ÖĞÒ²Ó¦¸Ã»áÓĞÒ»Ğ©´íÎó¡£ÕâĞ©ÎÊÌâÁô´ıÒÔ¶ÔÔªÊı¾İÓĞ¸üÉîµÄÀí½âºóÏÖ½øĞĞĞŞÕı¡£

1£®  ºÎÎªÔªÊı¾İ

ÔªÊı¾İÊÇ±»Ç¶Èëµ½³ÌĞòÎÄ¼şµ±ÖĞµÄÒ»Ğ©ÃèÊöĞÅÏ¢£¬.Net PEÎÄ¼şÖĞËù¶¨Òåµ½ºÍËùÒıÓÃµ½µÄÀàĞÍ¶¼»áÔÚÔªÊı¾İÖĞÓĞÏàÓ¦µÄÃèÊö¡£

2£®  ÔªÊı¾İÓĞÊ²Ã´ÓÃÍ¾

ÒÔÏÂÕâ¶Î»°ÊÇJefferyÏÈÉúÊéÀïÃæµÄ¶ÔÔªÊı¾İÓÃÍ¾µÄ¾«²ÊÃèÊö¡£

l         ÔªÊı¾İÊ¡È¥ÁËÔ´´úÂë±àÒëÊ±¶ÔÍ·ÎÄ¼şµÄÒÀÀµ£¬ÕâÊÇÒòÎªÔÚº¬ÓĞÊµÏÖÀàĞÍºÍ³ÉÔ±µÄIL´úÂëÎÄ¼şµ±ÖĞ£¬ÒÑ¾­°üº¬ÁËËùÓĞ±»ÒıÓÃµÄÀàĞÍºÍ³ÉÔ±µÄĞÅÏ¢¡£±àÒëÆ÷¿ÉÒÔÖ±½Ó´ÓÍĞ¹ÜÄ£¿éÖĞ¶ÁÈ¡ÔªÊı¾İÀ´»ñµÃÕâĞ©ĞÅÏ¢¡£

l         vs.net¿ÉÒÔÀûÓÃÔªÊı¾İÀ´¸¨ÖúÎÒÃÇ±àĞ´´úÂë¡£ËüµÄÖÇÄÜ¸ĞÖªÌØĞÔ¾ÍÊÇÍ¨¹ı·ÖÎöÔªÊı¾İÀ´¸æËßÎÒÃÇÄ³¸öÀàĞÍÌá¹©ÁËÄÄĞ©·½·¨£¬ÒÔ¼°ÒÔÕâĞ©·½·¨ÓĞÄÄĞ©²ÎÊı¡£

l         CLRµÄ´úÂëÑéÖ¤¹ı³Ì¿ÉÒÔÀûÓÃÔªÊı¾İÀ´È·±£´úÂë½öÖ´ĞĞ¡°°²È«¡±µÄ²Ù×÷¡£

l         ÀûÓÃÔªÊı¾İ£¬ÎÒÃÇ¿ÉÒÔ½«Ò»¸ö¶ÔÏóµÄ×Ö¶ÎĞòÁĞ»¯µ½Ò»¸öÄÚ´æ¿éÖĞ£¬È»ºóÔ¶³Ì´«ËÍ¸øÁíÒ»Ì¨»úÆ÷£¬×îºóÔÙÔÚÔ¶³Ì¼ÆËã»úÉÏÖ´ĞĞ·´ĞòÁĞ»¯£¬´Ó¶øÖØĞÂ´´½¨¶ÔÏóºÍËûµÄ×´Ì¬¡£

l         ÀûÓÃÔªÊı¾İ£¬À¬»øÊÕ¼¯Æ÷Òª°É×·×Ù¶ÔÏóµÄÉú´æÖÜÆÚ¡£¶ÔÓÚÈÎºÎ¶ÔÏó£¬À¬»øÊÕ¼¯Æ÷¶¼ÄÜ¹»Í¨¹ıÔªÊı¾İÀ´È·¶¨¸Ã¶ÔÏóµÄÀàĞÍ£¬²¢ÇÒ¿ÉÒÔ»ñÖª¸Ã¶ÔÏóµÄÄÄĞ©×Ö¶ÎÒıÓÃÁËÆäËüµÄ¶ÔÏó¡£

l

3£®  ÔªÊı¾İÖÖÀà

.NetÖĞµÄÔªÊı¾İÊÇÓÉ²»Í¬µÄÊı¾İ±í¹¹³ÉµÄ¡£ÔªÊı¾İ±íÔÚ.Netµ±ÖĞ±»·Ö³ÉÎªÈıÀà£¨Ã¿ÀàÓĞ¶à¸ö±í£©£¬ËüÃÇ·Ö±ğÊÇ£¬¶¨ÒåÔªÊı¾İ±í£¬ÒıÓÃÔªÊı¾İ±í»¹ÓĞÇåµ¥ÔªÊı¾İ±í¡£

¶¨ÒåÔªÊı¾İ±íÊÇÓÃÀ´ÃèÊö.Net PEÎÄ¼ş±¾ÉíËù¶¨ÒåµÄÊı¾İÀàĞÍµÄ¡£ÔÚÎÒÃÇ³ÌĞòµ±ÖĞµÄ¶¨ÒåµÄÀà£¬½á¹¹µÈµÈÒ»ÇĞµÄÀàĞÍĞÅÏ¢£¬×îÖÕ¶¼»á³öÏÖÔÚ¶¨ÒåÔªÊı¾İ±íÖĞ¡£

ÒıÓÃÊı¾İ±íÓÃÀ´ÃèÊö.Net Peµ±ÖĞËùÒıÓÃµ½µÄÍâ²¿ÀàĞÍ¡£ÔÚÎÒÃÇ³ÌĞòµ±ÖĞÒıÓÃµÄFCLÀàĞÍ¡¢×Ô¶¨ÒåÀàĞÍ£¨×¢1£©ÒÔ¼°µÚÈı·½ÀàĞÍµÄ¶¨Òå¶¼»á³öÏÖÔÚÒıÓÃÊı¾İ±íÄÚ¡£

Çåµ¥ÔªÊı¾İ±íÏà¶ÔÓÚ¶¨ÒåÔªËØÔªºÍÒıÓÃÔªÊı¾İ±íÀ´Ëµ£¬ÊÇÒ»Àà±È½ÏÌØÊâµÄÔªÊı¾İ±í£¬ËüµÄ×÷ÓÃÊÇÓÃÀ´ÃèÊö³ÌĞò¼¯ĞÅÏ¢¡£³ÌĞò¼¯µÄÀíÄîºÜÏñÊÇ¶¯Ì¬Á´½Ó¿â£¬ÔÚ³ÌĞò¼¯ÄÚ²¿°üº¬×ÅºÜ¶àµÄÀàĞÍ¶¨Òå£¬ÔÚ³ÌĞò¼¯µÄÍâ²¿£¬Ò»¸ö³ÌĞòÔ±¿ÉÒÔÍ¨¹ı°üº¬Õâ¸ö³ÌĞò¼¯µÄ·½Ê½À´Ê¹ÓÃÕâ¸ö³ÌĞòËùÌá¹©µÄ×ÊÔ´¡£È»¶øÓë¶¯Ì¬Á´½Ó¿âËù²»Í¬µÄÊÇ£¬³ÌĞò¼¯ÖĞº¬ÓĞÔªÊı¾İ£¨ÌØ±ğÊÇÇåµ¥Êı¾İ£©£¬ÕâÒ²¾ÍÊ¹³ÌĞò¼¯³ÉÎªÁË.NetÆ½Ì¨ÊµÏÖ½â¾ö°æ±¾³åÍ»ºÍ¼òµ¥²¿ÊğÖĞµÄÖØÒª»ù´¡¡£ÕıÊÇÓÉÓÚ³ÌĞò¼¯µÄÇåµ¥µ±ÖĞÃèÊöÁË³ÌĞò¼¯µÄ°æ±¾£¬.NetÆ½Ì¨²ÅÔÊĞí¶à¸ö°æ±¾µÄ³ÌĞò¼¯Í¬Ê±°²×°µ½Í¬Ò»Ì¨¼ÆËã»úÉÏ£¬²¢ÔÚÖ´ĞĞ³ÌĞòÊ±£¬¸ù¾İ³ÌĞòËù°ó¶¨µÄ³ÌĞò¼¯°æ±¾À´ÕıÈ·µÄ×°Èë³ÌĞò¼¯¡£

³ıÁËÃèÊö³ÌĞò¼¯µÄ°æ±¾ĞÅÏ¢ÒÔºó£¬³ÌĞò¼¯µÄÇåµ¥ÔªÊı¾İ»¹»á¶Ô³ÌĞò¼¯µÄÆäËüÒ»Ğ©¶¨ÒåĞÅÏ¢½øĞĞÃèÊö¡£ÕâĞ©ĞÅÏ¢°üÀ¨³ÌĞò¼¯ÖĞ¶ÔÄ£¿é»òÕßÆäËüÎÄ¼şµÄÒıÓÃ£¨Ò»¸ö³ÌĞò¼¯¿ÉÒÔÓÉ¶à¸öÄ£¿é»òÕßÆäËüµÄÎÄ¼şÖ÷³É£¬µ«ÊÇÔÚÕâ¸ö³ÌĞò¼¯ÖĞÖ»ÓĞÖ÷ÎÄ¼ş²Å»á°üº¬Çåµ¥£©¡¢³ÌĞò¼¯ÖĞ°üº¬µÄ×ÊÔ´¶¨Òå£¬»¹ÓĞ³ÌĞò¼¯ÖĞµ¼³öÀàĞÍµÄ¶¨Òå£¨ÎÒÏëÕâ¿ÉÄÜÊÇÎªÁË·½±ãCLR¶Ô³ÌĞò¼¯ÖĞµ¼³öÀàĞÍµÄ²éÕÒ°É£¬±Ï¾¹Ò»¸ö³ÌĞò¼¯¿ÉÒÔ°üº¬¶à¸öÄ£¿é£¬Èç¹ûÃ»ÓĞÒ»¸ö»ã×ÜË÷ÒıµÄ»°£¬ÔÚ³ÌĞò¼¯µ±ÖĞ²éÕÒµ½Ä³Ò»¸öÌØ¶¨ÀàĞÍµÄĞ§ÂÊ»áÊÜµ½½Ï´óµÄÓ°Ïì£©¡£


ÒÔÏÂÊÇJefferyÏÈÉú¶ÔÍÏ¹Ü´úÂëÓÅÊÆµÄÂÛÊö¡£

Èç¹ûÓ¦ÓÃ³ÌĞòÔÚÒ»Ğ©ĞÂĞÍµÄCPU£¨±ÈÈç±¼ÌÚ4£©ÉÏÔËĞĞ£¬JIT±àÒëÆ÷ÄÜ¹»¼ì²âµ½ÕâÖÖÇé¿ö£¬²¢²úÉúÀûÓÃÕâĞ©ĞÂĞÍCPUÌá¹©µÄÌØÊâÖ¸ÁîµÄ±¾µØ´úÂë¡£¶ø·ÇÍÏ¹ÜÓ¦ÓÃ³ÌĞòÍ¨¹ı±»±àÒëÎªÃæÏò¾ßÓĞ×îĞ¡Í¨ÓÃ¹¦ÄÜ¼¯ºÏµÄCPUÆ½Ì¨£¬Ò»°ã»á±ÜÃâÊ¹ÓÃĞÂĞÍCPUÌá¹©µÄÌØÊâÖ¸Áî¡£¶øÕâĞ©ÌØÊâÖ¸ÁîÍùÍù»áÔÚ½ÏĞÂµÄCPUÉÏÎªÓ¦ÓÃ³ÌĞò´øÀ´ºÜ¸ßµÄĞÔÄÜÌáÉı£¨Ç°Ò»¶ÎÊ±¼äÎÒ»¹ÔÚ³ÌĞòÔ±ÔÓÖ¾ÉÏ¿´µ½ÁËintel´µÅõÊ¹ÓÃËü×Ô¼ºµÄC++±àÒëÆ÷Ëù±àÒë³öÀ´µÄ´úÂë»áÔÚËü×Ô¼ºÉú²úµÄCPUÉÏ»ñµÃ¶àÃ´ºÃµÄĞÔÄÜ¡£ÆäÊµIntelÍêÈ«Ò²¿ÉÒÔÎªJITÀ´×öÕâÑùµÄÓÅ»¯¹¤×÷£¬²»¹ıÕâÒª¿´.NetÆ½Ì¨±¾ÉíÊÇ·ñÁô³öÁËÕâÖÖ¶ÔJITÀàËÆÓÚ²å¼şÊ½Ö§³Ö£©¡£

JIT±àÒëÆ÷ÄÜ¼ì²âµ½ÕıÔÚÔËĞĞµÄ»úÆ÷ÉÏÄ³Ğ©×ÜÊÇ·µ»Ø´íÎóµÄ²¼¶û²âÊÔ¡£ÕâÑùJIT¾Í»á½«ÕâÀà²»»á±»Ö´ĞĞµÄ´úÂëÓÅ»¯ÏÂÈ¥£¬ÒÔÊ¹´úÂëÁ¿±äµÄ¸üĞ¡£¬Ö´ĞĞËÙ¶È±äµÄ¸ü¿ì£¨µ±ÎÒÒ»¿ªÊ¼¶ÁÍêÕâ¶ÎµÄÊ±ºòÎÒ¶Ô´Ë²¢²»ÏàĞÅ£¬ÒòÎªÎÒ¸Ğ¾õÕâÊÇÒ»ÖÖ±àÒëÆÚµÄ¼¼Êõ£¬Ò»°ãµÄ·ÇÍÏ¹Ü±àÒëÆ÷Ò²ÊÇ¿ÉÒÔÊµÏÖËüµÄ£¬µ«ÊÇµ±ÎÒ¶ÁÍêÁËÏÂÃæÒ»¶ÎºóÎÒµÄ¹ÛÄî·¢ÉúÁË×ª±ä£©¡£

ÔÚÓ¦ÓÃ³ÌĞòÔËĞĞÊ±£¬CLRÄÜ¹»·ÖÎöÆÀ¹À´úÂëµÄÖ´ĞĞÇé¿ö£¬²¢ÓĞÑ¡ÔñµØÖØĞÂ½«IL´úÂë±àÒë³ÉÎª±¾µØ´úÂë¡£¸ù¾İ¹Û²ìµ½µÄÖ´ĞĞÄ£Ê½£¬±»±àÒëµÄ´úÂë¿ÉÒÔ±»ÖØĞÂ×éÖ¯ÒÔÌá¸ß·ÖÖ§²âÊÔµÄ³É¹¦ÂÊ£¨ÕâÊÇÒ»¸ö¶àÃ´ÁîÈËĞË·İµÄ¼¼Êõ°¡£¬Ò»ÖÖ¶Ô´úÂëÔÚÔËĞĞÊ±ÖÇÄÜ»¯µÄ·ÖÎöÓëµ÷Õû¡£ÕâÖÖ¼¼ÊõÀàËÆÓÚÈË¹¤ÖÇÄÜ¼¼Êõ£¬ÒòÎªËüĞèÒªCLR¸ù¾İÔËĞĞÊ±¸ù¾İÊµ¼Ê³öÏÖµÄÇé¿öÀ´¶Ô´úÂë½øĞĞµ÷Õû£¬²»¹ıÓÉÓÚÏÖÔÚÈË¹¤ÖÇÄÜ¼¼Êõ»¹ÔÚ²»¶ÏµÄ·¢Õ¹¹ı³ÌÖĞ£¬¶øÇÒÆä×ÔÉíÒ²²¢²»Íê³ÉÊì£¬ËùÒÔÎÒÏëÎ¢Èí¿ÉÄÜ²¢²»ÊÇÊ¹ÓÃÒ»ÖÖÖÇÄÜĞÔÖÊµÄ¼¼ÊõÀ´Íê³ÉÕâÏî¹¤×÷µÄ¡£Ò»ÖÖ¿ÉÒÔÏëÏóµÄµ½£¬Ò²¿ÉÒÔÀí½âµÄ·½Ê½ÊÇÎ¢Èí½«Ó¦ÓÃÖĞµÄÒ»Ğ©ÔËĞĞÊ±µ÷Õû·½Ê½¹é½á³ÉÎª¡°´úÂëÔËĞĞÊ±µ÷ÕûÄ£Ê½¿â¡±£¬È»ºóCLRÔÙ¸ù¾İÕâ¸öÄ£Ê½¿âÔÚÔËĞĞÊ±¶Ô´úÂë½øĞĞÆ¥ÅäºÍµ÷Õû£¬ÔÚÎ´À´£¬Î¢Èí¿ÉÒÔ²»¶ÏµÄÀ©Õ¹ºÍÍê×´¿öÕâ¸öÄ£Ê½¿âÒÔÊ¹ÕâÖÖÓÅ»¯¿ÉÒÔ´ïµ½Ò»ÖÖ¸üºÃµÄĞ§¹û£©¡£

ÖØ¶ÁJefferyÏÈÉúµÄ¡¶.Net¿ò¼Ü³ÌĞòÉè¼Æ¡·Õâ±¾Êé£¬·¢ÏÖËû¶Ô.NetÖĞÄ³Ğ©¹Ø¼üÔªËØµÄ×Ü½áÕæµÄºÜÖµµÃ¶ÁÕß»ØÎ¶¡£ÒÔÏÂÊÇJefferÏÈÉú¶ÔÔªÊı¾İ¸ø.NetÓ¦ÓÃ³ÌĞò´øÀ´ÓÅÊÆµÄ×Ü½á¡£

ÔªÊı¾İÊ¡È¥ÁËÔ´´úÂë±àÒëÊ±¶ÔÍ·ÎÄ¼şµÄÒÀÀµ£¬ÕâÊÇÒòÎªÔÚº¬ÓĞÊµÏÖÀàĞÍºÍ³ÉÔ±µÄIL´úÂëÎÄ¼şµ±ÖĞ£¬ÒÑ¾­°üº¬ÁËËùÓĞ±»ÒıÓÃµÄÀàĞÍºÍ³ÉÔ±µÄĞÅÏ¢¡£±àÒëÆ÷¿ÉÒÔÖ±½Ó´ÓÍĞ¹ÜÄ£¿éÖĞ¶ÁÈ¡ÔªÊı¾İÀ´»ñµÃÕâĞ©ĞÅÏ¢¡£

vs.net¿ÉÒÔÀûÓÃÔªÊı¾İÀ´¸¨ÖúÎÒÃÇ±àĞ´´úÂë¡£ËüµÄÖÇÄÜ¸ĞÖªÌØĞÔ¾ÍÊÇÍ¨¹ı·ÖÎöÔªÊı¾İÀ´¸æËßÎÒÃÇÄ³¸öÀàĞÍÌá¹©ÁËÄÄĞ©·½·¨£¬ÒÔ¼°ÒÔÕâĞ©·½·¨ÓĞÄÄĞ©²ÎÊı¡£

CLRµÄ´úÂëÑéÖ¤¹ı³Ì¿ÉÒÔÀûÓÃÔªÊı¾İÀ´È·±£´úÂë½öÖ´ĞĞ¡°°²È«¡±µÄ²Ù×÷¡£

ÀûÓÃÔªÊı¾İ£¬ÎÒÃÇ¿ÉÒÔ½«Ò»¸ö¶ÔÏóµÄ×Ö¶ÎĞòÁĞ»¯µ½Ò»¸öÄÚ´æ¿éÖĞ£¬È»ºóÔ¶³Ì´«ËÍ¸øÁíÒ»Ì¨»úÆ÷£¬×îºóÔÙÔÚÔ¶³Ì¼ÆËã»úÉÏÖ´ĞĞ·´ĞòÁĞ»¯£¬´Ó¶øÖØĞÂ´´½¨¶ÔÏóºÍËûµÄ×´Ì¬£¨ÎÒÏëÕâÀïJefferyÏÈÉú¿ÉÄÜÖ¸µÄÊÇÍ¨¹ıÔªÊı¾İ¿ÉÒÔ»ñÈ¡µ½¶ÔÏóµÄ²¼¾Ö£¬½ø¶ø¿ÉÒÔĞòÁĞ»¯Ëü£¬¶øºÍÔ¶³Ì²»Ô¶³ÌµÄÃ»ÓĞÊ²Ã´¹ØÏµ£©¡£

ÀûÓÃÔªÊı¾İ£¬À¬»øÊÕ¼¯Æ÷Òª°É×·×Ù¶ÔÏóµÄÉú´æÖÜÆÚ¡£¶ÔÓÚÈÎºÎ¶ÔÏó£¬À¬»øÊÕ¼¯Æ÷¶¼ÄÜ¹»Í¨¹ıÔªÊı¾İÀ´È·¶¨¸Ã¶ÔÏóµÄÀàĞÍ£¬²¢ÇÒ¿ÉÒÔ»ñÖª¸Ã¶ÔÏóµÄÄÄĞ©×Ö¶ÎÒıÓÃÁËÆäËüµÄ¶ÔÏó£¨ÃÀÃîµÄÔªÊı¾İ£©¡£



C# 2.0 - Static Class
±¾ÎÄ×ÊÁÏÒıÓÃ×ÔÀî½¨ÖÒÏÈÉúµÄÑİ½²¸å

C# 2.0 Ìá¹©ÁË¾²Ì¬Àà£¬ÔÚ1.xÖĞÎÒÃÇÒªÊµÏÖ¾²Ì¬ÀàĞèÒªÊ¹ÓÃÏÂÃæµÄ´úÂë¡£

1.0
public sealed class Class1
{
  private Class1(){}
}

ÔÚC# 2.0ÖĞÎÒÃÇ¿ÉÒÔÊ¹ÓÃstatic classÀ´¸ü¼ÓÓÅÑÅµØ½â¾öÕâ¸öÎÊÌâ¡£
public static class Class1
{
}

ÎÒÃÇ·´±àÒëÒ»ÏÂ£¬»áÁË½âÆäÊµÏÖ»úÖÆ¡£
.class public abstract auto ansi sealed beforefieldinit Program
 extends object
{
}

Ô­À´±àÒëÆ÷½«¸ÃÀàÉùÃ÷Îª abstract sealed£¬×ÔÈ»²»ÄÜ±»¼Ì³Ğ±»ÊµÀı»¯ÁË¡£
µ«ÊÇC#±àÒëÆ÷²¢²»ÔÊĞíÎÒÃÇÔÚ´úÂëÖĞÖ±½ÓÉùÃ÷Ò»¸öabstract sealedÀàĞÍ£¬ÏÂÃæµÄ´úÂëÎŞ·¨Í¨¹ı±àÒë¡£
public abstract sealed class Class1
{
}

¾²Ì¬ÀàµÄÏŞÖÆ

1. ¾²Ì¬Àà²»ÄÜÓĞÊµÀı¹¹ÔìÆ÷¡£
2. ¾²Ì¬Àà²»ÄÜÓĞÈÎºÎÊµÀı³ÉÔ±¡£
3. ¾²Ì¬ÀàÉÏ²»ÄÜÊ¹ÓÃabstractºÍsealedĞŞÊÎ·û¡£
4. ¾²Ì¬ÀàÄ¬ÈÏ¼Ì³Ğ×ÔSystem.Object£¬²»ÄÜÏÔÊ½Ö¸¶¨ÈÎºÎÆäËû»ùÀà¡£
5. ¾²Ì¬Àà²»ÄÜÖ¸¶¨ÈÎºÎ½Ó¿ÚÊµÏÖ¡£
6. ¾²Ì¬ÀàµÄ³ÉÔ±²»ÄÜÓĞprotected»òÕßprotected internal·ÃÎÊ±£»¤ĞŞÊÎ·û¡£

ÈÃÎÒÃÇÔÙÀ´²Â²âÒ»ÏÂ MS ¿ª·¢ÈËÔ±µÄÏë·¨£ºËûÃÇµÄÄ¿µÄÊÇÏë»ñµÃ abstract sealed class µÄĞ§¹û£¬µ«È´ÎªÓïÒåÉÏµÄÃ¬¶Ü¶ø¿àÄÕ²»ÒÑ£¬´ó¼ÒÏë»ñµÃÒ»¸öÓÅÃÀµÄ½â¾ö·½Ê½£¬ÓÚÊÇ¾ÍÎª C# 2.0 ĞÂÔöÁËÒ»¸ö static ¹Ø¼ü×Ö£¬ÍêÃÀµÄ½â¾öÁËÕâ¸öÎÊÌâ¡£ 

Ò²ĞíÓĞÈË»áÎÊ£ºÎªÊ²Ã´²»ÊÇ static class = abstract class + static member limit ¶øÒª¼ÓÉÏ sealed µÄÏŞÖÆÄØ£¿ÀíÓÉÊÇ¼Ì³ĞÒ»¸öÖ»ÓĞ static ³ÉÔ±µÄÀàºÍÖØĞÂĞ´Ò»¸öÀàÍêÈ«Ã»ÓĞÇø±ğ¡£ÎªÊ²Ã´ÕâÃ´ËµÄØ£¿ÒòÎª static ±ØÈ»ÊÇnot virtual£¬¼Ì³ĞËüÓÖÄÜÓĞÊ²Ã´ÓÃÄØ£¿

static class »¹ÓĞÒ»¸öÏŞÖÆ£¬ÄÇ¾ÍÊÇÖ»ÄÜ´Ó System.Object ¼Ì³Ğ£¬ÎªÊ²Ã´»áÓĞÕâ¸öÏŞÖÆ£¬ÀíÓÉºÍÉÏÃæ²î²»¶à¡£

Ã¿Ã¿Ìáµ½ static ¹Ø¼ü×Ö£¬ÎÒ¾ÍÏëÆğÁË static constructor£¬¸ĞĞ» MS µÄ¿ª·¢ÈËÔ±Ìá¹©ÁËÕâÃ´ºÃµÄÒ»¸öÌØĞÔ¡£µ«ÊÇ C# Ìá¹©ÁË static constructor È´Ã»ÓĞÌá¹© static destructor£¬²»¹ıÔÚ Applied Microsoft .NET Framework Programming Ò»ÊéÖĞ Jeffery Richter ¸øÎÒÃÇÌá¹©ÁËÒ»¸ö°ì·¨¾ÍÊÇÍ¨¹ı System.AppDomain.DomainUnload ÊÂ¼şÈ¥´ïµ½Í¬ÑùµÄĞ§¹û¡£

Ê¹ÓÃ static constructor Òª×¢ÒâµÄ¾ÍÊÇÕâÀïÅ×³öÈÎºÎÒì³£¶¼»áµ¼ÖÂ¸ÃÀàĞÍÔÚÖØĞÂ¼ÓÔØ AppDoamin Ö®Ç°²»ÔÙ¿ÉÓÃ£¬ËùÒÔÒª¼Ó±¶Ğ¡ĞÄ£¬ÁíÍâ static contructor ÖĞºÜÈİÒ×ÓĞÁ½¸öÀàĞÍËÀËøµÄÇé¿ö·¢Éú£¬ÔÚ±àĞ´´úÂëµÄÊ±ºòÒ»¶¨ÒªÏëÇå³ş¡£


CIL Instructions
_________________________________________________
Format                Assembly Format   Description
0x00                  nop
0x01                  break             ¶ÏµãÉèÖÃ£¬ÎÒÕâÀïÓÃ×÷halt.
0x02                  ldarg.0           load argument onto the stack
0x03                  ldarg.1
0x04                  ldarg.2
0x05                  ldarg.3
0x06                  ldloc.0           load local variable onto the stack
0x07                  ldloc.1
0x08                  ldloc.2
0x09                  ldloc.3
0x0A                  stloc.0
0x0B                  stloc.1
0x0C                  stloc.2
0x0D                  stloc.3
0x0E                  ldarg.s num       Load argument numbered num onto the stack, short form.
0x0F                  ldarga.s argNum   Fetch the address of argument argNum, short form.
0x10                  starg.s num       Store value to the argument numbered num, short form.
0x11<unsigned int8>   ldloc.s indx      Load local variable of index indx onto stack, short form.
0x12<unsigned int8>   ldloca.s indx     Load address of local variable with index indx, short form.
0x13<unsigned int8>   stloc.s indx      Pop a value from stack into local variable indx, short form.
0x14                  ldnull            Push a null reference on the stack.
                                        [It might be thought that ldnull is redundant: why not use ldc.i4.0 or ldc.i8.0 instead? The answer is
                                        that ldnull provides a size-agnostic null ¨C analogous to an ldc.i instruction, which does not exist. However,
                                        even if CIL were to include an ldc.i instruction it would still benefit verification algorithms to retain the ldnull
                                        instruction because it makes type tracking easier. ] agnostic ²»¿ÉÖªµÄ
                                          ldc.<type>: load numeric constant
0x15                  ldc.i4.m1           Push -1 onto the stack as int32.
0x15                  ldc.i4.M1           Push -1 of type int32 onto the stack as int32 (alias for ldc.i4.m1).
0x16                  ldc.i4.0            Push 0 onto the stack as int32.
0x17                  ldc.i4.1
0x18                  ldc.i4.2
0x19                  ldc.i4.3
0x1A                  ldc.i4.4
0x1B                  ldc.i4.5
0x1C                  ldc.i4.6
0x1D                  ldc.i4.7
0x1E                  ldc.i4.8
0x1F<int8>            ldc.i4.s num        Push num onto the stack as int32, short form.
0x20<int32>           ldc.i4 num          Push num of type int32 onto the stack as int32.
0x21<int64>           ldc.i8 num          Push num of type int64 onto the stack as int64.
0x22<float32>         ldc.r4 num          Push num of type float32 onto the stack as F.
0x23<float64>         ldc.r8 num          Push num of type float64 onto the stack as F.
0x25                  Dup                 Duplicate the value on the top of the stack.
0x26                  pop                 remove the top element of the stack
0x27<T>               jmp method          Exit current method and jump to the specified method.
0x28<T>               call method         Call method described by method.
0x29<T>               calli callsitedescr Call method indicated on the stack with arguments described by callsitedescr.
0x2A                  Ret                 Return from method, possibly with a value.
0x2B<int8>            br.s target         Branch to target, short form. <unconditional branch>
0x2C<int8>            brfalse.s target    Branch to target if value is zero (false), short form.   ¶ÑÕ»µÄÖµ²âÊÔÍê±Ï£¬¾Í´Ó¶ÑÕ»ÒÆ³öÁË£¡ËùÓĞµÄ·ÖÖ§Ö¸Áî¶¼ÊÇÈç´Ë¡£
0x2D<int8>            brtrue.s target     Branch to target if value is non-zero (true), short form.
0x2E<int8>            beq.s target        Branch to target if equal, short form.
0x2F<int8>            bge.s target        Branch to target if greater than or equal to, short form.
0x30<int8>            bgt.s target        Branch to target if greater than, short form.
0x31<int8>            ble.s target        Branch to target if less than or equal to, short form.
0x32<int8>            blt.s target        Branch to target if less than, short form.
0x33<int8>            bne.un.s target     Branch to target if unequal or unordered, short form.
                                          The bne.un instruction transfers control to target if value1 is not equal to value2, when compared unsigned
                                          (for integer values) or unordered (for floating-point values).
                                          The effect is identical to performing a ceq instruction followed by a brfalse target.
0x34<int8> bge.un.s
0x35<int8> bgt.un.s
0x36<int8> ble.un.s
0x37<int8> blt.un.s
0x38<int32>           br target           Branch to target.<unconditional branch>
0x39 brfalse
0x3A brtrue
0x3B beq
0x3C bge
0x3D bgt
0x3E ble
0x3F blt
0x40 bne.un
0x41 bge.un
0x42 bgt.un
0x43 ble.un
0x44 blt.un
0x45<unsigned int32>  switch(t1, t2 ¡­ tN) table switch based on value. Jump to one of n values. Stack:(Value -- )
   <int32>¡­ <int32>                       The switch instruction implements a jump table. The format of the instruction is
                                           an unsigned int32 representing the number of targets N, followed by N int32 values
                                           specifying jump targets: these targets are represented as offsets (positive or negative)
                                           from the beginning of the instruction following this switch instruction.
0x46                  ldind.i1             Indirect load value of type int8 as int32 on the stack. Stack:(addr -- Value)
0x47                  ldind.u1
0x48                  ldind.i2
0x49                  ldind.u2
0x4A                  ldind.i4
0x4B                  ldind.u4
0x4C                  ldind.i8
0x4D                  ldind.i
0x4E                  ldind.r4
0x4F                  ldind.r8
0x50                  ldind.ref
0x51                  stind.ref
0x52                  stind.i1
0x53                  stind.i2
0x54                  stind.i4
0x55                  stind.i8
0x56                  stind.r4
0x57                  stind.r8
0x58                  add                 Add two values, returning a new value. (value1, value2 -- Result). <Only For Type-Safe value.>
0x59                  sub                 <Only For Type-Safe value.>
0x5A                  mul                 <Only For Type-Safe value.>
0x5B                  div                 <Only For Type-Safe value.>
0x5C                  div.un              <Only For Type-Safe value.>
0x5D                  rem                 <Only For Type-Safe value.>
0x5E                  rem.un              <Only For Type-Safe value.>
0x5F                  and                 <Only For Type-Safe value.>
0x60                  or                  <Only For Type-Safe value.>
0x61                  xor                 <Only For Type-Safe value.>
0x62                  shl                 <Only For Type-Safe value.>
0x63                  shr                 <Only For Type-Safe value.>
0x64                  shr.un              <Only For Type-Safe value.>
0x65                  neg                 <Only For Type-Safe value.>
0x66                  not                 <Only For Type-Safe value.>
0x67                 conv.i1               conv.<to type> ¨C data conversion. Convert to int8, pushing int32 on stack. (Value -- Result)
0x68                 conv.i2
0x69                 conv.i4
0x6A                 conv.i8
0x6B                 conv.r4
0x6C                 conv.r8
0x6D                 conv.u4
0x6E                 conv.u8
0x6F<T>              callvirt method      call a method associated, at runtime, with an object (obj, arg1, ¡­ argN -- Result<if any>)
0x70                 cpobj
0x71                 ldobj
0x72                 ldstr
0x73<T>              newobj ctor          create a new object   (arg1, ¡­ argN -- obj)
                                          allocate an uninitialized object or value type and call ctor. Ctor is a metadata token (a methodref or methodef that must be marked as a constructor).
0x74                 castclass
0x75                 isinst
0x76                 conv.r.un
0x79                 unbox
0x7A                 throw
0x7B                 ldfld
0x7C                 ldflda
0x7D                 stfld
0x7E                 ldsfld
0x7F                 ldsflda
0x80                 stsfld
0x81<T>              stobj typeTok           Store a value of type typeTok at an address. (dest, src --)
                                             If typeTok is a value type, the stobj instruction copies the value src to the address dest.
                                             If typeTok is a reference type, the stobj instruction has the same effect as stind.ref.
0x82                 conv.ovf.i1.un
0x83                 conv.ovf.i2.un
0x84                 conv.ovf.i4.un
0x85                 conv.ovf.i8.un
0x86                 conv.ovf.u1.un
0x87                 conv.ovf.u2.un
0x88                 conv.ovf.u4.un
0x89                 conv.ovf.u8.un
0x8A                 conv.ovf.i.un
0x8B                 conv.ovf.u.un
0x8C<T>              box typeTok             Convert a boxable value to its boxed form. (val -- obj)
                                             If typeTok is a value type, the box instruction converts val to its boxed form.
                                             When typeTok is a non-nullable type (¡ì1.8.2.4), this is done by creating a new
                                             object and copying the data from val into the newly allocated object. If it is
                                             a nullable type, this is done by inspecting val¡¯s HasValue property; if it is
                                             false, a null reference is pushed onto the stack; otherwise, the result of boxing
                                             val¡¯s Value property is pushed onto the stack. If typeTok is a reference type,
                                             the box instruction does nothing.
0x8D<T>              newarr etype            Create a zero-based, one-dimensional array  (numElems -- array)
0x8E                 ldlen
0x8F                 ldelema
0x90                 ldelem.i1
0x91                 ldelem.u1
0x92                 ldelem.i2
0x93                 ldelem.u2
0x94                 ldelem.i4
0x95                 ldelem.u4
0x96                 ldelem.i8
0x97                 ldelem.i
0x98                 ldelem.r4
0x99                 ldelem.r8
0x9A                 ldelem.ref
0x9B                 stelem.i
0x9C                 stelem.i1
0x9D                 stelem.i2
0x9E                 stelem.i4
0x9F                 stelem.i8
0xA0                 stelem.r4
0xA1                 stelem.r8
0xA2                 stelem.ref
0xA3                 ldelem
0xA4                 stelem
0xA5                 unbox.any
0xB3                 conv.ovf.i1
0xB4                 conv.ovf.u1
0xB5                 conv.ovf.i2
0xB6                 conv.ovf.u2
0xB7                 conv.ovf.i4
0xB8                 conv.ovf.u4
0xB9                 conv.ovf.i8
0xBA                 conv.ovf.u8
0xC2                 refanyval
0xC3                 ckfinite
0xC6                 mkrefany
0xD0                 ldtoken
0xD1                 conv.u2
0xD2                 conv.u1
0xD3                 conv.i
0xD4                 conv.ovf.i
0xD5                 conv.ovf.u
0xD6                 add.ovf
0xD7                 add.ovf.un
0xD8                 mul.ovf
0xD9                 mul.ovf.un
0xDA                 sub.ovf
0xDB                 sub.ovf.un
0xDC                 endfinally(endfault)    End finally(fault) clause of an exception block.
                                             Return from the finally or fault clause of an exception block
                                             (see the Exception Handling subclause of Partition I for details).
0xDD<int32>          leave target            Exit a protected region of code.
0xDE<int8>           leave.s target          Exit a protected region of code, short form.
                                             The leave instruction unconditionally transfers control to target.
                                             target is represented as a signed offset (4 bytes for leave, 1 byte
                                             for leave.s) from the beginning of the instruction following the current instruction.
                                             The leave instruction is similar to the br instruction, but the former can be used
                                             to exit a try, filter, or catch block whereas the ordinary branch instructions can
                                             only be used in such a block to transfer control within it. The leave instruction
                                             empties the evaluation stack and ensures that the appropriate surrounding finally blocks
                                             are executed.
0xDF                 stind.i
0xE0                 conv.u
0xFE 0x00            arglist
0xFE 0x01            ceq
0xFE 0x02            cgt
0xFE 0x03            cgt.un
0xFE 0x04            clt
0xFE 0x05            clt.un
0xFE 0x06            ldftn
0xFE 0x07            ldvirtftn
0xFE 0x09            ldarg
0xFE 0x0A            ldarga
0xFE 0x0B            starg
0xFE 0x0C            ldloc
0xFE 0x0D            ldloca
0xFE 0x0E            stloc
0xFE 0x0F            localloc
0xFE 0x11            endfilter                 End an exception handling filter clause. (value -- )
                                               Used to return from the filter clause of an exception
                                               (see the Exception Handling subclause of Partition I for a
                                               discussion of exceptions). value (which shall be of type int32
                                               and one of a specific set of values) is returned from the filter
                                               clause. It should be one of:
                                                 * exception_continue_search (0) to continue searching for an exception handler
                                                 * exception_execute_handler (1) to start the second phase of exception handling where
                                                   finally blocks are run until the handler associated with this filter clause is located. Then the
                                                   handler is executed.
                                               The result of using any other integer value is unspecified.

0xFE 0x12            unaligned.
0xFE 0x13            volatile.
0xFE 0x14            tail.
0xFE 0x15            initobj
0xFE 0x17            cpblk
0xFE 0x18            initblk
0xFE 0x1A            rethrow
0xFE 0x1C            sizeof
0xFE 0x1D            refanytype

TurboScript Extented Instructions:


_________________________________________________
C# 2.0 Ö® partial[1]
×÷Õß£ºØıÃû    ÎÄÕÂÀ´Ô´£º±¾Õ¾ÊÕ²Ø    µã»÷Êı£º3    ¸üĞÂÊ±¼ä£º2006-11-4     	
           	¡¾×ÖÌå£ºĞ¡ ´ó¡¿
³£³£¿´¼û´ó¼ÒÔÚÈÈ»ğ³¯ÌìµÄÌÖÂÛ VS.Net Whidbey ºÍ .Net FrameWork 2.0 µÄĞÂ¹¦ÄÜ£¬¶øÎÒÈ´ÏÖÔÚ»¹ÔÚÕâ±ß±È¶ÔÁË°ëÌì²Å¸ÒÈ·¶¨ÎÒµÄ¡°Whidbey¡±ÕâÆß¸ö×ÖÄ¸Ã»ÓĞÇÃ´í¡££º£¨

½ñÌì¸Õ¸ÕÔÚ VPC ÖĞ×°ÉÏÁË VS.Net 2005 Community Technology Preview£¬¾öĞÄºÃºÃÌåÑéÒ»°Ñ .Net Framework 2.0 ºÍ C# 2.0 µÄÏ¬ÀûÖ®´¦¡£

´ò¿ªĞÂµÄ VS.Net£¬ĞÂ½¨Ò»¸ö WinForm Application£¬ÂíÉÏ¾Í·¢ÏÖÁË²»Í¬Ö®´¦£º¡°´°ÌåÉè¼ÆÆ÷Éú³ÉµÄ´úÂë¡±ÄÄÀïÈ¥ÁË£¿InitializeComponent()ÄÇÀïÈ¥ÁË£¿

¶ËÏêÆ¬¿Ì£¬²Å·¢ÏÖÔ­À´ÊÇÕâ¸ö partial ¹Ø¼ü×Ö¸ãµÄ¹í¡£

partial ¹Ø¼ü×ÖµÄ×÷ÓÃÊÇ½«ÄãµÄ class ·ÖÎª¶à¸ö²¿·Ö£¬±àÒëÆ÷»á½«¶à¸ö²¿·ÖÆ´µ½Ò»ÆğÈ¥¡£

public partial class SampleClass
...{
public void MethodA()
...{
}
}

public partial class SampleClass
...{
public void MethodB()
...{
}
}

ºÍ

public class SampleClass
...{
public void MethodA()
...{
}
public void MethodB()
...{
}
}


ÊÇµÈ¼ÛµÄ¡£

ÎÒ²ÂÏëÕâ¸ö¶«Î÷³öÏÖµÄ³õÖÔÊÇÎªÁË½â¾öµô£º¡°´°ÌåÉè¼ÆÆ÷Éú³ÉµÄ´úÂë¡±Õâ¸öÁîÈËÌÖÑáµÄ region¡£

¶ÔÎÒÃÇÀ´Ëµ£¬ÔÚÍÅ¶Ó¿ª·¢µ±ÖĞÕâ¸ö¶«Î÷»òĞíÒ²»áÓĞµãÓÃ´¦¡£

ÎÒ¹Û²ìÁËÒ»ÏÂÉú³ÉµÄ IL ´úÂë£¬Ê¹ÓÃ partial Éú³ÉµÄ´úÂë²¢Ã»ÓĞÊ²Ã´ÌØÊâµÄ±ê¼Ç£¬ÕâËµÃ÷ partial ´¿´âÊÇÓïÑÔµÄÌØĞÔ£¬CLR ÍêÈ«²»ÖªµÀÕâÃ´¸öÍæÒâµÄ´æÔÚ£¬ÕâÒ²¾ÍÒâÎ¶×Å²»ÒªÖ¸Íû½« partial class ±àÒëÎª assembly »òÕß module Ê²Ã´µÄÔÙÓëÆäËûµÄÈËĞ´µÄ partial class È¥½øĞĞÆ´½Ó£ºËüÖ»ÄÜÔÚ±àÒëµÄÊ±ºòÆğ×÷ÓÃ¡£

ÎªÁË¿¼ÑéÒ»ÏÂ±àÒëÆ÷£¬ÎÒÊÔ×ÅÈÃÄ³Ò»¸ö partial class ²»ÏÔÊ½Ö¸¶¨¸¸Àà£¬·¢ÏÖ´úÂëÈÔÈ»ÄÜ¹»ÕıÈ·µÄÍ¨¹ı±àÒë£¬±àÒëÆ÷»á°´ÕÕÄ³Ò»¸öÏÔÊ½Ö¸¶¨ÁË¸¸ÀàµÄ partial ½øĞĞ±àÒë£¬Ö»ÓĞÔÚ¶à¸ö partial Ö¸¶¨ÁË²»Í¬¸¸ÀàÊ±²Å»á±¨´í¡£Í¬Ñù£¬Èç¹û¶à¸ö partial Ö¸¶¨ÁË×ÔÏàÃ¬¶ÜµÄĞŞÊÎ·ûµÄ»°£¬±àÒëÊ±Ò²»á±¨´íµÄ¡£

ÓĞÒâË¼µÄÊÇ£¬ÎÒÃÇ»¹¿ÉÒÔĞ´ÒÔÏÂÕâÑùµÄ´úÂë£º

public partial class Sample
...{
public partial class SampleSon
...{
public partial class SampleGrandson
...{
}
}
}
public partial class Sample
...{
public partial class SampleSon
...{
public partial class SampleGrandson
...{
}
}
}

ÁõÃô£¨Rustle Liu£© http://ms.mblogger.cn/rustle/ 

_________________________________________________

Static Classes and Static Class Members (C# Programming Guide) 

Static classes and class members are used to create data and functions that can be accessed without creating an instance of the class. Static class members can be used to separate data and behavior that is independent of any object identity: the data and functions do not change regardless of what happens to the object. Static classes can be used when there is no data or behavior in the class that depends on object identity.
Static ClassesStatic Classes

A class can be declared static, indicating that it contains only static members. It is not possible to create instances of a static class using the new keyword. Static classes are loaded automatically by the .NET Framework common language runtime (CLR) when the program or namespace containing the class is loaded.

Use a static class to contain methods that are not associated with a particular object. For example, it is a common requirement to create a set of methods that do not act on instance data and are not associated to a specific object in your code. You could use a static class to hold those methods.

The main features of a static class are:

    *

      They only contain static members.
    *

      They cannot be instantiated.
    *

      They are sealed.
    *

      They cannot contain Instance Constructors (C# Programming Guide).

Creating a static class is therefore much the same as creating a class that contains only static members and a private constructor. A private constructor prevents the class from being instantiated.

The advantage of using a static class is that the compiler can check to make sure that no instance members are accidentally added. The compiler will guarantee that instances of this class cannot be created.

Static classes are sealed and therefore cannot be inherited. Static classes cannot contain a constructor, although it is still possible to declare a static constructor to assign initial values or set up some static state. For more information, see Static Constructors (C# Programming Guide).
When to Use Static ClassesWhen to Use Static Classes

Suppose you have a class CompanyInfo that contains the following methods to get information about the company name and address.
C#

class CompanyInfo
{
    public string GetCompanyName() { return "CompanyName"; }
    public string GetCompanyAddress() { return "CompanyAddress"; }
    //...
}

These methods do not need to be attached to a specific instance of the class. Therefore, instead of creating unnecessary instances of this class, you can declare it as a static class, like this:
C#

static class CompanyInfo
{
    public static string GetCompanyName() { return "CompanyName"; }
    public static string GetCompanyAddress() { return "CompanyAddress"; }
    //...
}

Use a static class as a unit of organization for methods not associated with particular objects. Also, a static class can make your implementation simpler and faster because you do not have to create an object in order to call its methods. It is useful to organize the methods inside the class in a meaningful way, such as the methods of the Math class in the System namespace.
Static MembersStatic Members

A static method, field, property, or event is callable on a class even when no instance of the class has been created. If any instances of the class are created, they cannot be used to access the static member. Only one copy of static fields and events exists, and static methods and properties can only access static fields and static events. Static members are often used to represent data or calculations that do not change in response to object state; for instance, a math library might contain static methods for calculating sine and cosine.

Static class members are declared using the static keyword before the return type of the member, for example:
C#

public class Automobile
{
    public static int NumberOfWheels = 4;
    public static int SizeOfGasTank
    {
        get
        {
            return 15;
        }
    }
    public static void Drive() { }
    public static event EventType RunOutOfGas;

    //other non-static fields and properties...
}

Static members are initialized before the static member is accessed for the first time, and before the static constructor, if any is called. To access a static class member, use the name of the class instead of a variable name to specify the location of the member. For example:
C#

Automobile.Drive();
int i = Automobile.NumberOfWheels;

ExampleExample

Here is an example of a static class that contains two methods that convert temperature from Celsius to Fahrenheit and vice versa:
C#

public static class TemperatureConverter
{
    public static double CelsiusToFahrenheit(string temperatureCelsius)
    {
        // Convert argument to double for calculations.
        double celsius = System.Double.Parse(temperatureCelsius);

        // Convert Celsius to Fahrenheit.
        double fahrenheit = (celsius * 9 / 5) + 32;

        return fahrenheit;
    }

    public static double FahrenheitToCelsius(string temperatureFahrenheit)
    {
        // Convert argument to double for calculations.
        double fahrenheit = System.Double.Parse(temperatureFahrenheit);

        // Convert Fahrenheit to Celsius.
        double celsius = (fahrenheit - 32) * 5 / 9;

        return celsius;
    }
}

class TestTemperatureConverter
{
    static void Main()
    {
        System.Console.WriteLine("Please select the convertor direction");
        System.Console.WriteLine("1. From Celsius to Fahrenheit.");
        System.Console.WriteLine("2. From Fahrenheit to Celsius.");
        System.Console.Write(":");

        string selection = System.Console.ReadLine();
        double F, C = 0;

        switch (selection)
        {
            case "1":
                System.Console.Write("Please enter the Celsius temperature: ");
                F = TemperatureConverter.CelsiusToFahrenheit(System.Console.ReadLine());
                System.Console.WriteLine("Temperature in Fahrenheit: {0:F2}", F);
                break;

            case "2":
                System.Console.Write("Please enter the Fahrenheit temperature: ");
                C = TemperatureConverter.FahrenheitToCelsius(System.Console.ReadLine());
                System.Console.WriteLine("Temperature in Celsius: {0:F2}", C);
                break;

            default:
                System.Console.WriteLine("Please select a convertor.");
                break;
        }
    }
}

InputInput

2

98.6

Sample Output:Sample Output:

Please select the convertor

1. From Celsius to Fahrenheit.

2. From Fahrenheit to Celsius.

:2

Please enter the Fahrenheit temperature: 98.6

Temperature in Celsius: 37.00

Additional sample output might look as follows:

Please select the convertor

1. From Celsius to Fahrenheit.

2. From Fahrenheit to Celsius.

:1

Please enter the Celsius temperature: 37.00

Temperature in Fahrenheit: 98.60
C# Language SpecificationC# Language Specification

For more information, see the following sections in the C# Language Specification:

    *      25.2 Static Classes

See AlsoSee Also