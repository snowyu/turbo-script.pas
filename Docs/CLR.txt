CIR(Common Intermediate Language (CIL))·ÖÎö

Êı¾İÕ»£º
Ëü³ÆÖ®Îª evaluation stack£¬ Êı¾İÕ»´æ·ÅÊı¾İµÄ×îĞ¡µ¥Î»ÊÇ4×Ö½ÚµÄ32Î»ÕûÊı¡£

ËüµÄ¼Ó·¨Ö¸ÁîÖ»ÓĞÒ»ÖÖĞÎÊ½£¬ÕâËµÃ÷ËüµÄ¼Ó·¨Ö¸ÁîµÄÊı¾İÀàĞÍÊÇºóÆÚÔ¼ÊøµÄ£¬²»¹ıÕâÑùÒ»À´£¬¹¹³É¼Ó·¨µÄÖ¸ÁîµÄÊı¾İ±ØĞëÒªÓĞÊı¾İÀàĞÍÁË£¡
CLR ±ÈÎÒ¶àÁËÒ»¸ö²ÎÊı±íÓÃÓÚ´«µİ¹ı³ÌµÄ²ÎÊı¡£

= CLI Architecture =
The Common Language Infrastructure (CLI) provides a specification for executable code and the execution environment (the Virtual Execution System, or VES) in which it runs.

The general CLI architecture as it relates to supporting mobile code, specifically
including
 *  ĞéÄâ»úÉè¼Æ
    * Ïß³Ì
    * ¶¯Ì¬°ó¶¨ classes, assemblies, and application domains.
    * ·Ö²¼Ê½ÎÄ¼ş¼ÓÔØ
    * ±£»¤»úÖÆ
    * CTS(Common Type System) - Self-describing type system
    * Cross assembly method/member function invocation
    * Side-by-side execution (simultaneous support for separate versions of the same component)
    * Managed and unmanaged code interoperability(Ğ­Í¬¹¤×÷ÄÜÁ¦)
 *  Ô´ÓïÑÔ¶ÀÁ¢ Source language independence
 *  Èí¼ş×é¼ş°æ±¾¹ÜÀí Software component version management
 *  Èí¼ş·Ö·¢Ä£Ê½ The software deployment model
 *  °²È«»úÖÆ Security mechanisms that address the mechanism that allows such general distribution of mobile code
 *  CLI Í¨Ñ¶»úÖÆ CLI communication mechanisms


== Ä£¿é(Module) ==
Ä£¿é(Module)ÀàËÆÓÚÒÔÇ°µÄµ¥Ôª£¬ÓÃÓÚ·Ö¸î²»Í¬µÄÀàºÍÀàĞÍ£¬ÒÔ¼°×ÊÔ´(resource, ×ÊÔ´¼ÇÂ¼¾ÍÊÇ×Ö·û´®£¬Í¼ÏóÒÔ¼°ÆäËüÊı¾İ£¬ËûÃÇÖ»ÔÚĞèÒªµÄÊ±ºò²Å»á±»µ÷ÈëÄÚ´æ)¡£ÀàĞÍµÄMetaĞÅÏ¢Ò²ÊÇÄ£¿éµÄÒ»²¿·Ö¡£
CLR µÄ³ÌĞò¼¯ÊÇÓÉÄ£¿é¹¹³ÉµÄ£¬CLR Ä£¿éÊÇÒ»ÖÖÁ÷Êı¾İ£¨×Ö½ÚÁ÷£©£¬Í¨³£ÊÇÒÔÎÄ¼şµÄĞÎÊ½´æÔÚÓÚ±¾µØÎÄ¼şÏµÍ³»òWeb·şÎñÆ÷ÉÏ¡£

¼ÈÈ»Ä£¿éÖÖ°üº¬ÀàĞÍµÄMetaĞÅÏ¢£¬ÀàĞÍ¼ì²éÏµÍ³¾Í¿ÉÒÔÁªºÏ¾²Ì¬ºÍ¶¯Ì¬¼¼Êõ¡£µ±ILÔËĞĞµÄÊ±ºò£¬Ö´ĞĞ»·¾³ÄÜµÃÖª
ËùÓĞ±äÁ¿²ÎÊıµÄÀàĞÍMetaĞÅÏ¢£¬×ÔÈ»¾ÍÄÜÖ´ĞĞÔËĞĞÊ±¿ÌµÄÀàĞÍ¼ì²é¡ª¡ªÕâ±»³ÆÖ®Îª reflection(ËüµÄº¬ÒåÎª½âÊÍ×ÔÃèÊöÀàĞÍ£¬ÀàĞÍµÄÓ°×Ó)¡£

== ³ÌĞò¼¯(Assembly) ==
³ÌĞò¼¯(Assembly)±¾Éí¾ÍÊÇÒ»¸öÄ£¿é£¬³ÌĞò¼¯(Assembly)ºÍÄ£¿é(Module)¼äµÄÇø±ğ£¬ÔÚÓÚ¶àÁËÒ»¸öÎ¬»¤Çåµ¥ manifest ¡¾ÃèÊöÒıÓÃÁËÄÄĞ©³ÌĞò¼¯£¬°üº¬ÁËÄÇĞ©Ä£¿éÎÄ¼ş£¬µ¼³öÁËÄÄĞ©ÀàĞÍ£¨ÆäËüÄ£¿éÖĞµÄ£©£¬ÒÔ¼°¶Ô×ÔÉíµÄÃèÊö¡¿¡£

¶à¸öÄ£¿éÎÄ¼ş¿ÉÒÔ±»Á´½Ó³ÉÒ»¸ö³ÌĞò¼¯(assembly)¡£ÔÚ³ÌĞò¼¯ÉÏ¶àÁËÒ»¸öÇåµ¥£¨manifest£©£¬ÓÃÀ´ÃèÊö¸Ã³ÌĞò¼¯ÒÔ¼°Ä£¿éµÄÁĞ±í£¬Ò»¸öÖ÷Èë¿Ú£¬µ¼³öµÄÀàĞÍ¶¨ÒåÁĞ±í£¨Ë½ÓĞÄ£¿éÖĞ¹«¿ªµÄÀàĞÍ£©¡£Õâ·İÇåµ¥±»·ÅÔÚÒ»¸öÄ£¿éÉÏ£¬
ÔÚ¸ÃÄ£¿éÉÏµÄ¹«¿ªµÄÀàĞÍ²»»á³öÏÖÔÚµ¼³öÀàĞÍ¶¨ÒåÁĞ±íÉÏ£¡

³ÌĞò¼¯ÊÇCLI·¢²¼¹ÜÀí(deployment managed)µÄµ¥Î»¡£³ÌĞò¼¯ÊÇ¿ÉÖØÓÃµÄÈí¼ş×é¼ş¡£³ÌĞò¼¯ÉõÖÁÄÜ¶¯Ì¬°ó¶¨µ÷ÓÃ´úÂë¡£
  * ³ÌĞò¼¯ÊÇ¶ÀÁ¢µÄÈí¼ş×é¼ş×Ó¼¯£¬ÎŞĞëÖØĞÂ±àÒë¡£
  * ³ÌĞò¼¯ÊÇ¶¨ÖÆÈí¼ş
  * ³ÌĞò¼¯ÄÜ±»¶ÀÁ¢·¢²¼
  * ³ÌĞò¼¯µ¼³öµÄAPIÄÜºÍÆäËü×é¼şÍêÃÀµÄ½»»¥¡£

³ÌĞò¼¯ÔÚÎÄ¼şÏµÍ³ÖĞÊÇÓÃPE(portable executable)¸ñÊ½´æ·Å¡£ÒıÓÃµÄ³ÌĞò¼¯ÊÇ°´Ğè¼ÓÔØµÄ£¬»»¾ä»°Ëµ£¬Ö»ÓĞµ±µ÷ÓÃµ½¸Ã³ÌĞò¼¯µÄº¯Êı»òÀàĞÍÖ®ºó£¬¸Ã³ÌĞò¼¯²Å»á±»¼ÓÔØ£º
  ³ÌĞò¼¯¼ÓÔØÆ÷(assembly loader)½«µ÷ÓÃ CLI ÏÂÔØÆ÷(downloader)¼ÓÔØ¸Ã³ÌĞò¼¯
    CLI ÏÂÔØÆ÷ ¸ù¾İËÑË÷Ë³Ğò´ÓÓ¦ÓÃ³ÌĞòÄ¿Â¼£¬×ÓÄ¿Â¼£¬±¾µØÎÄ¼şCacheÄ¿Â¼£¬»òÍøÂçURLÖĞ×°ÔØ¡£

JefferµÄÊéÖĞËµ£¬Çåµ¥ÔªÊı¾İ±íÖĞÓĞÒ»·İÃû½ĞExportedTypesDefµÄ±í£¬ÆäÖĞ¶¨ÒåÁËËùÓĞµÄµ¼³öÀàĞÍÌõÄ¿¡£µ«ÊÇÎÒÔÚ²é¿´µ¥ÎÄ¼ş³ÌĞò¼¯µÄÊ±ºòÈ´Ã»ÓĞ·¢ÏÖÔªÊı¾İµ±ÖĞÓĞExportedTypesµÄ¶¨Òå¡£ºóÀ´ÓÖ×ĞÏ¸¿´ÁËÒ»ÏÂÊé²ÅÃ÷°×£¬ÎªÁË½ÚÊ¡ÎÄ¼ş¿Õ¼ä£¬ËùÒÔÔÚÔªÊı¾İ¶¨ÒåÔªÊı¾İ±íÖĞËù¶¨ÒåµÄµ¼³öÀàĞÍÊÇ²»»áÔÚExportedTypesDef±íÖĞÖØ¸´³öÀ´µÄ¡£ÕâÒ²¾ÍÊÇËµ£¬Ö»ÓĞµ±Ò»¸ö³ÌĞò¼¯ÊÇÓÉ¶à¸öÄ£¿é¿éÎÄ¼ş×é³ÉµÄÊ±ºò£¬ÆäËüÄ£¿éÎÄ¼şÖĞµ¼³öµÄÀàĞÍ²Å»áÔÚ³ÌĞò¼¯Çåµ¥ÖĞ±»¶¨Òå¡£Ê¹ÓÃÁËÕâÖÖ¶¨Òå·½Ê½¡£Ïàµ±ÓÚÔÚ³ÌĞò¼¯Çåµ¥ÖĞÌá¹©Ò»¸ö²éÕÒ³ÌĞòÖĞËù¶¨ÒåÀàĞÍµÄË÷Òı¡£µ±CLR²éÕÒ³ÌĞò¼¯ÖĞÀàĞÍÊ±£¬Ëü»á¸ù¾İ³ÌĞò¼¯Çåµ¥ ExportdTypesDef±íµÄ¶¨Òå£¬ÔÚÏàÓ¦µÄÄ£¿éÎÄ¼şµ±ÖĞ²éÕÒµ½ĞèÒªµÄÀàĞÍ¶¨Òå¡£

Ò»¸ö.net³ÌĞò¼¯Ö§³ÖÈıÖÖ°æ±¾£¬Ëü¶¼ÊÇÊ¹ÓÃÌØĞÔµÄ·½Ê½ÔÚÔ´´úµ±ÖĞÖ¸¶¨µÄ£¬È»ºóÓÉ±àÒëÆ÷/Á´½ÓÆ÷½«ËüÃÇÇ¶Èëµ½.net³ÌĞòµ±ÖĞ£¨³ÌĞòÎÄ¼ş£©¡£ÕâÈıÖÖ°æ±¾ºÅ¶ÔÓ¦µÄÌØĞÔÃû³ÆºÍÆä×÷ÓÃÈçÏÂËùÊ¾£º
AssemblyFileVersion£ºÕâ¸öÌØĞÔËù±êÊ¶µÄ°æ±¾ºÅ¶ÔÓ¦´«Í³Win32³ÌĞòµÄÎÄ¼ş°æ±¾ºÅ¡£CLR±¾Éí²¢²»Ê¹ÓÃ´Ë°æ±¾ºÅ¡£
AssemblyInformation£ºÕâ¸öÌØĞÔËù±êÊ¶µÄ°æ±¾ºÅ¶ÔÓ¦´«Í³Win32³ÌĞòµÄ²úÆ·°æ±¾ºÅ¡£CLR±¾Éí²¢²»Ê¹ÓÃ´Ë°æ±¾ºÅ¡£
AssemblyVersion£ºÕâ¸öÌØĞÔ±êÊ¶µÄ°æ±¾ºÅÎªCLR±¾ÉíËùÊ¶±ğµÄ°æ±¾ºÅ£¬CLRÍ¨¹ıÕâ¸ö°æ±¾ºÅÀ´È·¶¨³ÌĞò¼¯µÄ°æ±¾¡£
ÕâÀïĞèÒª×¢ÒâµÄÊÇ£¬AssemblyFileVersionµÄbuildÎ»ºÍfixÎ»Ó¦¸ÃÊÇÒ»¸öµÚ´ÎÖØĞÂ±àÒëºó¶¼ÓĞËù²»Í¬µÄ°æ±¾ºÅ£¬³ÌĞòµÄÓÃ»§ôßÒÔ´Ë°æ±¾ºÅÀ´Çø·ÖÒ»¸öÖ÷°æ±¾ºÅ(ÓÉMajorºÍMinor×é³ÉµÄ°æ±¾ºÅ£©ÄÚ³ÌĞò¼¯µÄ²»Í¬¡£
¶øAssemblyVersion°æ±¾ºÅÔòÊÇÓ¦¸ÃÔÚÒ»¸öÖ÷°æ±¾ºÅÄÚ¹Ì¶¨²»±äµÄ£¬ÒòÎªCLRÊÇÊ¹ÓÃ´Ë°æ±¾ºÅÀ´È·¶¨¼ÓÔØ³ÌĞò¼¯µÄ¡£

== AppDomainºÍµØÖ·¿Õ¼ä ==

Ò»¸ö³ÌĞò¼¯½«±»¼ÓÔØµ½Ò»¸öApplication Domain(AppDomain)ÖĞÖ´ĞĞ¡£ Íâ²¿ÒıÓÃµÄÆäËü³ÌĞò¼¯½«ÔÚÍ¬ÑùÍ¬Ò»AppDomainÏÂÔËĞĞ¡£
»»¾ä»°Ëµ£¬AppDomain ½«³ÌĞò¼¯¾Û¼¯ÔÚÒ»Æğ£¬ÊµÏÖ×îÖÕ¹¦ÄÜ¡£
Ã¿Ò»¸öAppDomain¶¨ÒåÁËÒ»¸öÓÉCLIÖ´ĞĞÒıÇæ¹ÜÀíµÄµØÖ·¿Õ¼ä¡£ËùÓĞµÄµØÖ·ÒıÓÃ½«È·±£ÊµÔÚÍ¬Ò»¸öAppDomainÖĞ¡£
CLIµØÖ·¿Õ¼äÊÇÓĞ²ã´ÎµÄ£ºAppDomain ÄÜ±»¼ÓÔØÈëÒ»¸öCLIµØÖ·¿Õ¼ä¡£
CLIµØÖ·¿Õ¼ä¿ÉÒÔ±»¸ÅÂÔµÄÈÏÎªÊÇOSÖĞµÄ½ø³ÌµØÖ·¿Õ¼ä£¨ÖÁÉÙÔÚRotor CLIÖĞÊÇÕâÑù£©¡£Ã¿Ò»¸öµØÖ·¿Õ¼ä¶¼ÓĞÃ÷È·µÄµØÖ·±ß½ç¡£

Ã¿Ò»¸öCLIµØÖ·¿Õ¼ä¿ÉÒÔ°üº¬¶à¸öAppDomain£º ÆäÖĞÒ»¸öAppDomain¾ÍÊÇÏµÍ³³ÌĞò¼¯£¬ÁíÒ»¸öAppDomain°üº¬ÓëÆäËûÓëAppDomain¹²ÏíµÄ³ÌĞò¼¯¡£
Ö»ÓĞCLI¹ÜÀíÆ÷(the supervision of the CLI)²ÅÄÜ¿çÔ½AppDomainµÄµØÖ·¿Õ¼ä·ÃÎÊ½øĞĞ½»»¥¡£AppDomainÖ®¼äµÄ½»»¥Í¨Ñ¶ÊÇÍ¨¹ıÔ¶³Ì(Remoting)ÀàĞÍ¼ì²é»úÖÆ
Íê³É¡£Í¬ÑùµÄ»úÖÆ±»ÓÃÓÚ¿çÔ½µØÖ·¿Õ¼ä£¬Èç½Ó¿ÚºÍOS IPC.

Ä£¿é£¬³ÌĞò¼¯£¬AppDomainºÍµØÖ·¿Õ¼ä£¨address space£©µÄ¹ØÏµÊÇ£¬Ä£¿éÊÇ±àÒëÆ÷½¨Á¢µÄ×îĞ¡µÄµ¥ÔªÎÄ¼ş£¬ÓÉÒ»¸ö»òn¸öÄ£¿é×é³É³ÌĞò¼¯£¬³ÌĞò¼¯ÊÇ½øĞĞ·Ö·¢µÄ
×îĞ¡µ¥ÔªÎÄ¼ş£¬³ÌĞò¼¯ÄÜ×éºÏÔÚÒ»¸öAppDomainÏÂÖ´ĞĞ¡£¶à¸öAppDomainÄÜÔÚµ¥¸öµØÖ·¿Õ¼äÏÂÖ´ĞĞ¡£

¡¾ÎÊ¡¿1. Èç¹û¶ÔÆäËü³ÌĞò¼¯¹ı³ÌµÄµ÷ÓÃ£¬ÒâÎ¶×ÅĞèÒª¿ª±ÙĞÂµÄVirtualExecutionEngine?,¶ÑÕ»ÕâĞ©È«²¿¶¼ÒªĞÂµÄ£¿£¿
  2. address space ÊÇÔõÃ´¹¹ÔìµÄ£¿×î¶àÄÜÈİÄÉ¼¸¸öAppDomain£¿Ê²Ã´Ê±ºòĞèÒªĞÂ½¨ÁíÍâÒ»¸öaddress space£¿
¡¾´ğ¡¿
2¡¢»ù±¾ÉÏ Ò»¸öCLR Host½ø³Ì¾ÍÊÇÒ»¸öaddress space£¬È»ºó½¨Á¢¶à¸ö AppDomain£¬ÖÁÓÚ¸öÊıÄÇÊÇÎŞËùÎ½µÄ¡£AppDomain Ê¹ÓÃÀ´¸ôÀë³ÌĞò¼¯µÄ¡£±ÈÈç£º ASP.Net »òÕß  Microsoft SQL Server¡£
Ã¿Ò»¸öAppDomainÖ®¼ä²»ÄÜ±Ë´ËÓ°Ïì£¬ÊÇÍêÈ«¶ÀÁ¢µÄ£¬ÕâÑù±£Ö¤ÁËAppDomainµÄ°²È«£¡±ØĞë×öµ½Ò»¸öAppDomainÖĞ³öÁË´íÎó£¬¶ø²»Ó°Ïìµ½ÁíÒ»¸öAppDomain.

×¢£º
Common Language Infrastructure (CLI) Í¨ÓÃÓïÑÔ»ù´¡×éÖ¯

== Virtual Execution System(VES) ==
VESÊÇCLI DVM(·Ö²¼Ê½ĞéÄâ»ú)µÄĞÄÔà¡£Execution Engine (EE) ÔòÊÇÆäºËĞÄÁË£¬´úÂëÔÚ MSCOREE (Microsoft Common Object Runtime EE ¨C a name that is left over from the commercial
CLR code) ÖĞ¡£
ÒıÓÃµÄ³ÌĞò¼¯¿ÉÒÔ´æÔÚÓÚÈÎºÎµØ·½£¬±ÈÈçÒ»Ì¨web·şÎñÆ÷ÉÏ£¬µ±EE±»ÇëÇó×°ÔØ(Downloading)¸Ã³ÌĞò¼¯µÄÊ±ºò£¬½«»á×öÒÔÏÂµÄÊÂÇé£º
  ¼ì²éµ÷ÓÃÕßÈÏÖ¤
  ¼ì²é³ÌĞò¼¯ÊÇ·ñÓĞĞ§
  Ò»ÇĞ¸ã¶¨Ôò½«³ÌĞò¼¯×°ÔØµ½AppDomain
Ò»µ©³ÌĞò¼¯±»¼ÓÔØµ½AppDomain,ÄÇÃ´ÔÚAppDomainÖĞµÄÆäËü´úÂë½«ÄÜ·ÃÎÊ¸Ã³ÌĞò¼¯ÖĞµÄ¹«¿ª³ÉÔ±ºÍ×Ö¶Î£¬µ±È»ÉÏÔÚEEµÄ¼à¶½ÏÂ¡£
²»¹ıÕâÊ±ºò£¬³ÌĞò¼¯ÖĞµÄÀà²¢Ã»ÓĞ±»°ó¶¨µ½´úÂë£¬Ö»ÓĞµ±¶Ô¸ÃÀàµÄµ÷ÓÃÕæµÄ·¢ÉúµÄÊ±ºò£¬EE²Å»áÈ¥²éÕÒÔÚ³ÌĞò¼¯ÖĞµÄÄ¿±êÀà²¢½«Æä
×°ÔØÈëAppDomain£¬È»ºóĞ£Ñé·ÃÎÊĞí¿É£¬´Ó¸ÃÀàµÄMetaĞÅÏ¢ÖĞÌáÈ¡Ä¿±êÀàµÄÏ¸½ÚËµÃ÷£¬È»ºóBuild an appropriate call table data structure.
µ±µÚÒ»´ÎÒıÓÃÀà³ÉÔ±µÄÊ±ºò£¬ËüµÄĞÎÊ½»¹ÊÇÖĞ¼ä´úÂë£¬CLI ×ÜÊÇÊ¹ÓÃJIT±àÒëÆ÷(JITter)½«ÖĞ¼ä´úÂë·­Òë³É±¾µØ»úÆ÷Âë£¬È»ºóµ±ÏÂ´ÎÔÙ´Î
ÒıÓÃµÄÊ±ºò¾Í»áÖ±½ÓÖ´ĞĞ±àÒëºÃµÄ±¾µØ»úÆ÷Âë¡£EE»¹°üÀ¨ÁËÀ¬»øÊÕ¼¯Æ÷ºÍ½á¹¹»¯Òì³£´¦ÀíÆ÷¡£

EE Ö´ĞĞÁ÷³Ì£¬Í¨¹ıÒ»¸ö×î¼òµ¥µÄÖ÷³ÌĞòËµÃ÷£º
static void Main() {
  Console.WriteLine("Hello");
}

ÔÚ Main ·½·¨±»Ö´ĞĞÇ°£¬CLR½«¼ì²âËùÓĞ±»MainÖĞµÄ´úÂëÒıÓÃµÄÀàĞÍ£¬CLR½«»áÎªËùÓĞµÄÒıÓÃÀàĞÍ·ÖÅäÒ»¿éÄÚ²¿Êı¾İ£¬ÄÚ²¿Êı¾İÖĞ°üº¬ÁË¶¨ÒåµÄÀàĞÍÖĞµÄÃ¿Ò»¸ö·½·¨µÄÈë¿Ú¡£
Ã¿Ò»¸ö·½·¨Èë¿Ú°üº¬ÁË¸Ã·½·¨µÄÖ´ĞĞµØÖ·£¬µ±¸ÃÄÚ²¿Êı¾İ³õÊ¼»¯µÄÊ±ºò£¬CLR½«Ã¿Ò»¸öÈë¿ÚÖ¸ÏòÒ»¸öÄÚ²¿º¯Êı£ºJITCompiler.
ok, µÚÒ»´Îµ÷ÓÃWriteLine·½·¨µÄÊ±ºò£¬Êµ¼ÊÉÏÊÇ JITCompiler º¯Êı±»µ÷ÓÃ£¬JITCompiler º¯ÊıÖªµÀ±»µ÷ÓÃ·½·¨ÊÇÄÄÒ»¸ö£¨¸ù¾İ´«ÈëµÄSelf¶ÔÏóÖ¸Õë£©£¬È»ºó JITCompiler
º¯Êı²éÕÒ³ÌĞò¼¯µÄMetaDataÈ¡µÃ¸Ã·½·¨µÄIL£¬È»ºóĞ£Ñé²¢±àÒëIL³ÉÎª±¾µØCPUÖ¸Áî£¬±àÒëµÄ±¾µØCPUÖ¸Áî±»·ÅÔÚ¶¯Ì¬·ÖÅäµÄÄÚ´æ¿éÖĞ£¬½Ó×Å JITCompiler º¯Êı½«WriteLineµÄ
ÄÚ²¿Êı¾İµÄ·½·¨Èë¿ÚÌæ»»³É±àÒëºÃµÄ±¾µØCPUÖ¸ÁîÖ´ĞĞÈë¿Ú¡£×îºó£¬ JITCompiler º¯ÊıÌø×ªµ½¸ÃÈë¿Ú´¦Ö´ĞĞ¡£

JITCompiler ´æ·ÅµÄ±¾µØCPUÖ¸ÁîËæ×ÅÓ¦ÓÃµÄÖÕÖ¹¶ø×Ô¶¯±»ÊÍ·Å£¨³ı·ÇÊ¹ÓÃ NGen.exe£©£¬µ±ÔÙ´ÎÔËĞĞµÄÊ±ºò£¬ÄÇÃ´JITCompiler½«ÔÙ´Î±àÒë£¬Èç¹ûÄãÍ¬Ê±ÔËĞĞÁ½¸öÓ¦ÓÃÊµÀı
ÄÇÃ´JITCompilerÒ²½«»áÔÙ±àÒëÒ»´Î¡£ºÙºÙ£¬Èç¹ûÄãµÄÓ¦ÓÃ³ÌĞò´ó²¿·ÖµÄ·½·¨´úÂë¶¼Ö»±»µ÷ÓÃÒ»´Î£¬ÄÇÃ´ÕâËÙ¶ÈĞÔÄÜ½«±äµÃºÜÔã¸â£¬ÓÈÆäÊÇ´ò¿ªÁËJITCompilerÓÅ»¯µÄÇé¿öÏÂ
¸üÂı£¬µ±È»´ó¶àÊıÓ¦ÓÃ³ÌĞò¾ö²»¿ÉÄÜĞ´³öµÄ·½·¨´úÂëÖ»±»µ÷ÓÃÒ»´ÎµÄ£¬ÕâÖ»ÄÜÊÓ×÷¼«¶ËÇé¿ö¡£

ÁíÍâ£¬ÎÒºÜÏëÖªµÀµÄ£¬IL(MetaData)¼ÓÔØµ½ÄÚ´æÊÇÊ²Ã´Ê±ºò£¿Êµ¼ÊÉÏILÖ»ÓĞµ±JITCompiler±àÒëµÄÊ±ºò²ÅĞèÒª£¬Èç¹ûÒ»Ö±¶¼·ÅÔÚÄÚ´æÄÇ¾ÍÌ«ÀË·ÑÁË¡£

== Remoting »úÖÆ ==
Remoting »úÖÆ×÷ÎªÔÚAppDomainÖ®¼ä¹µÍ¨µÄÇÅÁº£¬µ±ÄãÒıÓÃÄãÒ»¸öAppDomainµÄ¶ÔÏó»ò³ÉÔ±µÄÊ±ºò£¬Remoting¾ÍÒª¸ºÔğ´¦ÀíÁË¡£Remoting Ò²±»ÓÃÓÚ
ÔÚµØÖ·¿Õ¼äÖ®¼ä¹µÍ¨¡£Remoting ÊÇÔÚ MarshalByRefObject ÀàÖĞÊµÏÖµÄ¡£
ËüµÄÊµÏÖ»úÖÆÈçÏÂ£º
·şÎñÆ÷¶Ë£ºÔ¶³Ì·ÃÎÊµÄ¶ÔÏóÊÇ MarshalByRefObject ×ÓÀàµÄÊµÀı£¬Í¨¹ıÊ¹ÓÃ¸Ã»ùÀà£¬CLI¾ÍÓĞÄÜÁ¦ÎªÔ¶³Ì¶ÔÏó½¨Á¢Real Proxy server Stub£¬
Õâ¸ö´úÀí·şÎñÆ÷½«±»×¢²áµ½È«¾ÖÃû³Æ¿Õ¼ä£¬È»ºó×¼±¸ºÃÔËĞĞÊ±¼äÁ´½Ó£¨µ±¿Í»§¶ÔÏóµ÷ÓÃÔ¶³Ì¶ÔÏóµÄÊ±ºòÓÃÒÔÖ§³ÖRMI£©¡£
Í¨µÀ£¨Channel£©¶ÔÏó±»MarshalByRefObject×ÓÀàÊµÀı»¯²¢×¢²á¡£

¿Í»§¶Ë£ºÍ¨µÀÔÚÊ¹ÓÃÇ°±ØĞëÏÈ×¢²á¡£µ±¿Í»§ÒıÓÃÔ¶³Ì¶ÔÏó£¬Î»ÓÚ¿Í»§¶ËµÄÍ¸Ã÷´úÀí(Transparent Proxy)±»½¨Á¢¡£½«µ÷ÓÃÊı¾İĞòÁĞ»¯£¨serializes£©ºó
Í¨¹ı´úÁ·±»´«ËÍµ½·şÎñÆ÷¡£

¿´Ñù×Ó£¬¾ÍËãÊÇÍ¬Ò»½ø³ÌÏÂµÄ²»Í¬AppDomainÖ®¼äµÄµ÷ÓÃÍ¨Ñ¶£¬Ò²ÊÇÂıµÃ²»µÃÁË°¡¡£Õâ¸ö²»Íâºõ¾ÍÊÇÒÔÇ°µÄAOÊµÏÖµÄÔ¶³Ìµ÷ÓÃ£¬Ö»²»¹ı±»°ü¹üÔÚÄÚºË
ÆÕÍ¨¿ª·¢Õß¿´²»µ½£¬Õâ¸öÔİ»ºÑĞ¾¿¡£

== ³ÌĞò¼¯µÄ¼ÓÔØºÍÖ´ĞĞ ==

³ÌĞò¼¯¼ÓÔØÆ÷£º²éÕÒ³ÌĞò¼¯£¬ÕÒµ½½«³ÌĞò¼¯×°ÔØµ½µ÷ÓÃÕßµÄAppDomainÖĞ£¬ÔÚ×°ÔØÇ°¼ÓÔØÆ÷½«Ê¹ÓÃPolicy ManagerĞ£ÑéÏàÓ¦µÄ°²È«È¨ÏŞ£¬È·±£µ÷ÓÃÕß±»ÔÊĞíÊ¹ÓÃ¸Ã³ÌĞò¼¯¡£
³ÌĞò¼¯ÏÂÔØÕß(downloader)ÊÇ³ÌĞò¼¯¼ÓÔØÆ÷µÄÒ»²¿·Ö£¬ÓÃÓÚ²éÕÒ³ÌĞò¼¯£¬²¢½«ÆäÏÂÔØµ½±¾µØ£¨Èç¹û³ÌĞò¼¯²»ÔÚ±¾µØ£©£¬ÒÔ±ã×°ÔØ£¬¿ª·¢Õß¿ÉÒÔÔÚÅäÖÃÎÄ¼şÖĞÖ¸¶¨¸½¼ÓµÄ
ÏÂÔØÎ»ÖÃ£¬ÅäÖÃÎÄ¼ş±ØĞëºÍÓ¦ÓÃ³ÌĞòÔÚÍ¬Ò»Ä¿Â¼£¬²¢×ñÑ­ÈçÏÂµÄÃüÃû£¬ÔÚ³ÌĞò¼¯ÎÄ¼şÃûºó¸½¼ÓÀ©Õ¹Ãû¡°.config¡±£¬Èç£º xxx.exe.config¡£Ô´³ÌĞòµÄÎ»ÖÃÔÚ£º/clr/src/fusion¡£
Ä¿Â¼µÄ²éÕÒË³Ğò¡¾Ò²ĞíÓĞÎó¡¿£º
  GACÄ¿Â¼
  Ó¦ÓÃÄ¿Â¼
  Ó¦ÓÃ×ÓÄ¿Â¼
  ÅäÖÃÎÄ¼şÖĞµÄ¸½¼ÓÎ»ÖÃ

³ÌĞò¼¯ÕÒµ½ºó£¬ÏÂÔØÆ÷½«³ÌĞò¼¯Á÷£¨ÎÄ¼şÃû£©´«µİ¸ø¼ÓÔØÆ÷£¬¼ÓÔØÆ÷Ê¹ÓÃPolicy ManagerĞ£ÑéÏàÓ¦µÄ°²È«È¨ÏŞ£¬È·±£³ÌĞò¼¯ÄÜÔÚ¸Ã»·¾³ÏÂÔËĞĞÒÔ¼°ÓÃ»§ÓĞÖ´ĞĞ¸Ã³ÌĞò¼¯µÄĞí¿É¡£
È»ºó£¬¼ÌĞøfusion£¬½«³ÌĞò¼¯¼ÓÔØµ½AppDomain£¬²¢µ÷ÓÃÀà¼ÓÔØÆ÷£¨class loader£©¡£

  nExitCode = _CorExeMain2(NULL, 0, pFileName, NULL, pCmdLine);                       //clr\src\tools\clix\clix.cpp:
    result = CoInitializeEE(COINITEE_DEFAULT | COINITEE_MAIN);  //³õÊ¼»¯ĞéÄâÖ´ĞĞÒıÇæ  //clr\src\vm\ceemain.cpp:
    bRetVal = ExecuteEXE(pImageNameIn);
          SystemDomain::ExecuteMainMethod(hMod);    //clr\src\vm\assembly.cpp
          hr = ClassLoader::RunMain(pMeth, 1, &iRetVal, stringArgs); //clr\src\vm\clsload.cpp
          È»ºóÅªÁËÒ»¸öÏß³Ì£¬ÔÚÏß³ÌÀïÔËĞĞ
             ARG_SLOT stackVar = ObjToArgSlot(StrArgArray); //ÔÚÕâÀï²Å×°Èë£¿
  ·ÖÎöclix¸Ğ¾õ²»¶Ô£¬Policy ManagerÒÔ¼°downloader¶¼Ã»ÓĞ¿´µ½£¡

=== Àà¼ÓÔØÆ÷ ===
µ±Àà×¼±¸Ö´ĞĞµÄÊ±ºòÀà¼ÓÔØÆ÷¾Í»á±»µ÷ÓÃ¡£Õâ·¢ÉúÔÚ£º
  1¡¢³ÌĞò¼¯µÄÖ÷Èë¿Úµã±»¼ÓÔØ
  2¡¢ÕıÔÚÖ´ĞĞµÄ¶ÔÏóÒıÓÃÁËÒ»¸ö´ÓÎ´¼ÓÔØµÄ¶ÔÏó¡£
Àà¼ÓÔØÆ÷½«´Ó³ÌĞò¼¯ÖĞ¼ÓÔØ¸ÃÀàµÄÈ«²¿¶¨Òå£¬È»ºó×¼±¸ÏàÓ¦µÄ¶ÔÏóÊµÀı»¯£º
  ¸´ÖÆILÒÔ¼°¸ÃÀàµÄMetaData
  ×¼±¸ÀàµÄÊı¾İ½á¹¹(EEClass)
  ´´½¨³õÊ¼»¯ÀàµÄµÄ·½·¨±í(MethodTable and Vtable)

== CLI±àÒëµÄÖ´ĞĞÎÄ¼ş½á¹¹ ==
ÆäÊµ¾ÍÊÇPEÎÄ¼ş½á¹¹£¬²»¹ıÀûÓÃPE½á¹¹ÖĞµÄIMAGE_OPTIONAL_HEADER.DataDirectory[IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR]±£´æ
ÁËCLRµÄIMAGE_COR20_HEADERÍ·¡£È»ºó½«_CorExeMain ×®ÒÔ¼°IL£¬metaData£¬µ¼ÈëµØÖ·±íÈ«²¿·ÅÔÚ.text½ÚÖĞ¡£

=== MS-DOS Stub ===
Ê×ÏÈÊÇ MS-DOS Stub: ÓÃÓÚÔÚDos»·¾³ÏÂÏÔÊ¾¸Ã³ÌĞò²»ÄÜÔËĞĞÔÚDOSÏÂµÄÌáÊ¾¡£
ÔÚÎÄ¼şÆ«ÒÆÁ¿0x3CµÄÎ»ÖÃÊÇÖ¸ÏòPE Ç©Ãû(signature) µÄÖ¸Õë: 80 00 00 00,¾ÍÊÇ 0x80.

00000000h: 4D 5A 90 00 03 00 00 00 04 00 00 00 FF FF 00 00 ; MZ?........ÿÿ..
00000010h: B8 00 00 00 00 00 00 00 40 00 00 00 00 00 00 00 ; ?......@.......
00000020h: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ; ................
00000030h: 00 00 00 00 00 00 00 00 00 00 00 00 80 00 00 00 ; ............€...
...
00000080h: 50 45 00 00 4C 01 03 00 92 38 84 45 00 00 00 00 ; PE..L...?„E....
00000090h: 00 00 00 00 E0 00 0E 01 0B 01 06 00 00 04 00 00 ; ....?..........

  _IMAGE_DOS_HEADER = record //¿ÉÒÔÊÓ×÷¹Ì¶¨µÄ,ÕÕ°á¡£
    e_magic: Word;     // Magic number: "MZ"
    e_cblp: Word;      // Bytes on last page of file
    e_cp: Word;        // Pages in file
    e_crlc: Word;      // Relocations
    e_cparhdr: Word;   // Size of header in paragraphs
    e_minalloc: Word;  // Minimum extra paragraphs needed
    e_maxalloc: Word;  // Maximum extra paragraphs needed
    e_ss: Word;        // Initial (relative) SS value
    e_sp: Word;        // Initial SP value
    e_csum: Word;      // Checksum
    e_ip: Word;        // Initial IP value
    e_cs: Word;        // Initial (relative) CS value
    e_lfarlc: Word;    // File address of relocation table
    e_ovno: Word;      // Overlay number
    e_res: array [0..3] of Word;    // Reserved words
    e_oemid: Word;     // OEM identifier (for e_oeminfo)
    e_oeminfo: Word;   // OEM information; e_oemid specific
    e_res2: array [0..9] of Word;  // Reserved words
    e_lfanew: Longint; // File address of new exe header ÎÄ¼şÆ«ÒÆÁ¿£º0x3C
  end;

PE Ç©Ãû(signature) ½ô½Ó×ÅMS-DOS Stub,ÊÇ4¸ö×Ö½Ú£¬ÄÚÈİÎª ¡°PE¡±È»ºóÊÇÁ½¸ö×Ö½Ú0: 0x00004550
  _IMAGE_NT_HEADERS = record
    Signature: DWORD;                      //PE signature: 0x00004550
    FileHeader: IMAGE_FILE_HEADER;         //The COFF header
    OptionalHeader: IMAGE_OPTIONAL_HEADER; //The PE header. 32Î»Í·ºÍ64Î»Í·ÂÔÓĞ²îÒì£¬CLRÄ¿Ç°°æ±¾Í³Ò»Ê¹ÓÃ32Î»½á¹¹¡£
  end;

=== COFF Í· ===
ÔÚ PE Ç©Ãû(signature) Ö®ºóÊÇ COFF Í·£¬ÄÚÈİÈçÏÂ£º
  _IMAGE_FILE_HEADER = record //JwaWinNT.pas
    Machine: WORD;               //Ä¿±ê»úÆ÷ÀàĞÍ×Ö¶Î£¬ÍĞ¹ÜµÄIL´úÂëÉèÖÃ¸Ã×Ö¶ÎÎª IMAGE_FILE_MACHINE_I386 (0x014C)
    NumberOfSections: WORD;      //Section½ÚµÄ¸öÊı£¬Section½Ú½ô½Ó×ÅPEÍ·
    TimeDateStamp: DWORD;        //ÎÄ¼şµÄ´´½¨Ê±¼ä
    PointerToSymbolTable: DWORD; //·ûºÅ±íµÄÎÄ¼şÎ»ÖÃÖ¸Õë£¬ÔÚÍĞ¹ÜµÄILÖĞÎ´ÓÃ£¬×ÜÊÇ0¡£
    NumberOfSymbols: DWORD;      //·ûºÅ±íµÄµÄ¸öÊı£¬ÔÚÍĞ¹ÜµÄILÖĞÎ´ÓÃ£¬×ÜÊÇ0¡£ £¨ÕâÀïµÄÎ»ÖÃÔÚ£º0x90£©
    SizeOfOptionalHeader: WORD;  //PEÍ·µÄ´óĞ¡¡£
    Characteristics: WORD;       //ÎÄ¼şÊôĞÔ±êÊ¾¡£¶ÔÓÚÒ»°ãµÄÍĞ¹Ü´úÂë¿ÉÖ´ĞĞÎÄ¼şµÄÊôĞÔÎª0x010E, DLLÊÇ0x210E.
  end;

Ä¿±ê»úÆ÷ÀàĞÍ×Ö¶ÎµÄ¿ÉÄÜµÄÖµÒÔ¼°º¬ÒåÈçÏÂ£º
  IMAGE_FILE_MACHINE_UNKNOWN   = 0;
  IMAGE_FILE_MACHINE_I386      = $014c; // Intel 386. For managed PE files, contents are applicable to any machine type.
  IMAGE_FILE_MACHINE_R3000     = $0162; // MIPS little-endian, 0x160 big-endian
  IMAGE_FILE_MACHINE_R4000     = $0166; // MIPS little-endian
  IMAGE_FILE_MACHINE_R10000    = $0168; // MIPS little-endian
  IMAGE_FILE_MACHINE_WCEMIPSV2 = $0169; // MIPS little-endian WinCE v2
  IMAGE_FILE_MACHINE_ALPHA     = $0184; // Alpha_AXP
  IMAGE_FILE_MACHINE_SH3       = $01a2; // SH3 little-endian
  IMAGE_FILE_MACHINE_SH3DSP    = $01a3;
  IMAGE_FILE_MACHINE_SH3E      = $01a4; // SH3E little-endian
  IMAGE_FILE_MACHINE_SH4       = $01a6; // SH4 little-endian
  IMAGE_FILE_MACHINE_SH5       = $01a8; // SH5
  IMAGE_FILE_MACHINE_ARM       = $01c0; // ARM Little-Endian
  IMAGE_FILE_MACHINE_THUMB     = $01c2; // ARM processor with Thumb decompressor
  IMAGE_FILE_MACHINE_AM33      = $01d3;
  IMAGE_FILE_MACHINE_POWERPC   = $01F0; // IBM PowerPC Little-Endian
  IMAGE_FILE_MACHINE_POWERPCFP = $01f1;
  IMAGE_FILE_MACHINE_IA64      = $0200; // Intel IA64
  IMAGE_FILE_MACHINE_MIPS16    = $0266; // MIPS
  IMAGE_FILE_MACHINE_ALPHA64   = $0284; // ALPHA64
  IMAGE_FILE_MACHINE_MIPSFPU   = $0366; // MIPS
  IMAGE_FILE_MACHINE_MIPSFPU16 = $0466; // MIPS
  IMAGE_FILE_MACHINE_AXP64     = IMAGE_FILE_MACHINE_ALPHA64;
  IMAGE_FILE_MACHINE_TRICORE   = $0520; // Infineon
  IMAGE_FILE_MACHINE_CEF       = $0CEF;
  IMAGE_FILE_MACHINE_EBC       = $0EBC; // EFI Byte Code
  IMAGE_FILE_MACHINE_AMD64     = $8664; // AMD64 (K8)
  IMAGE_FILE_MACHINE_M32R      = $9041; // M32R little-endian
  IMAGE_FILE_MACHINE_CEE       = $C0EE;

ÎÄ¼şÊôĞÔ±êÊ¶µÄÖµÒÔ¼°º¬Òå£º
  IMAGE_FILE_RELOCS_STRIPPED         = $0001; // Relocation info stripped from file. ÍĞ¹Ü´úÂë²»ÄÜÉèÖÃ¸Ã±êÖ¾ÎªÕæ¡£
  IMAGE_FILE_EXECUTABLE_IMAGE        = $0002; // File is executable  (i.e. no unresolved externel references). ÍĞ¹Ü´úÂë±ØĞëÉèÖÃ¸Ã±êÖ¾ÎªÕæ¡£
  IMAGE_FILE_LINE_NUMS_STRIPPED      = $0004; // Line nunbers stripped from file. ÍĞ¹Ü´úÂë±ØĞëÉèÖÃ¸Ã±êÖ¾ÎªÕæ¡£ÒòÎª²»ÄÜÇ¶Èëµ÷ÊÔĞÅÏ¢¡£
  IMAGE_FILE_LOCAL_SYMS_STRIPPED     = $0008; // Local symbols stripped from file. ÍĞ¹Ü´úÂë±ØĞëÉèÖÃ¸Ã±êÖ¾ÎªÕæ¡£
  IMAGE_FILE_AGGRESIVE_WS_TRIM       = $0010; // Agressively trim working set ÍĞ¹Ü´úÂë²»ÄÜÉèÖÃ¸Ã±êÖ¾ÎªÕæ¡£
  IMAGE_FILE_LARGE_ADDRESS_AWARE     = $0020; // App can handle >2gb addresses ÍĞ¹Ü´úÂë²»ÄÜÉèÖÃ¸Ã±êÖ¾ÎªÕæ¡£
  IMAGE_FILE_BYTES_REVERSED_LO       = $0080; // Little endian. Bytes of machine word are reversed. ÍĞ¹Ü´úÂë²»ÄÜÉèÖÃ¸Ã±êÖ¾ÎªÕæ¡£
  IMAGE_FILE_32BIT_MACHINE           = $0100; // 32 bit word machine.  µ±Ç°°æ±¾µÄÍĞ¹Ü´úÂëÉèÖÃ¸Ã±êÖ¾ÎªÕæ¡£
  IMAGE_FILE_DEBUG_STRIPPED          = $0200; // Debugging info stripped from file in .DBG file
  IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP = $0400; // If Image is on removable media, copy and run from the swap file.  ÍĞ¹Ü´úÂë²»ÄÜÉèÖÃ¸Ã±êÖ¾ÎªÕæ¡£
  IMAGE_FILE_NET_RUN_FROM_SWAP       = $0800; // If Image is on Net, copy and run from the swap file.   ÍĞ¹Ü´úÂë²»ÄÜÉèÖÃ¸Ã±êÖ¾ÎªÕæ¡£
  IMAGE_FILE_SYSTEM                  = $1000; // System File.   ÍĞ¹Ü´úÂë²»ÄÜÉèÖÃ¸Ã±êÖ¾ÎªÕæ¡£
  IMAGE_FILE_DLL                     = $2000; // File is a DLL.
  IMAGE_FILE_UP_SYSTEM_ONLY          = $4000; // File should only be run on a UP machine   ÍĞ¹Ü´úÂë²»ÄÜÉèÖÃ¸Ã±êÖ¾ÎªÕæ¡£
  IMAGE_FILE_BYTES_REVERSED_HI       = $8000; // Big endian. Bytes of machine word are reversed.  ÍĞ¹Ü´úÂë²»ÄÜÉèÖÃ¸Ã±êÖ¾ÎªÕæ¡£
 
EXE ÍĞ¹ÜÎÄ¼şµÄÎÄ¼şÊôĞÔÊÇ 0x010E (IMAGE_FILE_EXECUTABLE_IMAGE ©¦ IMAGE_FILE_LINE_NUMS_ STRIPPED ©¦ IMAGE_FILE_LOCAL_SYMS_STRIPPED ©¦ IMAGE_FILE_32BIT_ MACHINE). 
DLL ÍĞ¹ÜÎÄ¼şµÄÎÄ¼şÊôĞÔÊÇ 0x210E (IMAGE_FILE_ EXECUTABLE_IMAGE ©¦ IMAGE_FILE_LINE_NUMS_STRIPPED ©¦ IMAGE_FILE_ LOCAL_SYMS_STRIPPED ©¦ IMAGE_FILE_32BIT_MACHINE ©¦ IMAGE_FILE_DLL).

=== PE Í· ===
½ô½Ó×ÅCOFFÍ·µÄ¾ÍÊÇPEÍ·ÁË£¬¾¡¹ÜËü±»³Æ×÷¿ÉÑ¡Í·£¬µ«ÊÇÊµ¼ÊÉÏ¶ÔÓÚExeºÍDLLÎÄ¼şÀ´Ëµ£¬È´×ÜÊÇ´æÔÚµÄ¡£PEÍ·µÄ´óĞ¡²»ÊÇ¹Ì¶¨µÄ£¬ËüÓÉÊı¾İÄ¿Â¼µÄ´óĞ¡¾ö¶¨¡£
Ëü»á¸æËßÎÒÃÇ¸Ã¶ş½øÖÆÎÄ¼şÔõÑù±»ÔØÈëµÄ¸ü¶àĞÅÏ¢£º¿ªÊ¼µÄµØÖ·¡¢±£ÁôµÄ¶ÑÕ»Êı¡¢Êı¾İ¶ÎµÄ´óĞ¡µÈµÈ¡£

00000098h: 0B 01 06 00 00 04 00 00 00 04 00 00 00 00 00 00 ; ................
000000a8h: FE 22 00 00 00 20 00 00 00 40 00 00 00 00 40 00 ; ?... ...@....@.
000000b8h: 00 20 00 00 00 02 00 00 04 00 00 00 00 00 00 00 ; . ..............
000000c8h: 04 00 00 00 00 00 00 00 00 80 00 00 00 02 00 00 ; .........€......

  _IMAGE_OPTIONAL_HEADER = record
    //
    // Standard fields.
    //
    Magic: Word;               //Ä§Êı±êÊ¶¸ÃPE¾µÏñÎÄ¼şµÄ×´Ì¬£¬0x010B±íÊ¾32Î»PEÎÄ¼ş£¬ÍĞ¹Ü´úÂë×ÜÊÇ0x010B.
    MajorLinkerVersion: Byte;  //Á´½ÓÆ÷µÄÖ÷°æ±¾ºÅ£¬MC++ÉèÖÃ¸Ã×Ö¶ÎÎª7£¬ÆäËü¹«Ë¾µÄ´¿IL´úÂëÁ´½ÓÆ÷ÉèÖÃÎª6¡£
    MinorLinkerVersion: Byte;  //Á´½ÓÆ÷µÄ´Î°æ±¾ºÅ
    SizeOfCode: DWORD;         //×Ü´úÂë½ÚÇøµÄ´óĞ¡(.text),ÍĞ¹Ü´úÂëÖ»ÓĞÒ»¸ö´úÂëÇø¡£
    SizeOfInitializedData: DWORD; //×Ü³õÊ¼»¯Êı¾İ½ÚÇøµÄ´óĞ¡(Í³¼ÆËùÓĞµÄÊı¾İ½ÚÇøµÄSizeOfRawData×Ö¶Î)£¬ĞèÒª³õÊ¼»¯µÄÊı¾İ¡£
    SizeOfUninitializedData: DWORD; //×Ü²»ĞèÒª³õÊ¼»¯µÄÊı¾İ½ÚÇø´óĞ¡(.bss),¸ÃÊı¾İÇø²»Õ¼ÓÃ´ÅÅÌ¿Õ¼ä£¬Ö»ÊÇ×°ÔØºóÓÉOS¼ÓÔØÆ÷·ÖÅäÄÚ´æ¿Õ¼ä¡£
    AddressOfEntryPoint: DWORD;     //´úÂëÈë¿ÚµØÖ·RVA £¬¶ÔÓÚÍĞ¹Ü´úÂë£¨DLL»òExe£©×ÜÊÇÖ¸ÏòCLRµ÷ÓÃ×®¡£(ÔÚÎÄ¼şÆ«ÒÆÁ¿£º0x0a8)
    BaseOfCode: DWORD;              //´úÂë»ùÖ·RVA 
    BaseOfData: DWORD;              //Êı¾İ»ùÖ·RVA 
    //
    // NT additional fields.
    //
    ImageBase: DWORD;              //Ó³ÏóÎÄ¼ş»ùÖ·,Ìá¹©Õû¸ö¶ş½øÖÆÎÄ¼şµÄÓÅÏÈ£¨ÏßĞÔ£©ÔØÈëµØÖ·£¬ÔÚILAsmÖĞ¿ÉÒÔÊ¹ÓÃ .imagebase <integer value> Ö¸ÁîÖ¸¶¨¡£
    SectionAlignment: DWORD;       //½Ú¶ÔÆëÖµ£¬¸ÃÖµ±ØĞë´óÓÚµÈÓÚFileAlignment£¬Ä¬ÈÏÊÇÄÚ´æÒ³´óĞ¡¡£
    FileAlignment: DWORD;          //ÎÄ¼ş¶ÔÆëÖµ£¬Èç¹ûSectionAlignmentµÄÖµĞ¡ÓÚÄÚ´æÒ³µÄ´óĞ¡£¬¸ÃÖµÔòÊÇ2µÄn´Î·½£¬´Ó512¡«64K¡£ FileAlignment ±ØĞëÆ¥Åä SectionAlignment!
                                   // .file alignment <integer value>
    MajorOperatingSystemVersion: Word;
    MinorOperatingSystemVersion: Word;
    MajorImageVersion: Word;
    MinorImageVersion: Word;
    MajorSubsystemVersion: Word;
    MinorSubsystemVersion: Word;
    Win32VersionValue: DWORD;
    SizeOfImage: DWORD;            //Ó³ÏóÎÄ¼ş½«ÒªÊ¹ÓÃµÄÄÚ´æÊıÁ¿
    SizeOfHeaders: DWORD;          //¸ø³öËùÓĞÍ·µÄ×Ü³¤¶È£¬°üÀ¨Êı¾İÄ¿Â¼ºÍ½ÚÍ·¡£Í¬Ê±£¬ËüÒ²ÊÇ´ÓÎÄ¼şµÄ¿ªÍ·µ½µÚÒ»½ÚµÄÔ­Ê¼Êı¾İµÄÆ«ÒÆÁ¿¡£
    CheckSum: DWORD;               //´ÅÅÌÎÄ¼şµÄĞ£ÑéºÍ
    Subsystem: Word;               //×ÓÏµÍ³: Çı¶¯³ÌĞò,¿ØÖÆÌ¨³ÌĞò(Console), GUI,etc
    DllCharacteristics: Word;      //·ÏÆú£¬×ÜÊÇ0
    SizeOfStackReserve: DWORD;     //±£ÁôµÄÕ»µÄ´óĞ¡,Ä¬ÈÏÊÇ1M£¬²¢Ã»ÓĞÕæÕı·ÖÅä¿Õ¼ä
    SizeOfStackCommit: DWORD;      //³õÊ¼Ê±Ö¸¶¨Õ»´óĞ¡,Ä¬ÈÏÊÇ1Ò³£¬Êµ¼Ê·ÖÅä¿Õ¼äµÄ´óĞ¡£¬Í¬Ê±Ò²ÊÇÖ¸¶¨µÄÔö¼ÓµÄÊıÁ¿¡£
    SizeOfHeapReserve: DWORD;      //±£ÁôµÄ¶ÑµÄ´óĞ¡£¬Ä¬ÈÏÊÇ1M£¬²¢Ã»ÓĞÕæÕı·ÖÅä¿Õ¼ä
    SizeOfHeapCommit: DWORD;       //³õÊ¼Ê±Ö¸¶¨¶Ñ´óĞ¡,Ä¬ÈÏÊÇ1Ò³£¬Êµ¼Ê·ÖÅä¿Õ¼äµÄ´óĞ¡£¬Í¬Ê±Ò²ÊÇÖ¸¶¨µÄÔö¼ÓµÄÊıÁ¿¡£
    LoaderFlags: DWORD;            //·ÏÆú£¬×ÜÊÇ0
    NumberOfRvaAndSize: DWORD;     //Êı¾İÄ¿Â¼Êı£¬ÖÁÉÙÊÇ16¡£
    DataDirectory: array [0..IMAGE_NUMBEROF_DIRECTORY_ENTRIES - 1] of IMAGE_DATA_DIRECTORY;
  end;

Ä§Êı±êÊ¶¸ÃPE¾µÏñÎÄ¼şµÄ×´Ì¬£º
  IMAGE_NT_OPTIONAL_HDR32_MAGIC = $10b;
  IMAGE_NT_OPTIONAL_HDR64_MAGIC = $20b;
  IMAGE_ROM_OPTIONAL_HDR_MAGIC  = $107;

×ÓÏµÍ³:
  IMAGE_SUBSYSTEM_UNKNOWN                 = 0; // Unknown subsystem.
  IMAGE_SUBSYSTEM_NATIVE                  = 1; // Image doesn't require a subsystem.
  IMAGE_SUBSYSTEM_WINDOWS_GUI             = 2; // Image runs in the Windows GUI subsystem.
  IMAGE_SUBSYSTEM_WINDOWS_CUI             = 3; // Image runs in the Windows character subsystem.
  IMAGE_SUBSYSTEM_OS2_CUI                 = 5; // image runs in the OS/2 character subsystem.
  IMAGE_SUBSYSTEM_POSIX_CUI               = 7; // image runs in the Posix character subsystem.
  IMAGE_SUBSYSTEM_NATIVE_WINDOWS          = 8; // image is a native Win9x driver.
  IMAGE_SUBSYSTEM_WINDOWS_CE_GUI          = 9; // Image runs in the Windows CE subsystem.
  IMAGE_SUBSYSTEM_EFI_APPLICATION         = 10;
  IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER = 11;
  IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER      = 12;
  IMAGE_SUBSYSTEM_EFI_ROM                 = 13;
  IMAGE_SUBSYSTEM_XBOX                    = 14;

== Metadata ==
Token µÄ¶¨Òå£º uint32, xxyyyyyy; xx´ú±íÊÇµÚ¼¸¸ö±í£¨0x70³ıÍâ£¬´ú±í#USÁ÷£©£» yyyyyy´ú±íÔÚ±íÖĞµÄĞòºÅ£¬¾ÍÊÇindex

Ì¸Ì¸MetadataÔÚPEÖĞµÄ×éÖ¯½á¹¹¡£CLRµÄÍ·ĞÅÏ¢ÀïÃæ×¨ÃÅÓĞÒ»¸ö×Ö¶ÎÖ¸ÏòMetadataÊı¾İ¿é£¬Êµ¼ÊÉÏÕâ¸öÊı¾İ¿éÖ»ÊÇMetadataµÄÒ»¸öÍ·½á¹¹£¬
±£´æÓĞMetadataµÄÈ«¾ÖĞÅÏ¢£¬¶øMetadataµÄÊµ¼ÊÊı¾İ£¬ÊÇÍ¨¹ıÈô¸É²»Í¬µÄHeap»òÕßËµStream±£´æµÄ¡£ÕâÀïÎÒÍ³Ò»Ê¹ÓÃStreamÁ÷×÷ÎªËû
µÄÃû×Ö£¬µ«ºÜ¶àÎÄµµÖĞÒÔHeap¶Ñ×÷ÎªÆä³Æºô£¬ÎÒÃÇ¿ÉÒÔÀí½âËûÊÇÒ»¸ö¶ş½øÖÆÁ÷£¬ÆäÖĞÊı¾İÒÔ¶ÑµÄ½á¹¹½øĞĞ×éÖ¯¡£ÔÚÎÄ¼şÖĞÊÇÁ÷£¬×°ÈëÄÚ´æ
ºóÊÇ¶Ñ¡£Êµ¼ÊÉÏ¾ÍÊÇ°³µÄÊı¾İÇø¡£²»¹ıËü·ÖµÃ¸ü¼ÓÏ¸ÖÂ¡£

MetadataÀï×î³£¼ûµÄÓĞÎåÖÖÁ÷£¬#String, #Blob, #Guid,#US(User String)ºÍ#~Á÷("#"ÊÇÁ÷Ãû×ÖµÄÇ°×º)¡£Ã¿ÖÖÀàĞÍÁ÷×î¶àÖ»ÄÜ³öÏÖÒ»´Î£¬
#USºÍ#BlobÁ÷¿ÉÊ¡ÂÔ¡£

#StringÁ÷¾ÍÊÇÒ»¸ö×Ö·û´®¶Ñ£¬MetadataÄÚ²¿ÓÃµ½µÄËùÓĞ×Ö·û´®ÈçÀà»ò·½·¨µÄÃû×ÖµÈµÈ¶¼ÒÔUTF8±àÂë±£´æÔÚ´Ë¶ÑÄÚ¡£
¶øÓÃ»§µÄ×Ö·û´®Èç×Ö·û´®³£Á¿£¬ÔòÒÔUnicode±àÂë±£´æÔÚ#US(User String)¶ÑÄÚ¡£
ÖµµÃ×¢ÒâµÄÊÇ£¬USÁ÷ºÍStringÁ÷ÔÚ¶ş½øÖÆ½á¹¹×éÖ¯ÉÏ²»Í¬£¬ÎÒÃÇºóÃæ½«·ÖÎöÊ±»áÏêÏ¸Ìá¼°¡£

GuidÁ÷ÊÇ±£´æ³ÌĞòÖĞÊ¹ÓÃµ½µÄGuidµÄÊı×é£¬ÈçAssemblyÖĞModuleµÄMVID¡£

BlobÁ÷ÊÇÒ»¸öÍ¨ÓÃ´æ´¢¿Õ¼ä£¬³ıÁËGuidºÍ×Ö·û´®ÒÔÍâ»ù±¾ÉÏËùÓĞÊ£ÏÂµÄ¶«Î÷¶¼ÒÔ¶ş½øÖÆÊı¾İĞÎÊ½·ÅÔÚÀïÃæ£¬ÈçPublicKey£¬³£Á¿µÄÖµµÈµÈ¡£
µÈĞ§ÓÚÎÒµÄÊı¾İÇøÖĞ·ÖÅäµÄ±äÁ¿Çø¡£

×îÖØÒªµÄÊÇ#~Á÷£¬ÕâÊÇMetadataºËĞÄĞÅÏ¢´æ·ÅµÄµØ·½¡£#~Á÷ÎïÀíÉÏÒÔÈô¸ÉÕÅ±í(Table)µÄĞÎÊ½×éÖ¯£¬Ã¿ÕÅ±í´æ´¢Ä³Ò»·½ÃæµÄMetadataĞÅÏ¢£¬
ÈçMethodDef±í´æ´¢ËùÓĞ·½·¨µÄĞÅÏ¢¡£Ã¿ÕÅ±íÓÖÓÉÈô¸ÉµÄĞĞ(Row)×é³ÉÃ¿ĞĞÓĞn¸öÁĞ(Column)£¬Ã¿ÁĞ´ú±íÒ»ÖÖĞÅÏ¢£¬ÈçMethodDef±íÖĞÃ¿Ò»ĞĞ
¶¼ÓĞÒ»¸ö·½·¨µÄRVA,ÀàĞÍ±êÖ¾,Ãû×Ö,SignatureµÈµÈĞÅÏ¢¡£ÔÚÆäÖĞÍ¨¹ı¸÷ÖÖË÷ÒıÀ´Ïà»¥¹ØÁª£¬Õû¸ö×éÖ¯½á¹¹ºÍ¹ØÏµÊı¾İ¿âºÜÏàËÆ¡£

±È½ÏÌØÊâµÄÊÇ£¬ÕâÀïËùÓĞµÄ±íÍ¨¹ıÒ»¸ö64bitµÄÓĞĞ§Î»Í¼À´±íÊ¾±í´æÔÚÓë·ñÃ¿ÖÖÀàĞÍµÄ±íÓĞÒ»¸ö±àºÅ£¬ÈçMethodDef±íµÄ±àºÅÊÇ6£¬ÔòµÚ(1<<(6-1))Î»ÖÃ1
Òò¶øÃ¿¸ö±íµÄÃ¿Ò»ĞĞ£¬¿ÉÒÔÊ¹ÓÃÒ»¸öÎ¨Ò»µÄToken±íÊ¾¡£´ËTokenÊÇÒ»¸ö32bitÎŞ·ûºÅÕûĞÍÊı£¬×î¸ßÒ»¸ö×Ö½Ú±íÊ¾±íµÄĞòºÅ£¬µÍÈı¸ö×Ö½Ú±íÊ¾±íÖĞµÄË÷ÒıºÅ¡£
Èç0x06000003±íÊ¾0x06±í£¨MethodDef£©ÖĞµÚ3ĞĞ£¨ÈçMyApp::Add£©Õâ¸öToken¸ÅÄîÔÚCLRÖĞÆµ·±Ê¹ÓÃ£¬ÈçIL´úÂëµ÷ÓÃº¯Êı¡¢Ê¹ÓÃ±äÁ¿¶¼ÊÇÊ¹ÓÃToken¡£
ÓëÖ®ÀàËÆµÄ»¹ÓĞCoded Index£¬µÈ»á½²¶ş½øÖÆÊµÏÖÊ±ÔÙËµ¡£


´ËÆª±Ê¼ÇÎªÏÖÔÚµÄÌå»á£¬ÎÒ¸Ğ¾õ±È½ÏÇ³±¡£¬¶øÇÒµ±ÖĞÒ²Ó¦¸Ã»áÓĞÒ»Ğ©´íÎó¡£ÕâĞ©ÎÊÌâÁô´ıÒÔ¶ÔÔªÊı¾İÓĞ¸üÉîµÄÀí½âºóÏÖ½øĞĞĞŞÕı¡£

1£®  ºÎÎªÔªÊı¾İ

ÔªÊı¾İÊÇ±»Ç¶Èëµ½³ÌĞòÎÄ¼şµ±ÖĞµÄÒ»Ğ©ÃèÊöĞÅÏ¢£¬.Net PEÎÄ¼şÖĞËù¶¨Òåµ½ºÍËùÒıÓÃµ½µÄÀàĞÍ¶¼»áÔÚÔªÊı¾İÖĞÓĞÏàÓ¦µÄÃèÊö¡£

2£®  ÔªÊı¾İÓĞÊ²Ã´ÓÃÍ¾

ÒÔÏÂÕâ¶Î»°ÊÇJefferyÏÈÉúÊéÀïÃæµÄ¶ÔÔªÊı¾İÓÃÍ¾µÄ¾«²ÊÃèÊö¡£

l         ÔªÊı¾İÊ¡È¥ÁËÔ´´úÂë±àÒëÊ±¶ÔÍ·ÎÄ¼şµÄÒÀÀµ£¬ÕâÊÇÒòÎªÔÚº¬ÓĞÊµÏÖÀàĞÍºÍ³ÉÔ±µÄIL´úÂëÎÄ¼şµ±ÖĞ£¬ÒÑ¾­°üº¬ÁËËùÓĞ±»ÒıÓÃµÄÀàĞÍºÍ³ÉÔ±µÄĞÅÏ¢¡£±àÒëÆ÷¿ÉÒÔÖ±½Ó´ÓÍĞ¹ÜÄ£¿éÖĞ¶ÁÈ¡ÔªÊı¾İÀ´»ñµÃÕâĞ©ĞÅÏ¢¡£

l         vs.net¿ÉÒÔÀûÓÃÔªÊı¾İÀ´¸¨ÖúÎÒÃÇ±àĞ´´úÂë¡£ËüµÄÖÇÄÜ¸ĞÖªÌØĞÔ¾ÍÊÇÍ¨¹ı·ÖÎöÔªÊı¾İÀ´¸æËßÎÒÃÇÄ³¸öÀàĞÍÌá¹©ÁËÄÄĞ©·½·¨£¬ÒÔ¼°ÒÔÕâĞ©·½·¨ÓĞÄÄĞ©²ÎÊı¡£

l         CLRµÄ´úÂëÑéÖ¤¹ı³Ì¿ÉÒÔÀûÓÃÔªÊı¾İÀ´È·±£´úÂë½öÖ´ĞĞ¡°°²È«¡±µÄ²Ù×÷¡£

l         ÀûÓÃÔªÊı¾İ£¬ÎÒÃÇ¿ÉÒÔ½«Ò»¸ö¶ÔÏóµÄ×Ö¶ÎĞòÁĞ»¯µ½Ò»¸öÄÚ´æ¿éÖĞ£¬È»ºóÔ¶³Ì´«ËÍ¸øÁíÒ»Ì¨»úÆ÷£¬×îºóÔÙÔÚÔ¶³Ì¼ÆËã»úÉÏÖ´ĞĞ·´ĞòÁĞ»¯£¬´Ó¶øÖØĞÂ´´½¨¶ÔÏóºÍËûµÄ×´Ì¬¡£

l         ÀûÓÃÔªÊı¾İ£¬À¬»øÊÕ¼¯Æ÷Òª°É×·×Ù¶ÔÏóµÄÉú´æÖÜÆÚ¡£¶ÔÓÚÈÎºÎ¶ÔÏó£¬À¬»øÊÕ¼¯Æ÷¶¼ÄÜ¹»Í¨¹ıÔªÊı¾İÀ´È·¶¨¸Ã¶ÔÏóµÄÀàĞÍ£¬²¢ÇÒ¿ÉÒÔ»ñÖª¸Ã¶ÔÏóµÄÄÄĞ©×Ö¶ÎÒıÓÃÁËÆäËüµÄ¶ÔÏó¡£

l

3£®  ÔªÊı¾İÖÖÀà

.NetÖĞµÄÔªÊı¾İÊÇÓÉ²»Í¬µÄÊı¾İ±í¹¹³ÉµÄ¡£ÔªÊı¾İ±íÔÚ.Netµ±ÖĞ±»·Ö³ÉÎªÈıÀà£¨Ã¿ÀàÓĞ¶à¸ö±í£©£¬ËüÃÇ·Ö±ğÊÇ£¬¶¨ÒåÔªÊı¾İ±í£¬ÒıÓÃÔªÊı¾İ±í»¹ÓĞÇåµ¥ÔªÊı¾İ±í¡£

¶¨ÒåÔªÊı¾İ±íÊÇÓÃÀ´ÃèÊö.Net PEÎÄ¼ş±¾ÉíËù¶¨ÒåµÄÊı¾İÀàĞÍµÄ¡£ÔÚÎÒÃÇ³ÌĞòµ±ÖĞµÄ¶¨ÒåµÄÀà£¬½á¹¹µÈµÈÒ»ÇĞµÄÀàĞÍĞÅÏ¢£¬×îÖÕ¶¼»á³öÏÖÔÚ¶¨ÒåÔªÊı¾İ±íÖĞ¡£

ÒıÓÃÊı¾İ±íÓÃÀ´ÃèÊö.Net Peµ±ÖĞËùÒıÓÃµ½µÄÍâ²¿ÀàĞÍ¡£ÔÚÎÒÃÇ³ÌĞòµ±ÖĞÒıÓÃµÄFCLÀàĞÍ¡¢×Ô¶¨ÒåÀàĞÍ£¨×¢1£©ÒÔ¼°µÚÈı·½ÀàĞÍµÄ¶¨Òå¶¼»á³öÏÖÔÚÒıÓÃÊı¾İ±íÄÚ¡£

Çåµ¥ÔªÊı¾İ±íÏà¶ÔÓÚ¶¨ÒåÔªËØÔªºÍÒıÓÃÔªÊı¾İ±íÀ´Ëµ£¬ÊÇÒ»Àà±È½ÏÌØÊâµÄÔªÊı¾İ±í£¬ËüµÄ×÷ÓÃÊÇÓÃÀ´ÃèÊö³ÌĞò¼¯ĞÅÏ¢¡£³ÌĞò¼¯µÄÀíÄîºÜÏñÊÇ¶¯Ì¬Á´½Ó¿â£¬ÔÚ³ÌĞò¼¯ÄÚ²¿°üº¬×ÅºÜ¶àµÄÀàĞÍ¶¨Òå£¬ÔÚ³ÌĞò¼¯µÄÍâ²¿£¬Ò»¸ö³ÌĞòÔ±¿ÉÒÔÍ¨¹ı°üº¬Õâ¸ö³ÌĞò¼¯µÄ·½Ê½À´Ê¹ÓÃÕâ¸ö³ÌĞòËùÌá¹©µÄ×ÊÔ´¡£È»¶øÓë¶¯Ì¬Á´½Ó¿âËù²»Í¬µÄÊÇ£¬³ÌĞò¼¯ÖĞº¬ÓĞÔªÊı¾İ£¨ÌØ±ğÊÇÇåµ¥Êı¾İ£©£¬ÕâÒ²¾ÍÊ¹³ÌĞò¼¯³ÉÎªÁË.NetÆ½Ì¨ÊµÏÖ½â¾ö°æ±¾³åÍ»ºÍ¼òµ¥²¿ÊğÖĞµÄÖØÒª»ù´¡¡£ÕıÊÇÓÉÓÚ³ÌĞò¼¯µÄÇåµ¥µ±ÖĞÃèÊöÁË³ÌĞò¼¯µÄ°æ±¾£¬.NetÆ½Ì¨²ÅÔÊĞí¶à¸ö°æ±¾µÄ³ÌĞò¼¯Í¬Ê±°²×°µ½Í¬Ò»Ì¨¼ÆËã»úÉÏ£¬²¢ÔÚÖ´ĞĞ³ÌĞòÊ±£¬¸ù¾İ³ÌĞòËù°ó¶¨µÄ³ÌĞò¼¯°æ±¾À´ÕıÈ·µÄ×°Èë³ÌĞò¼¯¡£

³ıÁËÃèÊö³ÌĞò¼¯µÄ°æ±¾ĞÅÏ¢ÒÔºó£¬³ÌĞò¼¯µÄÇåµ¥ÔªÊı¾İ»¹»á¶Ô³ÌĞò¼¯µÄÆäËüÒ»Ğ©¶¨ÒåĞÅÏ¢½øĞĞÃèÊö¡£ÕâĞ©ĞÅÏ¢°üÀ¨³ÌĞò¼¯ÖĞ¶ÔÄ£¿é»òÕßÆäËüÎÄ¼şµÄÒıÓÃ£¨Ò»¸ö³ÌĞò¼¯¿ÉÒÔÓÉ¶à¸öÄ£¿é»òÕßÆäËüµÄÎÄ¼şÖ÷³É£¬µ«ÊÇÔÚÕâ¸ö³ÌĞò¼¯ÖĞÖ»ÓĞÖ÷ÎÄ¼ş²Å»á°üº¬Çåµ¥£©¡¢³ÌĞò¼¯ÖĞ°üº¬µÄ×ÊÔ´¶¨Òå£¬»¹ÓĞ³ÌĞò¼¯ÖĞµ¼³öÀàĞÍµÄ¶¨Òå£¨ÎÒÏëÕâ¿ÉÄÜÊÇÎªÁË·½±ãCLR¶Ô³ÌĞò¼¯ÖĞµ¼³öÀàĞÍµÄ²éÕÒ°É£¬±Ï¾¹Ò»¸ö³ÌĞò¼¯¿ÉÒÔ°üº¬¶à¸öÄ£¿é£¬Èç¹ûÃ»ÓĞÒ»¸ö»ã×ÜË÷ÒıµÄ»°£¬ÔÚ³ÌĞò¼¯µ±ÖĞ²éÕÒµ½Ä³Ò»¸öÌØ¶¨ÀàĞÍµÄĞ§ÂÊ»áÊÜµ½½Ï´óµÄÓ°Ïì£©¡£


ÒÔÏÂÊÇJefferyÏÈÉú¶ÔÍÏ¹Ü´úÂëÓÅÊÆµÄÂÛÊö¡£

Èç¹ûÓ¦ÓÃ³ÌĞòÔÚÒ»Ğ©ĞÂĞÍµÄCPU£¨±ÈÈç±¼ÌÚ4£©ÉÏÔËĞĞ£¬JIT±àÒëÆ÷ÄÜ¹»¼ì²âµ½ÕâÖÖÇé¿ö£¬²¢²úÉúÀûÓÃÕâĞ©ĞÂĞÍCPUÌá¹©µÄÌØÊâÖ¸ÁîµÄ±¾µØ´úÂë¡£¶ø·ÇÍÏ¹ÜÓ¦ÓÃ³ÌĞòÍ¨¹ı±»±àÒëÎªÃæÏò¾ßÓĞ×îĞ¡Í¨ÓÃ¹¦ÄÜ¼¯ºÏµÄCPUÆ½Ì¨£¬Ò»°ã»á±ÜÃâÊ¹ÓÃĞÂĞÍCPUÌá¹©µÄÌØÊâÖ¸Áî¡£¶øÕâĞ©ÌØÊâÖ¸ÁîÍùÍù»áÔÚ½ÏĞÂµÄCPUÉÏÎªÓ¦ÓÃ³ÌĞò´øÀ´ºÜ¸ßµÄĞÔÄÜÌáÉı£¨Ç°Ò»¶ÎÊ±¼äÎÒ»¹ÔÚ³ÌĞòÔ±ÔÓÖ¾ÉÏ¿´µ½ÁËintel´µÅõÊ¹ÓÃËü×Ô¼ºµÄC++±àÒëÆ÷Ëù±àÒë³öÀ´µÄ´úÂë»áÔÚËü×Ô¼ºÉú²úµÄCPUÉÏ»ñµÃ¶àÃ´ºÃµÄĞÔÄÜ¡£ÆäÊµIntelÍêÈ«Ò²¿ÉÒÔÎªJITÀ´×öÕâÑùµÄÓÅ»¯¹¤×÷£¬²»¹ıÕâÒª¿´.NetÆ½Ì¨±¾ÉíÊÇ·ñÁô³öÁËÕâÖÖ¶ÔJITÀàËÆÓÚ²å¼şÊ½Ö§³Ö£©¡£

JIT±àÒëÆ÷ÄÜ¼ì²âµ½ÕıÔÚÔËĞĞµÄ»úÆ÷ÉÏÄ³Ğ©×ÜÊÇ·µ»Ø´íÎóµÄ²¼¶û²âÊÔ¡£ÕâÑùJIT¾Í»á½«ÕâÀà²»»á±»Ö´ĞĞµÄ´úÂëÓÅ»¯ÏÂÈ¥£¬ÒÔÊ¹´úÂëÁ¿±äµÄ¸üĞ¡£¬Ö´ĞĞËÙ¶È±äµÄ¸ü¿ì£¨µ±ÎÒÒ»¿ªÊ¼¶ÁÍêÕâ¶ÎµÄÊ±ºòÎÒ¶Ô´Ë²¢²»ÏàĞÅ£¬ÒòÎªÎÒ¸Ğ¾õÕâÊÇÒ»ÖÖ±àÒëÆÚµÄ¼¼Êõ£¬Ò»°ãµÄ·ÇÍÏ¹Ü±àÒëÆ÷Ò²ÊÇ¿ÉÒÔÊµÏÖËüµÄ£¬µ«ÊÇµ±ÎÒ¶ÁÍêÁËÏÂÃæÒ»¶ÎºóÎÒµÄ¹ÛÄî·¢ÉúÁË×ª±ä£©¡£

ÔÚÓ¦ÓÃ³ÌĞòÔËĞĞÊ±£¬CLRÄÜ¹»·ÖÎöÆÀ¹À´úÂëµÄÖ´ĞĞÇé¿ö£¬²¢ÓĞÑ¡ÔñµØÖØĞÂ½«IL´úÂë±àÒë³ÉÎª±¾µØ´úÂë¡£¸ù¾İ¹Û²ìµ½µÄÖ´ĞĞÄ£Ê½£¬±»±àÒëµÄ´úÂë¿ÉÒÔ±»ÖØĞÂ×éÖ¯ÒÔÌá¸ß·ÖÖ§²âÊÔµÄ³É¹¦ÂÊ£¨ÕâÊÇÒ»¸ö¶àÃ´ÁîÈËĞË·İµÄ¼¼Êõ°¡£¬Ò»ÖÖ¶Ô´úÂëÔÚÔËĞĞÊ±ÖÇÄÜ»¯µÄ·ÖÎöÓëµ÷Õû¡£ÕâÖÖ¼¼ÊõÀàËÆÓÚÈË¹¤ÖÇÄÜ¼¼Êõ£¬ÒòÎªËüĞèÒªCLR¸ù¾İÔËĞĞÊ±¸ù¾İÊµ¼Ê³öÏÖµÄÇé¿öÀ´¶Ô´úÂë½øĞĞµ÷Õû£¬²»¹ıÓÉÓÚÏÖÔÚÈË¹¤ÖÇÄÜ¼¼Êõ»¹ÔÚ²»¶ÏµÄ·¢Õ¹¹ı³ÌÖĞ£¬¶øÇÒÆä×ÔÉíÒ²²¢²»Íê³ÉÊì£¬ËùÒÔÎÒÏëÎ¢Èí¿ÉÄÜ²¢²»ÊÇÊ¹ÓÃÒ»ÖÖÖÇÄÜĞÔÖÊµÄ¼¼ÊõÀ´Íê³ÉÕâÏî¹¤×÷µÄ¡£Ò»ÖÖ¿ÉÒÔÏëÏóµÄµ½£¬Ò²¿ÉÒÔÀí½âµÄ·½Ê½ÊÇÎ¢Èí½«Ó¦ÓÃÖĞµÄÒ»Ğ©ÔËĞĞÊ±µ÷Õû·½Ê½¹é½á³ÉÎª¡°´úÂëÔËĞĞÊ±µ÷ÕûÄ£Ê½¿â¡±£¬È»ºóCLRÔÙ¸ù¾İÕâ¸öÄ£Ê½¿âÔÚÔËĞĞÊ±¶Ô´úÂë½øĞĞÆ¥ÅäºÍµ÷Õû£¬ÔÚÎ´À´£¬Î¢Èí¿ÉÒÔ²»¶ÏµÄÀ©Õ¹ºÍÍê×´¿öÕâ¸öÄ£Ê½¿âÒÔÊ¹ÕâÖÖÓÅ»¯¿ÉÒÔ´ïµ½Ò»ÖÖ¸üºÃµÄĞ§¹û£©¡£

ÖØ¶ÁJefferyÏÈÉúµÄ¡¶.Net¿ò¼Ü³ÌĞòÉè¼Æ¡·Õâ±¾Êé£¬·¢ÏÖËû¶Ô.NetÖĞÄ³Ğ©¹Ø¼üÔªËØµÄ×Ü½áÕæµÄºÜÖµµÃ¶ÁÕß»ØÎ¶¡£ÒÔÏÂÊÇJefferÏÈÉú¶ÔÔªÊı¾İ¸ø.NetÓ¦ÓÃ³ÌĞò´øÀ´ÓÅÊÆµÄ×Ü½á¡£

ÔªÊı¾İÊ¡È¥ÁËÔ´´úÂë±àÒëÊ±¶ÔÍ·ÎÄ¼şµÄÒÀÀµ£¬ÕâÊÇÒòÎªÔÚº¬ÓĞÊµÏÖÀàĞÍºÍ³ÉÔ±µÄIL´úÂëÎÄ¼şµ±ÖĞ£¬ÒÑ¾­°üº¬ÁËËùÓĞ±»ÒıÓÃµÄÀàĞÍºÍ³ÉÔ±µÄĞÅÏ¢¡£±àÒëÆ÷¿ÉÒÔÖ±½Ó´ÓÍĞ¹ÜÄ£¿éÖĞ¶ÁÈ¡ÔªÊı¾İÀ´»ñµÃÕâĞ©ĞÅÏ¢¡£

vs.net¿ÉÒÔÀûÓÃÔªÊı¾İÀ´¸¨ÖúÎÒÃÇ±àĞ´´úÂë¡£ËüµÄÖÇÄÜ¸ĞÖªÌØĞÔ¾ÍÊÇÍ¨¹ı·ÖÎöÔªÊı¾İÀ´¸æËßÎÒÃÇÄ³¸öÀàĞÍÌá¹©ÁËÄÄĞ©·½·¨£¬ÒÔ¼°ÒÔÕâĞ©·½·¨ÓĞÄÄĞ©²ÎÊı¡£

CLRµÄ´úÂëÑéÖ¤¹ı³Ì¿ÉÒÔÀûÓÃÔªÊı¾İÀ´È·±£´úÂë½öÖ´ĞĞ¡°°²È«¡±µÄ²Ù×÷¡£

ÀûÓÃÔªÊı¾İ£¬ÎÒÃÇ¿ÉÒÔ½«Ò»¸ö¶ÔÏóµÄ×Ö¶ÎĞòÁĞ»¯µ½Ò»¸öÄÚ´æ¿éÖĞ£¬È»ºóÔ¶³Ì´«ËÍ¸øÁíÒ»Ì¨»úÆ÷£¬×îºóÔÙÔÚÔ¶³Ì¼ÆËã»úÉÏÖ´ĞĞ·´ĞòÁĞ»¯£¬´Ó¶øÖØĞÂ´´½¨¶ÔÏóºÍËûµÄ×´Ì¬£¨ÎÒÏëÕâÀïJefferyÏÈÉú¿ÉÄÜÖ¸µÄÊÇÍ¨¹ıÔªÊı¾İ¿ÉÒÔ»ñÈ¡µ½¶ÔÏóµÄ²¼¾Ö£¬½ø¶ø¿ÉÒÔĞòÁĞ»¯Ëü£¬¶øºÍÔ¶³Ì²»Ô¶³ÌµÄÃ»ÓĞÊ²Ã´¹ØÏµ£©¡£

ÀûÓÃÔªÊı¾İ£¬À¬»øÊÕ¼¯Æ÷Òª°É×·×Ù¶ÔÏóµÄÉú´æÖÜÆÚ¡£¶ÔÓÚÈÎºÎ¶ÔÏó£¬À¬»øÊÕ¼¯Æ÷¶¼ÄÜ¹»Í¨¹ıÔªÊı¾İÀ´È·¶¨¸Ã¶ÔÏóµÄÀàĞÍ£¬²¢ÇÒ¿ÉÒÔ»ñÖª¸Ã¶ÔÏóµÄÄÄĞ©×Ö¶ÎÒıÓÃÁËÆäËüµÄ¶ÔÏó£¨ÃÀÃîµÄÔªÊı¾İ£©¡£

CIL Instructions
_________________________________________________
Format                Assembly Format   Description
0x00                  nop
0x01                  break             ¶ÏµãÉèÖÃ£¬ÎÒÕâÀïÓÃ×÷halt.
0x02                  ldarg.0           load argument onto the stack
0x03                  ldarg.1
0x04                  ldarg.2
0x05                  ldarg.3
0x06                  ldloc.0           load local variable onto the stack
0x07                  ldloc.1
0x08                  ldloc.2
0x09                  ldloc.3
0x0A                  stloc.0
0x0B                  stloc.1
0x0C                  stloc.2
0x0D                  stloc.3
0x0E                  ldarg.s num       Load argument numbered num onto the stack, short form.
0x0F                  ldarga.s argNum   Fetch the address of argument argNum, short form.
0x10                  starg.s num       Store value to the argument numbered num, short form.
0x11<unsigned int8>   ldloc.s indx      Load local variable of index indx onto stack, short form.
0x12<unsigned int8>   ldloca.s indx     Load address of local variable with index indx, short form.
0x13<unsigned int8>   stloc.s indx      Pop a value from stack into local variable indx, short form.
0x14                  ldnull            Push a null reference on the stack.
                                        [It might be thought that ldnull is redundant: why not use ldc.i4.0 or ldc.i8.0 instead? The answer is
                                        that ldnull provides a size-agnostic null ¨C analogous to an ldc.i instruction, which does not exist. However,
                                        even if CIL were to include an ldc.i instruction it would still benefit verification algorithms to retain the ldnull
                                        instruction because it makes type tracking easier. ] agnostic ²»¿ÉÖªµÄ
                                          ldc.<type>: load numeric constant
0x15                  ldc.i4.m1           Push -1 onto the stack as int32.
0x15                  ldc.i4.M1           Push -1 of type int32 onto the stack as int32 (alias for ldc.i4.m1).
0x16                  ldc.i4.0            Push 0 onto the stack as int32.
0x17                  ldc.i4.1
0x18                  ldc.i4.2
0x19                  ldc.i4.3
0x1A                  ldc.i4.4
0x1B                  ldc.i4.5
0x1C                  ldc.i4.6
0x1D                  ldc.i4.7
0x1E                  ldc.i4.8
0x1F<int8>            ldc.i4.s num        Push num onto the stack as int32, short form.
0x20<int32>           ldc.i4 num          Push num of type int32 onto the stack as int32.
0x21<int64>           ldc.i8 num          Push num of type int64 onto the stack as int64.
0x22<float32>         ldc.r4 num          Push num of type float32 onto the stack as F.
0x23<float64>         ldc.r8 num          Push num of type float64 onto the stack as F.
0x25                  Dup                 Duplicate the value on the top of the stack.
0x26                  pop                 remove the top element of the stack
0x27<T>               jmp method          Exit current method and jump to the specified method.
0x28<T>               call method         Call method described by method.
0x29<T>               calli callsitedescr Call method indicated on the stack with arguments described by callsitedescr.
0x2A                  Ret                 Return from method, possibly with a value.
0x2B<int8>            br.s target         Branch to target, short form. <unconditional branch>
0x2C<int8>            brfalse.s target    Branch to target if value is zero (false), short form.
0x2D<int8>            brtrue.s target     Branch to target if value is non-zero (true), short form.
0x2E<int8>            beq.s target        Branch to target if equal, short form.
0x2F<int8>            bge.s target        Branch to target if greater than or equal to, short form.
0x30<int8>            bgt.s target        Branch to target if greater than, short form.
0x31<int8>            ble.s target        Branch to target if less than or equal to, short form.
0x32<int8>            blt.s target        Branch to target if less than, short form.
0x33<int8>            bne.un.s target     Branch to target if unequal or unordered, short form.
                                          The bne.un instruction transfers control to target if value1 is not equal to value2, when compared unsigned
                                          (for integer values) or unordered (for floating-point values).
                                          The effect is identical to performing a ceq instruction followed by a brfalse target.
0x34<int8> bge.un.s
0x35<int8> bgt.un.s
0x36<int8> ble.un.s
0x37<int8> blt.un.s
0x38<int32>           br target           Branch to target.<unconditional branch>
0x39 brfalse
0x3A brtrue
0x3B beq
0x3C bge
0x3D bgt
0x3E ble
0x3F blt
0x40 bne.un
0x41 bge.un
0x42 bgt.un
0x43 ble.un
0x44 blt.un
0x45<unsigned int32>  switch(t1, t2 ¡­ tN) table switch based on value. Jump to one of n values. Stack:(Value -- )
   <int32>¡­ <int32>                       The switch instruction implements a jump table. The format of the instruction is
                                           an unsigned int32 representing the number of targets N, followed by N int32 values
                                           specifying jump targets: these targets are represented as offsets (positive or negative)
                                           from the beginning of the instruction following this switch instruction.
0x46                  ldind.i1             Indirect load value of type int8 as int32 on the stack. Stack:(addr -- Value)
0x47                  ldind.u1
0x48                  ldind.i2
0x49                  ldind.u2
0x4A                  ldind.i4
0x4B                  ldind.u4
0x4C                  ldind.i8
0x4D                  ldind.i
0x4E                  ldind.r4
0x4F                  ldind.r8
0x50                  ldind.ref
0x51                  stind.ref
0x52                  stind.i1
0x53                  stind.i2
0x54                  stind.i4
0x55                  stind.i8
0x56                  stind.r4
0x57                  stind.r8
0x58                  add                 Add two values, returning a new value. (value1, value2 -- Result). <Only For Type-Safe value.>
0x59                  sub                 <Only For Type-Safe value.>
0x5A                  mul                 <Only For Type-Safe value.>
0x5B                  div                 <Only For Type-Safe value.>
0x5C                  div.un              <Only For Type-Safe value.>
0x5D                  rem                 <Only For Type-Safe value.>
0x5E                  rem.un              <Only For Type-Safe value.>
0x5F                  and                 <Only For Type-Safe value.>
0x60                  or                  <Only For Type-Safe value.>
0x61                  xor                 <Only For Type-Safe value.>
0x62                  shl                 <Only For Type-Safe value.>
0x63                  shr                 <Only For Type-Safe value.>
0x64                  shr.un              <Only For Type-Safe value.>
0x65                  neg                 <Only For Type-Safe value.>
0x66                  not                 <Only For Type-Safe value.>
0x67                 conv.i1               conv.<to type> ¨C data conversion. Convert to int8, pushing int32 on stack. (Value -- Result)
0x68                 conv.i2
0x69                 conv.i4
0x6A                 conv.i8
0x6B                 conv.r4
0x6C                 conv.r8
0x6D                 conv.u4
0x6E                 conv.u8
0x6F                 callvirt
0x70                 cpobj
0x71                 ldobj
0x72                 ldstr
0x73                 newobj
0x74                 castclass
0x75                 isinst
0x76                 conv.r.un
0x79                 unbox
0x7A                 throw
0x7B                 ldfld
0x7C                 ldflda
0x7D                 stfld
0x7E                 ldsfld
0x7F                 ldsflda
0x80                 stsfld
0x81<T>              stobj typeTok           Store a value of type typeTok at an address. (dest, src --)
                                             If typeTok is a value type, the stobj instruction copies the value src to the address dest.
                                             If typeTok is a reference type, the stobj instruction has the same effect as stind.ref.
0x82                 conv.ovf.i1.un
0x83                 conv.ovf.i2.un
0x84                 conv.ovf.i4.un
0x85                 conv.ovf.i8.un
0x86                 conv.ovf.u1.un
0x87                 conv.ovf.u2.un
0x88                 conv.ovf.u4.un
0x89                 conv.ovf.u8.un
0x8A                 conv.ovf.i.un
0x8B                 conv.ovf.u.un
0x8C<T>              box typeTok             Convert a boxable value to its boxed form. (val -- obj)
                                             If typeTok is a value type, the box instruction converts val to its boxed form.
                                             When typeTok is a non-nullable type (¡ì1.8.2.4), this is done by creating a new
                                             object and copying the data from val into the newly allocated object. If it is
                                             a nullable type, this is done by inspecting val¡¯s HasValue property; if it is
                                             false, a null reference is pushed onto the stack; otherwise, the result of boxing
                                             val¡¯s Value property is pushed onto the stack. If typeTok is a reference type,
                                             the box instruction does nothing.
0x8D                 newarr
0x8E                 ldlen
0x8F                 ldelema
0x90                 ldelem.i1
0x91                 ldelem.u1
0x92                 ldelem.i2
0x93                 ldelem.u2
0x94                 ldelem.i4
0x95                 ldelem.u4
0x96                 ldelem.i8
0x97                 ldelem.i
0x98                 ldelem.r4
0x99                 ldelem.r8
0x9A                 ldelem.ref
0x9B                 stelem.i
0x9C                 stelem.i1
0x9D                 stelem.i2
0x9E                 stelem.i4
0x9F                 stelem.i8
0xA0                 stelem.r4
0xA1                 stelem.r8
0xA2                 stelem.ref
0xA3                 ldelem
0xA4                 stelem
0xA5                 unbox.any
0xB3                 conv.ovf.i1
0xB4                 conv.ovf.u1
0xB5                 conv.ovf.i2
0xB6                 conv.ovf.u2
0xB7                 conv.ovf.i4
0xB8                 conv.ovf.u4
0xB9                 conv.ovf.i8
0xBA                 conv.ovf.u8
0xC2                 refanyval
0xC3                 ckfinite
0xC6                 mkrefany
0xD0                 ldtoken
0xD1                 conv.u2
0xD2                 conv.u1
0xD3                 conv.i
0xD4                 conv.ovf.i
0xD5                 conv.ovf.u
0xD6                 add.ovf
0xD7                 add.ovf.un
0xD8                 mul.ovf
0xD9                 mul.ovf.un
0xDA                 sub.ovf
0xDB                 sub.ovf.un
0xDC                 endfinally(endfault)    End finally(fault) clause of an exception block.
                                             Return from the finally or fault clause of an exception block
                                             (see the Exception Handling subclause of Partition I for details).
0xDD<int32>          leave target            Exit a protected region of code.
0xDE<int8>           leave.s target          Exit a protected region of code, short form.
                                             The leave instruction unconditionally transfers control to target.
                                             target is represented as a signed offset (4 bytes for leave, 1 byte
                                             for leave.s) from the beginning of the instruction following the current instruction.
                                             The leave instruction is similar to the br instruction, but the former can be used
                                             to exit a try, filter, or catch block whereas the ordinary branch instructions can
                                             only be used in such a block to transfer control within it. The leave instruction
                                             empties the evaluation stack and ensures that the appropriate surrounding finally blocks
                                             are executed.
0xDF                 stind.i
0xE0                 conv.u
0xFE 0x00            arglist
0xFE 0x01            ceq
0xFE 0x02            cgt
0xFE 0x03            cgt.un
0xFE 0x04            clt
0xFE 0x05            clt.un
0xFE 0x06            ldftn
0xFE 0x07            ldvirtftn
0xFE 0x09            ldarg
0xFE 0x0A            ldarga
0xFE 0x0B            starg
0xFE 0x0C            ldloc
0xFE 0x0D            ldloca
0xFE 0x0E            stloc
0xFE 0x0F            localloc
0xFE 0x11            endfilter                 End an exception handling filter clause. (value -- )
                                               Used to return from the filter clause of an exception
                                               (see the Exception Handling subclause of Partition I for a
                                               discussion of exceptions). value (which shall be of type int32
                                               and one of a specific set of values) is returned from the filter
                                               clause. It should be one of:
                                                 * exception_continue_search (0) to continue searching for an exception handler
                                                 * exception_execute_handler (1) to start the second phase of exception handling where
                                                   finally blocks are run until the handler associated with this filter clause is located. Then the
                                                   handler is executed.
                                               The result of using any other integer value is unspecified.

0xFE 0x12            unaligned.
0xFE 0x13            volatile.
0xFE 0x14            tail.
0xFE 0x15            initobj
0xFE 0x17            cpblk
0xFE 0x18            initblk
0xFE 0x1A            rethrow
0xFE 0x1C            sizeof
0xFE 0x1D            refanytype

TurboScript Extented Instructions:
