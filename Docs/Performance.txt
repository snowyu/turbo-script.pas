<Include("Claim")/>
=>著者：Riceball LEE>=

测试全部采用 QueryPerformanceCounter 高精度计数【Lua这个家伙不支持int64让我头疼了一阵，还好我想到了解决的方法】。

我这里测试指令：只简单测试加法运算；总共测试2017个加法指令与常数直接相加，最后的结果应该为：300*2017=605100

另外我还将测试子程序调用的速度。

没有比较是不行的，我用机器语言直接运行的效率和脚本相比!

== 加法指令速度比拼 ==

下面是加法指令直接运行的速度：

=== x86汇编 ===
<code>
  ;计时开始
  MOV EBX, 300  BB2C010000
  ADD EBX, 300  81C32C010000
  ..... --- 总计 2017 次
  ADD EBX, 300  81C32C010000
  ;计时结束
</code>
 
结果运行时间：60

=== Lua Script 脚本 ===
<code>
  (计时开始)
  local count = 300
  count = count + 300
    ..... （总计 2017 次）
  count = count + 300
  (计时结束)
</code>

【Lua5.0.2】运行时间： 110 
【Lua5.1 】 运行时间： 120


=== EUPHORIA 加法指令顺序执行效率测试脚本 ===
<code>
  --计时开始
    count = 300
    count +=300
    ..... --- 总计 2017 次
    count +=300
  --计时结束
</code>
 
结果运行时间：74 

=== TurboScript 脚本 ===
<code>
  //计时开始
  300
  300 +
    ..... （总计 2017 次）
  300 +
  //(计时结束
</code>
 
结果运行时间：87 【比汇编慢0.31倍； 如果当我进一步取消CPUStates(判断终止标志位)测试，运行时间居然和汇编差不多了：61！嘿嘿。】


== 子过程调用的速度比拼 ==

=== x86 汇编 子过程调用效率测试脚本 ===
<code>
function add(a,b: integer): integer;
asm
  mov EAX, a
  add EAX, b
end;
--计时开始
  asm
    mOV EAX, 300
    MOV EDX, 300    CALL ADD
    ..... （总计 2017 次）
    MOV EDX, 300    CALL ADD
--计时结束
</code>

结果运行时间：126

=== Lua Script 脚本 ===
<code>
function iAdd(a, b)
  return a+b
end function
  (计时开始)
  local count = 300
  count = iAdd(count, 300)
    ..... （总计 2017 次）
  count = iAdd(count, 300)
  (计时结束)
</code>

【Lua5.0.2】运行时间：1270 
【Lua5.1 】  运行时间：1820


=== EUPHORIA 子过程调用效率测试脚本 ===
<code>
function iAdd(integer a, integer b)
  return a+b
end function
--计时开始
count = 300
count = iAdd(count, 300)
..... --- 总计 2017 次
count = iAdd(count, 300)
--计时结束
</code>
 
结果运行时间：522 【比汇编慢了近0.759倍，比TurboScript 近调用慢近0.70倍】


=== TurboScript 子过程近调用效率测试 ===
<code>
: Add +;
//--计时开始
300
300 Add
..... （总计 2017 次）
300 Add
//--计时结束
</code>
结果运行时间：157【只比汇编慢0.197倍，改用字节代码流后速度略有损失，现在的运行时间：169】

=== TurboScript 子过程模块之间的VM DLL远调用效率 ===
<code>
: Add external 'test'; //该函数在另一文件中。
//--计时开始
300
300 Add
..... （总计 2017 次）
300 Add
//--计时结束
</code>

启用按需加载技术的结果运行时间：1082【不稳定徘徊在1082-8828】
使用的是按需加载技术，也就是仅当该函数被调用的时候才加载，然后加上Cache技术，后面的调用就在内存中处理。
时间远远长于其它，是因为加载文件耗去了绝大部分时间
不启用按需加载技术，而是预先加载模块：
结果运行时间：202  <如果不使用Cache功能每次都要查找所花时间：1790>

== 网站 ==
 * Lua: http://www.lua.org
 * EUPHORIA: http://www.rapideuphoria.com
 * TurboScript: http://www.mesdk.com [建造中]
 
== 速度图 ==
